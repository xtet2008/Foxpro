* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



PROCEDURE IsTag
	LPARAMETER TCTAGNAME , TCALIAS
	LOCAL LLISTAG , LCTAGFOUND
	IF PARAMETERS() < 2
		TCALIAS = ALIAS()
	ENDIF
	IF EMPTY(TCALIAS)
		RETURN .F.
	ENDIF
	LLISTAG = .F.
	TCTAGNAME = UPPER(ALLTRIM(TCTAGNAME))
	LNTAGNUM = 1
	LCTAGFOUND = TAG(LNTAGNUM,TCALIAS)
	DO WHILE  .NOT. EMPTY(LCTAGFOUND)
		IF UPPER(ALLTRIM(LCTAGFOUND)) == TCTAGNAME
			LLISTAG = .T.
			EXIT
		ENDIF
		LNTAGNUM = LNTAGNUM + 1
		LCTAGFOUND = TAG(LNTAGNUM,TCALIAS)
	ENDDO
	RETURN LLISTAG
ENDPROC
*------
PROCEDURE NotYet
	= MESSAGEBOX('Under Construction',64)
	RETURN
ENDPROC
*------
PROCEDURE it_Sumup
	LPARAMETER PLVAR , PLDBF , PLSEEK , PLFOR , PLFM , PLTO
	LOCAL PLFM , PLTO , PLVALUE , PLVAR , PLLOCALDBF
	PLLOCALDBF = SELECT()
	SELECT (PLDBF)
	IF  .NOT. EMPTY(PLSEEK)
		SET ORDER TO (PLSEEK)
	ENDIF
	GO TOP
	SEEK PLFM
	PLVALUE = 0
	IF EMPTY(PLTO)
		PLTO = PLFM
	ENDIF
	sum &plvar. while plfm==&plfor.  to plvalue
	SELECT (PLLOCALDBF)
	RETURN PLVALUE
ENDPROC
*------
PROCEDURE itmsg
	LPARAMETER PLKEY , PLFIELD , PLREMARKS , PLLANG , PLFORM
	LOCAL PLSELECTITMSG , PLITMSG , PLITLANG
	SET TALK OFF
	PLITMSG = ''
	PLSELECTITMSG = SELECT()
	SELECT 0
	PLITLANG = DEF_LANG
	IF  .NOT. EMPTY(PLLANG)
		PLITLANG = PLLANG
	ENDIF
	IF  .NOT. EMPTY(PLFIELD)
		IF  .NOT. USED('itmsg')
			USE IN 0 caption AGAIN ALIAS ITMSG ORDER id
		ELSE
			SELECT ITMSG
			SET ORDER TO id
		ENDIF
		SELECT ITMSG
		SEEK ALLTRIM(UPPER(PLKEY)) + PLITLANG
		IF FOUND()
			plitmsg=alltrim(&plfield.)
		ENDIF
	ELSE
		IF  .NOT. USED('itmessag')
			IF FILE('itmessag.dbf')
				USE IN 0 itmessag AGAIN ORDER id
			ELSE
				USE IN 0 (GCOLDDIR + 'include\itmessag') AGAIN ALIAS ITMESSAG ORDER id
			ENDIF
		ELSE
			SELECT ITMESSAG
			SET ORDER TO id
		ENDIF
		SELECT ITMESSAG
		SEEK PLITLANG + SUBSTR(UPPER(PLKEY),1,5)
		IF FOUND()
			PLITMSG = ALLTRIM(MESSAGE)
			IF  .NOT. EMPTY(PLFORM)
				IF UPPER(PLFORM) = 'BUTTON' .OR. UPPER(ALLTRIM(PLFORM)) = '1'
					PLITMSG = ALLTRIM(BUTTON)
				ENDIF
				IF UPPER(PLFORM) = 'SHORTFORM' .OR. UPPER(ALLTRIM(PLFORM)) = '2'
					PLITMSG = ALLTRIM(SHORTFORM)
				ENDIF
				IF UPPER(PLFORM) = 'HELP' .OR. UPPER(ALLTRIM(PLFORM)) = '3'
					PLITMSG = ALLTRIM(HELP)
				ENDIF
			ENDIF
		ENDIF
	ENDIF
	SELECT (PLSELECTITMSG)
	RETURN PLITMSG
ENDPROC
*------
PROCEDURE FileSize
	LPARAMETER TCFILENAME
	LOCAL LCSETCOMPATIBLE , LNFILESIZE
	LCSETCOMPATIBLE = SET('COMPATIBLE')
	SET COMPATIBLE ON
	LNFILESIZE = FSIZE(TCFILENAME)
	SET COMPATIBLE &lcSetCompatible
	RETURN LNFILESIZE
ENDPROC
*------
PROCEDURE FormIsObject
	RETURN (TYPE('_screen.activeform') == 'O' AND UPPER(_SCREEN.ACTIVEFORM.BASECLASS) = 'FORM')
ENDPROC
*------
PROCEDURE OnShutdown
	ON ERROR RETURN .T.
	IF DEF_LANG = 'ENG'
		IF MESSAGEBOX('Logout System ?',292,'LOGOUT') = 7
			RETURN
		ENDIF
	ELSE
		IF MESSAGEBOX(ITMSG('00082'),292,ITMSG('00083')) = 7
			RETURN
		ENDIF
	ENDIF
	= PAULLOGIN_OUT(USER_NAME,'LOGOUT')
	= MESSAGEBOX('Shut down International Trader database ! ',48,'International Trader')
	QUIT
	CLEAR ALL
	CLOSE ALL
	RETURN
ENDPROC
*------
PROCEDURE IsACCESS
	LPARAMETER TCSCREEN_KEY , TCSECURITY_ID , TSWINDOW_NAME , TCFIELD
	LOCAL TCSCREEN_KEY , TCSECURITY_ID , VPAULPROGRAM
	IF  .NOT. EMPTY(TSWINDOW_NAME)
		IF WEXIST(TSWINDOW_NAME)
			ACTIVATE WINDOW &tswindow_name.
			RETURN .F.
		ENDIF
	ENDIF
	m.ICON_ACCESS = .F.
	SELECT_WK = SELECT()
	IF  .NOT. USED('SECURITY')
		USE IN 0 SECURITY ORDER ID
	ENDIF
	SELECT SECURITY
	IF SEEK(UPPER(TCSECURITY_ID + TCSCREEN_KEY))
		ICON_ACCESS = ICON_ACCESS
		IF  .NOT. EMPTY(TCFIELD)
			ICON_ACCESS=&tcfield.
		ENDIF
		USE IN SECURITY
	ENDIF
	IF TRADE_MARK
		m.ICON_ACCESS = .T.
	ENDIF
	IF M.ICON_ACCESS
		= ITSYSTEMLOG('',TCSCREEN_KEY,'','','','','ACCESS','OK !')
	ELSE
		= ITSYSTEMLOG('',TCSCREEN_KEY,'','','','','ACCESS','FAILED !')
	ENDIF
	SELECT (SELECT_WK)
	IF EMPTY(TCFIELD)
		VPAULPROGRAM =  ;
			PAULRETURN('N','caption','id','screen_id',ALLTRIM(TCSCREEN_KEY) + DEF_LANG,'it_program','')
		IF  .NOT. EMPTY(VPAULPROGRAM) AND M.ICON_ACCESS
			OAPP.DOFORM(VPAULPROGRAM)
			SELECT (SELECT_WK)
			RETURN .F.
		ENDIF
	ENDIF
	IF TRADE_MARK .OR. M.ICON_ACCESS
		IF DEF_LANG <> 'ENG'
			WAIT WINDOW NOWAIT ITMSG('00084')
		ELSE
			WAIT WINDOW NOWAIT 'Open Records ... '
		ENDIF
		RETURN .T.
	ELSE
		= MESSAGEBOX(ITMSG('00085'),304,ITMSG('00080'))
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE it_query
	LPARAMETER PLFORM , PLDBF , PLSEEK , PLCURRENT
	SELECT 0
	IF  .NOT. EMPTY(PLFORM)
		KEYVALUE1 = PLFORM
		KEYVALUE2 = PLDBF
		KEYVALUE3 = PLSEEK
		KEYVALUE4 = PLCURRENT
		LOCAL PAULFORM
		PAULFORM = ALLTRIM(PLFORM)
		do form &paulform.
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE ITEMEXIST
	LPARAMETER TCSCREEN_KEY , TCSECURITY_ID
	LOCAL TCSCREEN_KEY , TCSECURITY_ID
	IF TCSCREEN_KEY = TCSECURITY_ID
		RETURN .T.
	ELSE
		= MESSAGEBOX('This Product Item Has Been Deleted !',304,'WARNING MESSAGE')
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE paulUPDATEDATETIME
	LPARAMETER PLCONTROLSOURCE
	IF EMPTY(PLCONTROLSOURCE)
		RETURN 'N'
	ENDIF
	LOCAL VPAULCONTROL , VPAULFIELD , VPAULTABLE , VPAULDATETIME , VPAULADATE
	VPAULCONTROL = PLCONTROLSOURCE
	VPAULFIELD =  ;
		ALLTRIM(SUBSTR(VPAULCONTROL,AT('.',VPAULCONTROL) + 1,LEN(VPAULCONTROL)))
	VPAULTABLE = ALLTRIM(SUBSTR(VPAULCONTROL,1,AT('.',VPAULCONTROL) - 1))
	VPAULDATETIME = VPAULTABLE + '.adatetime'
	VPAULADATE = VPAULTABLE + '.adate'
	IF CURSORGETPROP('Buffering',VPAULTABLE) = 1
		RETURN 'N'
	ENDIF
	IF (GETFLDSTATE(VPAULFIELD,VPAULTABLE) = 1)
		RETURN 'N'
	ENDIF
	IF VARTYPE(ADATETIME) = 'T'
		replace &vpauldatetime. with datetime()
	ENDIF
	IF VARTYPE(ADATE) = 'C'
		replace &vpauladate. with pauluser_create()
	ENDIF
	RETURN 'Y'
ENDPROC
*------
PROCEDURE CNUMBER
	LPARAMETER NB , NAME_CENTS
	LOCAL NB , NAME_CENTS
	CNUMBER = PRINT_NUM(NB)
	DEC_NUM = INT(NB * 100) - INT(NB) * 100
	IF DEC_NUM >= 1
		IF AT(' and ',CNUMBER) > 0
			CNUMBER = STRTRAN(CNUMBER,' and')
		ENDIF
		IF EMPTY(NAME_CENTS)
			NAME_CENTS = ' and Cent'
			IF DEC_NUM > 1
				CNUMBER = CNUMBER + NAME_CENTS + 's '
			ELSE
				CNUMBER = CNUMBER + NAME_CENTS + ' '
			ENDIF
		ELSE
			NAME_CENTS = ' and ' + ALLTRIM(NAME_CENTS)
			CNUMBER = CNUMBER + NAME_CENTS + ' '
		ENDIF
	ENDIF
	CNUMBER = CNUMBER + PRINT_NUM(DEC_NUM) + ' Only'
	RETURN CNUMBER
ENDPROC
*------
PROCEDURE Print_num
	PARAMETER NUM
	PAULSIGN = ''
	IF NUM < 0
		PAULSIGN = ' - '
	ENDIF
	A_HUNDRED = 100
	A_THOUSAND = 1000
	A_MILLION = 1000000
	IF NUM < 20
		VALUE = NUM_LESS_THAN_20(INT(NUM))
	ELSE
		IF NUM < A_HUNDRED
			VALUE = PRINT_TENS(INT(NUM / 10))
			IF (INT(MOD(NUM,10))) <> 0
				VALUE = VALUE + ' ' + PRINT_NUM(INT(MOD(NUM,10)))
			ENDIF
		ELSE
			IF NUM < A_THOUSAND
				IF INT(NUM / A_HUNDRED) > 1
					VALUE = PRINT_NUM(INT(NUM / A_HUNDRED)) + ' Hundred'
				ELSE
					VALUE = PRINT_NUM(INT(NUM / A_HUNDRED)) + ' Hundred'
				ENDIF
				IF (INT(MOD(NUM,A_HUNDRED))) <> 0
					VALUE = VALUE + ' and ' + PRINT_NUM(INT(MOD(NUM,A_HUNDRED)))
				ENDIF
			ELSE
				IF NUM < A_MILLION
					IF INT(NUM / A_THOUSAND) > 1
						VALUE = PRINT_NUM(INT(NUM / A_THOUSAND)) + ' Thousand'
					ELSE
						VALUE = PRINT_NUM(INT(NUM / A_THOUSAND)) + ' Thousand'
					ENDIF
					IF (INT(MOD(NUM,A_THOUSAND))) <> 0
						IF (MOD(NUM,A_THOUSAND)) < A_HUNDRED
							VALUE = VALUE + ' and '
						ELSE
							VALUE = VALUE + ' '
						ENDIF
						VALUE = VALUE + PRINT_NUM(INT(MOD(NUM,A_THOUSAND)))
					ENDIF
				ELSE
					IF INT(NUM / A_MILLION) > 1
						VALUE = PRINT_NUM(INT(NUM / A_MILLION)) + ' Million'
					ELSE
						VALUE = PRINT_NUM(INT(NUM / A_MILLION)) + ' Million'
					ENDIF
					IF (INT(MOD(NUM,A_MILLION))) <> 0
						IF (MOD(NUM,A_MILLION)) < A_HUNDRED
							VALUE = VALUE + ' and '
						ELSE
							VALUE = VALUE + ' '
						ENDIF
						VALUE = VALUE + PRINT_NUM(INT(MOD(NUM,A_MILLION)))
					ENDIF
				ENDIF
			ENDIF
		ENDIF
	ENDIF
	RETURN PAULSIGN + VALUE
ENDPROC
*------
PROCEDURE Num_less_than_20
	PARAMETER SMALL_NUM
	DIMENSION WORD( 19 )
	WORD( 1 ) = 'One'
	WORD( 2 ) = 'Two'
	WORD( 3 ) = 'Three'
	WORD( 4 ) = 'Four'
	WORD( 5 ) = 'Five'
	WORD( 6 ) = 'Six'
	WORD( 7 ) = 'Seven'
	WORD( 8 ) = 'Eight'
	WORD( 9 ) = 'Nine'
	WORD( 10 ) = 'Ten'
	WORD( 11 ) = 'Eleven'
	WORD( 12 ) = 'Twelve'
	WORD( 13 ) = 'Thirteen'
	WORD( 14 ) = 'Fourteen'
	WORD( 15 ) = 'Fifteen'
	WORD( 16 ) = 'Sixteen'
	WORD( 17 ) = 'Seventeen'
	WORD( 18 ) = 'Eighteen'
	WORD( 19 ) = 'Nineteen'
	IF SMALL_NUM < 1 .OR. SMALL_NUM > 19
		RETURN CHR(32)
	ELSE
		RETURN WORD(SMALL_NUM)
	ENDIF
ENDPROC
*------
PROCEDURE Print_tens
	PARAMETER TENS
	DIMENSION WORD( 9 )
	WORD( 1 ) = 'Ten'
	WORD( 2 ) = 'Twenty'
	WORD( 3 ) = 'Thirty'
	WORD( 4 ) = 'Forty'
	WORD( 5 ) = 'Fifty'
	WORD( 6 ) = 'Sixty'
	WORD( 7 ) = 'Seventy'
	WORD( 8 ) = 'Eighty'
	WORD( 9 ) = 'Ninety'
	IF TENS < 1 .OR. TENS > 9
		RETURN CHR(32)
	ELSE
		RETURN WORD(TENS)
	ENDIF
ENDPROC
*------
PROCEDURE errhand
	PARAMETER MERROR , MESS , MESS1 , MPROG , MLINENO
	ERROR_YN = .T.
	MESSAGEBOX('Error number: ' + LTRIM(STR(ERROR())) + CHR(13) + 'Error message: ' + MESSAGE() +  ;
		CHR(13) +  ;
		'Line of code with error: ' +  ;
		MESSAGE(1))
ENDPROC
*------
PROCEDURE errhand2
	PARAMETER MERROR , MESS , MESS1 , MPROG , MLINENO
	ERROR_YN = .T.
ENDPROC
*------
PROCEDURE tsGEN_NO
	LPARAMETER TSDBF , TSSEEK_VALUE , TSKEY , TSGEN_NO , TSPLUSONE , TSFORMULA , TSMASTER ,  ;
		TSMASTERKEY , TSRECEXIST_LOC , TSPLUSTWO , TSDBF2 , TSAUTOGEN ,  ;
		TSDOC_RUNNINGNO , TSDOC_RUNNINGFROM
	LOCAL SELECT_WK , TSDOC_NO , GENNO , PLTEMPONE , PLTEMPTWO , TSAUTOGEN , LCOLDEXPR
	LCOLDEXPR = ''
	IF EMPTY(TSAUTOGEN)
		TSAUTOGEN = 'N'
	ENDIF
	IF  .NOT. EMPTY(TSDOC_RUNNINGNO)
		IF  .NOT. EMPTY(TSDOC_RUNNINGFROM)
			&tsDOC_RUNNINGNO.=tsDOC_RUNNINGFROM
		ELSE
			&tsDOC_RUNNINGNO.=1
		ENDIF
	ENDIF
	SELECT_WK = SELECT()
	IF USED(TSDBF)
		SELECT (TSDBF)
		LCOLDEXPR = FILTER()
		SET FILTER TO
	ELSE
		USE IN 0 (TSDBF)
		SELECT (TSDBF)
	ENDIF
	= CURSORSETPROP('buffering',3)
	SET DELETED OFF
	set order to &tsKEY.
	GO TOP
	SEEK TSSEEK_VALUE
	IF FOUND()
		IF &tsGEN_NO.
			IF  .NOT. NOCOUNTBACK .OR. TSAUTOGEN = 'Y'
				pltempone=&tsPLUSONE.
				IF  .NOT. EMPTY(TSPLUSTWO)
					pltemptwo=&tsPLUSTWO.
					IF PLTEMPTWO - 2 > 0
						REPLACE &tsPLUSTWO. WITH &tsPLUSTWO. - 2
					ELSE
						REPLACE &tsPLUSTWO. WITH 1
					ENDIF
				ENDIF
				IF PLTEMPONE - 2 > 0
					REPLACE &tsPLUSONE. WITH &tsPLUSONE. - 2
				ELSE
					REPLACE &tsPLUSONE. WITH 1
				ENDIF
			ENDIF
			GENNO=&tsFORMULA.
			tsDOC_NO=&GENNO.
			IF  .NOT. EMPTY(TSPLUSTWO)
				REPLACE &tsPLUSTWO. WITH &tsPLUSTWO.+ 1
				= TABLEUPDATE(.T.,.T.,TSDBF2)
			ENDIF
			REPLACE &tsPLUSONE. WITH &tsPLUSONE. + 1
			= TABLEUPDATE(.T.,.T.,TSDBF)
			IF  .NOT. EMPTY(TSDOC_RUNNINGNO)
				&tsDOC_RUNNINGNO.=&tsDOC_RUNNINGNO. +1
			ENDIF
			TSDOCGEN_COUNTER = 1
			DO WHILE SEEK(TSDOC_NO,TSMASTER,TSMASTERKEY)
				SELECT (TSDBF)
				GENNO=&tsFORMULA.
				tsDOC_NO=&GENNO.
				REPLACE &tsPLUSONE. WITH &tsPLUSONE.+ 1
				= TABLEUPDATE(.T.,.T.,TSDBF)
				IF  .NOT. EMPTY(TSPLUSTWO)
					SELECT (TSDBF2)
					REPLACE &tsPLUSTWO. WITH &tsPLUSTWO.+ 1
					= TABLEUPDATE(.T.,.T.)
				ENDIF
				IF  .NOT. EMPTY(TSDOC_RUNNINGNO)
					&tsDOC_RUNNINGNO.=&tsDOC_RUNNINGNO. +1
				ENDIF
				TSDOCGEN_COUNTER = TSDOCGEN_COUNTER + 1
				IF TSDOCGEN_COUNTER > 9999
					EXIT
				ENDIF
				SELECT (TSDBF)
			ENDDO
			IF  .NOT. NOCOUNTBACK .OR. TSAUTOGEN = 'Y'
				IF  .NOT. EMPTY(TSPLUSTWO)
					if pltemptwo > &tsPLUSTWO.
						REPLACE &tsPLUSTWO. WITH pltemptwo
					ENDIF
				ENDIF
				IF pltempone > &tsPLUSONE.
					REPLACE &tsPLUSONE. WITH pltempone
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(TSPLUSTWO)
				= TABLEUPDATE(.T.,.T.,TSDBF2)
			ENDIF
			= TABLEUPDATE(.T.,.T.,TSDBF)
			GO BOTTOM IN (TSMASTER) BOTTOM
		ELSE
			TSDOC_NO = ''
		ENDIF
	ELSE
		TSDOC_NO = ''
	ENDIF
	SET DELETED ON
	IF  .NOT. EMPTY(LCOLDEXPR)
		SELECT (TSDBF)
		set filter to &lcOldExpr
	ENDIF
	SELECT (SELECT_WK)
	RETURN TSDOC_NO
ENDPROC
*------
PROCEDURE paulCLIENT_ID
	LPARAMETER TSDBF , TSALIAS , TSSCREEN_NAME , TSSEEK_KEY1 , TSSEEK_KEY2 , TSVARIABLE1 ,  ;
		TSVARIABLE2 , TSVAR_DISP1 , TSVAR_DISP2 , TSVAR_DISP11 , TSVAR_DISP21 ,  ;
		TSVARIABLE3 , TSVAR_DISP3 , TSVARIABLE4 , TSVAR_DISP4 , TSVARIABLE5 ,  ;
		TSVAR_DISP5 , TSFILTER , TSSTKEY , TSSECDBF , TSSECALIAS , TSSECKEY
	LOCAL SELECT_WK , TSDOC_NO , JKRECNO_NO , TSDOC_NO
	APPEND_YN = .F.
	SELECT_WK = SELECT()
	IF USED(TSALIAS)
		SELECT (TSALIAS)
	ELSE
		USE IN 0 (TSDBF) AGAIN ALIAS (TSALIAS)
		SELECT (TSALIAS)
	ENDIF
	IF  .NOT. EMPTY(TSSECDBF)
		IF USED(TSSECALIAS)
			SELECT (TSSECALIAS)
			set order to &tsseckey.
		ELSE
			USE IN 0 (TSSECDBF) AGAIN ALIAS (TSSECALIAS)
			SELECT (TSSECALIAS)
			set order to &tsseckey.
		ENDIF
		SELECT (TSALIAS)
		SET RELATION TO &tsstkey. into (tssecalias)
	ENDIF
	IF  .NOT. EMPTY(TSFILTER)
		set filter to &tsFILTER.
	ENDIF
	JKRECNO_NO = RECNO()
	IF EOF()
		GO TOP
		JKRECNO_NO = RECNO()
		IF EOF()
			RETURN ''
		ENDIF
	ENDIF
	LOCAL APPQRY2
	APPQRY2 = CREATEOBJECT('REC_SELECT')
	APPQRY2.CAPTION = TSSCREEN_NAME
	APPQRY2.TXTBROWSER.RECORDSOURCE = TSALIAS
	APPQRY2.TXTBROWSER.COLUMN1.CONTROLSOURCE = TSVARIABLE1
	APPQRY2.TXTBROWSER.COLUMN2.CONTROLSOURCE = TSVARIABLE2
	IF  .NOT. EMPTY(TSVAR_DISP11)
		APPQRY2.TXTBROWSER.COLUMN1.HEADER1.CAPTION = TSVAR_DISP11
	ELSE
		APPQRY2.TXTBROWSER.COLUMN1.HEADER1.CAPTION = TSVAR_DISP1
	ENDIF
	IF  .NOT. EMPTY(TSVAR_DISP21)
		APPQRY2.TXTBROWSER.COLUMN2.HEADER1.CAPTION = TSVAR_DISP21
	ELSE
		APPQRY2.TXTBROWSER.COLUMN2.HEADER1.CAPTION = TSVAR_DISP2
	ENDIF
	IF  .NOT. EMPTY(TSVARIABLE3)
		APPQRY2.COLUMNYN3 = .T.
		APPQRY2.TXTBROWSER.COLUMN3.CONTROLSOURCE = TSVARIABLE3
		APPQRY2.TXTBROWSER.COLUMN3.HEADER1.CAPTION = TSVAR_DISP3
	ELSE
		APPQRY2.TXTBROWSER.RESIZEABLEWIDTH = .T.
	ENDIF
	IF  .NOT. EMPTY(TSVARIABLE4)
		APPQRY2.COLUMNYN4 = .T.
		APPQRY2.TXTBROWSER.COLUMN4.CONTROLSOURCE = TSVARIABLE4
		APPQRY2.TXTBROWSER.COLUMN4.HEADER1.CAPTION = TSVAR_DISP4
	ENDIF
	IF  .NOT. EMPTY(TSVARIABLE5)
		APPQRY2.COLUMNYN5 = .T.
		APPQRY2.TXTBROWSER.COLUMN5.CONTROLSOURCE = TSVARIABLE5
		APPQRY2.TXTBROWSER.COLUMN5.HEADER1.CAPTION = TSVAR_DISP5
	ENDIF
	APPQRY2.TABLE_NAME = TSALIAS
	APPQRY2.KEY1.VALUE = SPACE(10)
	APPQRY2.KEYNAME1.CAPTION = TSVAR_DISP1
	APPQRY2.SEEKFIELD = TSSEEK_KEY1
	APPQRY2.KEY2.VALUE = SPACE(40)
	APPQRY2.KEYNAME2.CAPTION = TSVAR_DISP2
	APPQRY2.SEEKFIELD2 = TSSEEK_KEY2
	APPQRY2.SHOW()
	TSDOC_NO = ''
	IF APPEND_YN
		tsDOC_NO=&tsVARIABLE1.
	ELSE
		TSDOC_NO = ''
		GO JKRECNO_NO
	ENDIF
	IF  .NOT. EMPTY(TSSECDBF)
		IF USED(TSSECALIAS)
			USE IN (TSSECALIAS)
		ENDIF
	ENDIF
	SELECT (SELECT_WK)
	RETURN TSDOC_NO
ENDPROC
*------
PROCEDURE paulREPLACEPACK
	LPARAMETER PLFRCUST , PLCUSTDBF , PLITEMDBF
	LOCAL VPLVARIABLES , VPLFROMDBF
	IF PLFRCUST
		VPLFROMDBF = ALLTRIM(PLCUSTDBF)
	ELSE
		VPLFROMDBF = ALLTRIM(PLITEMDBF)
	ENDIF
	VPLVARIABLES = VPLFROMDBF + '.INNER_QTY'
	REPLACE    INNER_QTY    with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.INNER_UNIT'
	REPLACE    INNER_UNIT       with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.INNER_PACK'
	REPLACE    INNER_PACK       with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.CTN_QTY'
	REPLACE    CTN_QTY          with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.CTN_UNIT'
	REPLACE    CTN_UNIT         with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.CTN_PACK'
	REPLACE    CTN_PACK         with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.LENGTH'
	REPLACE    LENGTH           with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.HIGHT'
	REPLACE    HIGHT            with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.WIDTH'
	REPLACE    WIDTH            with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.MEASURE_UNIT'
	REPLACE    MEASURE_UNIT     with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.NET_WT'
	REPLACE    NET_WT           with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.GRS_WT'
	REPLACE    GRS_WT           with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.NN_WT'
	REPLACE    NN_WT            with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.WT_UNIT'
	REPLACE    WT_UNIT          with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.PACKING'
	REPLACE    PACKING          with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.CBM'
	REPLACE    CBM              with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.CUFT'
	REPLACE    CUFT             with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.INNER_MARK'
	REPLACE    INNER_MARK       with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.SIDE_MARK'
	REPLACE    SIDE_MARK        with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.ITEM_MARK'
	REPLACE    ITEM_MARK        with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.BAR_CODE'
	REPLACE    BAR_CODE         with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.BAR_TYPE'
	REPLACE    BAR_TYPE         with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.MATERIAL_NAME'
	REPLACE    MATERIAL_NAME    with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.MATERIAL_DESC'
	REPLACE    MATERIAL_DESC   with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.DESC2'
	REPLACE    DESC2   with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.PACKAGE'
	REPLACE    PACKAGE  with  &vplvariables.
	VPLVARIABLES = VPLFROMDBF + '.MARKS'
	REPLACE    MARKS  with  &vplvariables.
	RETURN
ENDPROC
*------
PROCEDURE paulDEL_REC
	LPARAMETER PAULWARN , PAULDEL , PAULDBF , PAULREP , PAULWITH , PAULREP1 , PAULWITH1 ,  ;
		PLNOSKIP
	LOCAL LNRECNO , LLRETVAL
	LLRETVAL = .T.
	IF  .NOT. EMPTY(PAULWARN)
		IF MESSAGEBOX(PAULWARN,292,PAULDEL) = 7
			RETURN .F.
		ENDIF
	ELSE
		IF MESSAGEBOX('Are you sure to delete this record?',292,'Delete Warning') = 7
			RETURN .F.
		ENDIF
	ENDIF
	IF '3' $ GETFLDSTATE(-1) .OR. '4' $ GETFLDSTATE(-1)
		_SCREEN.ACTIVEFORM.RESTORE()
		RETURN .T.
	ENDIF
	LNRECNO = RECNO()
	IF  .NOT. EMPTY(PAULREP)
		REPLACE &paulrep. with &paulwith.
		IF  .NOT. EMPTY(PAULREP1)
			REPLACE &paulrep1. with &paulwith1.
		ENDIF
	ENDIF
	IF VARTYPE(ADATETIME) = 'T'
		REPLACE ADATETIME WITH DATETIME()
	ENDIF
	IF VARTYPE(DDATE) = 'C'
		REPLACE DDATE WITH PAULUSER_CREATE()
	ENDIF
	DELETE
	IF  .NOT. EMPTY(PLNOSKIP) AND PLNOSKIP = 'Y'
		RETURN .T.
	ENDIF
	= TABLEUPDATE(.T.)
	SKIP
	IF EOF()
		SKIP -1
		IF  .NOT. BOF()
			_SCREEN.ACTIVEFORM.REFRESHFORM()
		ELSE
		ENDIF
	ELSE
		IF LNRECNO = RECNO()
			LLRETVAL = .F.
		ELSE
			_SCREEN.ACTIVEFORM.REFRESHFORM()
		ENDIF
	ENDIF
	RETURN LLRETVAL
ENDPROC
*------
PROCEDURE paulFILTER
	LPARAMETER PAULDBF , PAULCAPTION , PAULDBF_FILTER
	LOCAL APPFLT
	SELECT (PAULCAPTION)
	APPFLT = CREATEOBJECT('FLTFORM')
	APPFLT.CAPTION = SCREEN_FLT
	IF TYPE(FLT_FROM1) = 'D' .OR. TYPE(FLT_FROM1) = 'N'
		DVNAME_FM = FLT_FROM1
		DVNAME_TO = FLT_TO1
		APPFLT.KEY11.VALUE=&DVNAME_FM.
		APPFLT.KEY12.VALUE=&DVNAME_TO.
	ELSE
		DVNAME_FM = FLT_FROM1
		DVNAME_TO = FLT_TO1
		APPFLT.KEY11.VALUE = DVNAME_FM
		APPFLT.KEY12.VALUE = DVNAME_TO
	ENDIF
	IF TYPE(FLT_FROM2) = 'D' .OR. TYPE(FLT_FROM2) = 'N'
		DVNAME_FM = FLT_FROM2
		DVNAME_TO = FLT_TO2
		APPFLT.KEY21.VALUE=&DVNAME_FM.
		APPFLT.KEY22.VALUE=&DVNAME_TO.
	ELSE
		DVNAME_FM = FLT_FROM2
		DVNAME_TO = FLT_TO2
		APPFLT.KEY21.VALUE = DVNAME_FM
		APPFLT.KEY22.VALUE = DVNAME_TO
	ENDIF
	IF TYPE(FLT_FROM3) = 'D' .OR. TYPE(FLT_FROM3) = 'N'
		DVNAME_FM = FLT_FROM3
		DVNAME_TO = FLT_TO3
		APPFLT.KEY31.VALUE=&DVNAME_FM.
		APPFLT.KEY32.VALUE=&DVNAME_TO.
	ELSE
		DVNAME_FM = FLT_FROM3
		DVNAME_TO = FLT_TO3
		APPFLT.KEY31.VALUE = DVNAME_FM
		APPFLT.KEY32.VALUE = DVNAME_TO
	ENDIF
	APPFLT.KEYNAME1.CAPTION = KEYNAME1
	APPFLT.FLTFIELD = FLTFIELD1
	APPFLT.KEYNAME2.CAPTION = KEYNAME2
	APPFLT.FLTFIELD1 = FLTFIELD2
	APPFLT.KEYNAME3.CAPTION = KEYNAME3
	APPFLT.FLTFIELD2 = FLTFIELD3
	IF  .NOT. EMPTY(PAULDBF_FILTER)
		APPFLT.DBF_FILTER = PAULDBF_FILTER
	ENDIF
	SELECT (PAULDBF)
	APPFLT.SHOW()
	SELECT (PAULDBF)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulINQUIRY
	LPARAMETER PAULDBF , PAULSCREEN_NAME , PAULKEYNAME1 , PAULSEEKFIELD1 , PAULKEYNAME2 ,  ;
		PAULSEEKFIELD2 , PAULKEYNAME3 , PAULSEEKFIELD3 , PAULKEYNAME4 ,  ;
		PAULSEEKFIELD4 , PAULKEYNAME5 , PAULSEEKFIELD5
	LOCAL APPQRY , SELECT_WK1
	APPQRY = CREATEOBJECT('QRYFORM')
	APPQRY.CAPTION = PAULSCREEN_NAME
	APPQRY.KEYNAME1.CAPTION = PAULKEYNAME1
	APPQRY.SEEKFIELD = PAULSEEKFIELD1
	APPQRY.KEYNAME2.CAPTION = PAULKEYNAME2
	APPQRY.SEEKFIELD2 = PAULSEEKFIELD2
	IF  .NOT. EMPTY(PAULKEYNAME3)
		APPQRY.KEYNAME3.VISIBLE = .T.
		APPQRY.KEY3.VISIBLE = .T.
		APPQRY.KEYNAME3.CAPTION = PAULKEYNAME3
		APPQRY.SEEKFIELD3 = PAULSEEKFIELD3
	ENDIF
	IF  .NOT. EMPTY(PAULKEYNAME4)
		APPQRY.KEYNAME4.VISIBLE = .T.
		APPQRY.KEY4.VISIBLE = .T.
		APPQRY.KEYNAME4.CAPTION = PAULKEYNAME4
		APPQRY.SEEKFIELD4 = PAULSEEKFIELD4
	ENDIF
	IF  .NOT. EMPTY(PAULKEYNAME5)
		APPQRY.KEYNAME5.VISIBLE = .T.
		APPQRY.KEY5.VISIBLE = .T.
		APPQRY.KEYNAME5.CAPTION = PAULKEYNAME5
		APPQRY.SEEKFIELD5 = PAULSEEKFIELD5
	ENDIF
	SELECT_WK1 = SELECT()
	SELECT (PAULDBF)
	APPQRY.SHOW()
	SELECT (SELECT_WK1)
	RELEASE APPQRY
	RETURN .T.
ENDPROC
*------
PROCEDURE paulRECALL
	LPARAMETER PAULDBF , PAULSEEKFIELD , PAULKEY , PAULKEYNAME , PAULSCREEN_NAME ,  ;
		PAULFIELDNAME1 , PAULFIELD1 , PAULFIELDNAME2 , PAULFIELD2 , PAULDBF1 , PAULDBF2 ,  ;
		PAULDBF3 , PAULDBF4 , PAULDBF_FILTER
	LOCAL REC_NUM , SET_DEL1 , SET_EXACT1 , SET_NEAR1 , APPQRY2 , SEEK_VALUE , SEEK_TF ,  ;
		SELECT_WKD
	APPEND_YN = .F.
	SELECT_WKD = SELECT()
	SELECT (PAULDBF)
	REC_NUM = RECNO()
	SET_DEL1 = SET('DELETED')
	SET_EXACT1 = SET('EXACT')
	SET_NEAR1 = SET('NEAR')
	APPQRY2 = CREATEOBJECT('RECALL_REC')
	APPQRY2.CAPTION = PAULSCREEN_NAME
	APPQRY2.TXTBROWSER.RECORDSOURCE = PAULDBF
	APPQRY2.TXTBROWSER.ENABLED = .T.
	APPQRY2.TXTBROWSER.COLUMN1.CONTROLSOURCE = PAULFIELD1
	APPQRY2.TXTBROWSER.COLUMN2.CONTROLSOURCE = PAULFIELD2
	APPQRY2.TXTBROWSER.COLUMN1.HEADER1.CAPTION = PAULFIELDNAME1
	APPQRY2.TXTBROWSER.COLUMN2.HEADER1.CAPTION = PAULFIELDNAME2
	APPQRY2.DBF = PAULDBF
	APPQRY2.KEYFIELD = PAULKEY
	APPQRY2.KEYNAME1.CAPTION = PAULKEYNAME
	APPQRY2.SEEKFIELD = PAULSEEKFIELD
	IF  .NOT. EMPTY(PAULDBF_FILTER)
		APPQRY2.DBF_FILTER = PAULDBF_FILTER
	ENDIF
	APPQRY2.SHOW()
	seek_value=UPPER(&paulKEY.)
	IF APPEND_YN
		IF  .NOT. EMPTY(PAULDBF1)
			SELECT (PAULDBF1)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		IF  .NOT. EMPTY(PAULDBF2)
			SELECT (PAULDBF2)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		IF  .NOT. EMPTY(PAULDBF3)
			SELECT (PAULDBF3)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		IF  .NOT. EMPTY(PAULDBF4)
			SELECT (PAULDBF4)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		SEEK_TF = SEEK(SEEK_VALUE,PAULDBF,PAULSEEKFIELD)
		SELECT (PAULDBF)
		IF  .NOT. EMPTY(PAULDBF_FILTER)
			set filter to &pauldbf_filter.
		ENDIF
	ELSE
		SEEK_VALUE = ''
		IF REC_NUM <= RECCOUNT() AND RECCOUNT() <> 0
			GO REC_NUM
		ENDIF
	ENDIF
	SET DELETED &SET_DEL1.
	SET NEAR &SET_NEAR1.
	SET EXACT &SET_EXACT1.
	RELEASE APPQRY2
	RETURN SEEK_VALUE
ENDPROC
*------
PROCEDURE paulRETURN_VALUE
	LPARAMETER PAULRECALL , PAULDBF , PULSEEKEXP , PAULKEY , PAULKEYNAME , PAULFIELD1 ,  ;
		PAULFIELDNAME1 , PAULFIELD2 , PAULFIELDNAME2 , PAULREP1 , PAULWITH1 ,  ;
		PAULREP2 , PAULWITH2 , PAULREP3 , PAULWITH3
	LOCAL SELECT_WK , SET_EXACT , SET_NEAR
	IF EMPTY(PAULRECALL)
		RETURN .T.
	ENDIF
	SELECT_WK = SELECT()
	SET_EXACT = SET('EXACT')
	SET_NEAR = SET('NEAR')
	SELECT (PAULDBF)
	SET NEAR OFF
	SET EXACT ON
	DO OUTPUT_WIN
	ACTIVATE WINDOW OUTPUT_WIN
	GO TOP
	SCAN FOR paulRECALL=&paulKEY.
		IF  &paulKEY.=paulRECALL
			@ 2 , 4 SAY PAULKEYNAME
			@ 2,25 SAY &paulKEY.
			IF  .NOT. EMPTY(PAULFIELD1)
				@ 3 , 4 SAY PAULFIELDNAME1
				@ 3,25 SAY &paulFIELD1.
			ENDIF
			IF  .NOT. EMPTY(PAULFIELD2)
				@ 4 , 4 SAY PAULFIELDNAME2
				@ 4,25 SAY &paulFIELD2.
			ENDIF
			SEEK_YN=&paulSEEKEXP.
			IF SEEK_YN AND  .NOT. EMPTY(PAULREP1)
				REPLACE &paulREP1. WITH &paulWITH1.
			ENDIF
			IF SEEK_YN AND  .NOT. EMPTY(PAULREP2)
				REPLACE &paulREP2. WITH &paulWITH2.
			ENDIF
			IF SEEK_YN AND  .NOT. EMPTY(PAULREP3)
				REPLACE &paulREP3. WITH &paulWITH3.
			ENDIF
		ENDIF
	ENDSCAN
	DEACTIVATE WINDOW OUTPUT_WIN
	RELEASE WINDOW OUTPUT_WIN
	SELECT (SELECT_WK)
	SET EXACT &set_exact.
	SET NEAR  &set_near.
	RETURN .T.
ENDPROC
*------
PROCEDURE paulDUPL
	LPARAMETER PAULDBF , PAULSCREEN , PAULKEY , PAULKEYNAME , PAULKEYNAME1 , PAULSEEKFIELD ,  ;
		PAULKEY2 , PAULINPUTMASK
	LOCAL APPQRY6 , REC_CUST , SET_DEL , SET_EXACT , SET_NEAR , SELECT_WKD , PAULKEY2
	APPEND_YN = .F.
	SELECT_WKD = SELECT()
	SELECT (PAULDBF)
	IF EOF()
		SELECT (SELECT_WKD)
		RETURN
	ENDIF
	REC_CUST = RECNO()
	SET_DEL = SET('DELETED')
	SET_EXACT = SET('EXACT')
	SET_NEAR = SET('NEAR')
	APPQRY6 = CREATEOBJECT('DUPLIC_REC')
	APPQRY6.CAPTION = PAULSCREEN
	APPQRY6.DBF = PAULDBF
	APPQRY6.KEYFIELD = PAULKEY
	APPQRY6.KEY1.VALUE=&paulKEY.
	APPQRY6.KEYNAME1.CAPTION = ALLTRIM(PAULKEYNAME)
	APPQRY6.SEEKFIELD = PAULSEEKFIELD
	IF  .NOT. EMPTY(PAULKEY2)
		APPQRY6.KEY2.VALUE = PAULKEY2
	ELSE
		APPQRY6.KEY2.VALUE = SPACE(20)
	ENDIF
	IF  .NOT. EMPTY(PAULINPUTMASK)
		APPQRY6.KEY2.INPUTMASK = PAULINPUTMASK
	ENDIF
	APPQRY6.KEYNAME2.CAPTION = ALLTRIM(PAULKEYNAME1)
	APPQRY6.SHOW()
	SET DELETED &SET_DEL.
	SET EXACT &SET_EXACT.
	SET NEAR &SET_NEAR.
	RELEASE APPQRY6
	SELECT (SELECT_WKD)
	IF APPEND_YN
		RETURN .T.
	ELSE
		GO REC_CUST
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE paulDEF_MEMO
	LPARAMETER PAULSCREEN_ID , PAULMEMO , PAULYN1 , PAULSIDEMARK , PAULYN2 , PAULINNERMARK ,  ;
		PAULTRADE , PAULSHIP_TO , PAULSHIP_FROM , PAULORIGIN , PAULFOB_CIF ,  ;
		PAULSAMPLE , PAULSEASON
	IF  .NOT. USED('DEFMEMO')
		USE IN 0 DEFMEMO ORDER DEF_MEMO
	ENDIF
	SELECT DEFMEMO
	SEEK_YN = SEEK(ALLTRIM(PAULSCREEN_ID) + 'Y','DEFMEMO','DEF_MEMO')
	IF SEEK_YN
		REPLACE &paulMEMO. with DEFMEMO.REMARKS
		IF  .NOT. EMPTY(PAULYN1) AND PAULYN1 = 'Y'
			REPLACE &paulsidemark. with DEFMEMO.SIDEMARK
		ENDIF
		IF  .NOT. EMPTY(PAULYN2) AND PAULYN2 = 'Y'
			REPLACE &paulINNERmark. with DEFMEMO.INNERMARK
		ENDIF
		IF  .NOT. EMPTY(PAULTRADE)
			IF  .NOT. EMPTY(DEFMEMO.TRADE)
				replace &paulTRADE.  with ALLTRIM(DEFMEMO.TRADE)
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PAULSHIP_TO)
			IF  .NOT. EMPTY(DEFMEMO.SHIP_TO)
				replace &paulSHIP_TO.  with DEFMEMO.SHIP_TO
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PAULSHIP_FROM)
			IF  .NOT. EMPTY(DEFMEMO.SHIP_FROM)
				replace &paulSHIP_FROM.  with DEFMEMO.SHIP_FROM
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PAULORIGIN)
			IF  .NOT. EMPTY(DEFMEMO.ORIGIN)
				replace &paulORIGIN.  with DEFMEMO.ORIGIN
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PAULFOB_CIF)
			IF  .NOT. EMPTY(DEFMEMO.FOB_CIF)
				replace &paulFOB_CIF.  with ALLTRIM(DEFMEMO.FOB_CIF)
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PAULSAMPLE)
			IF  .NOT. EMPTY(DEFMEMO.SAMPLE)
				replace &paulSAMPLE.  with ALLTRIM(DEFMEMO.SAMPLE)
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PAULSEASON)
			IF  .NOT. EMPTY(DEFMEMO.SEASON)
				replace &paulSEASON.  with ALLTRIM(DEFMEMO.SEASON)
			ENDIF
		ENDIF
		RETURN .T.
	ELSE
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE paulSAVE
	LPARAMETER PAULDBF1 , PAULDBF2 , PAULDBF3 , PAULDBF4 , PAULDBF5 , PAULDBF6 , PAULDBF7 ,  ;
		PAULDBF8 , PAULDBF9 , PAULDBF10
	LOCAL TSUPDATE , SELECT_SAVE
	SELECT_SAVE = SELECT()
	TSUPDATE = PAULTABLEUPDATE(PAULDBF1)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF2)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF3)
	IF EMPTY(PAULDBF4)
		SELECT (SELECT_SAVE)
		RETURN .T.
	ENDIF
	TSUPDATE = PAULTABLEUPDATE(PAULDBF4)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF5)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF6)
	IF EMPTY(PAULDBF7)
		SELECT (SELECT_SAVE)
		RETURN .T.
	ENDIF
	TSUPDATE = PAULTABLEUPDATE(PAULDBF7)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF8)
	IF EMPTY(PAULDBF9)
		SELECT (SELECT_SAVE)
		RETURN .T.
	ENDIF
	TSUPDATE = PAULTABLEUPDATE(PAULDBF9)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF10)
	SELECT (SELECT_SAVE)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulDESTROY
	LPARAMETER PAULRELEASETYPE , PAULDBF1 , PAULDBF2 , PAULDBF3 , PAULDBF4 , PAULDBF5 ,  ;
		PAULDBF6 , PAULDBF7 , PAULDBF8 , PAULDBF9 , PAULDBF10
	LOCAL TSUPDATE
	TSUPDATE = PAULTABLEUPDATE(PAULDBF1)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF2)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF3)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF4)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF5)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF6)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF7)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF8)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF9)
	TSUPDATE = PAULTABLEUPDATE(PAULDBF10)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulTABLEUPDATE
	LPARAMETER PAULDBF
	IF EMPTY(PAULDBF)
		RETURN .F.
	ENDIF
	IF USED(PAULDBF)
		SELECT (PAULDBF)
		= TABLEUPDATE(.T.)
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE paulTABLEREVERT
	LPARAMETER PAULDBF
	IF EMPTY(PAULDBF)
		RETURN .F.
	ENDIF
	IF USED(PAULDBF)
		SELECT (PAULDBF)
		= TABLEREVERT(.T.)
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE paulADD_ITEM
	LPARAMETER PLTODBF , PLFROMDBF , PLSCREEN , PLFILTER , PLSF1 , PLSF2 , PLSF3 , PLSFN1 ,  ;
		PLSFN2 , PLSFN3 , PLKEY1 , PLKEY2 , PLKEYNAME1 , PLKEYNAME2 , PLSEEK1 ,  ;
		PLSEEK2 , PLREP1 , PLWITH1 , PLREP2 , PLWITH2 , PLREP3 , PLWITH3 ,  ;
		PLREP4 , PLWITH4 , PLREP5 , PLWITH5 , PLREP6 , PLWITH6 , PLREP7 , PLWITH7 ,  ;
		PLREP8 , PLWITH8 , PLREP9 , PLWITH9 , PLREP10 , PLWITH10
	LOCAL APPQRY2 , SELECT_WK , REC_CUST , SET_DEL , SET_EXACT , SET_NEAR , REC_NUM2
	SELECT_WK = SELECT()
	SELECT (PLTODBF)
	REC_CUST = RECNO()
	SET_DEL = SET('DELETED')
	SET_EXACT = SET('EXACT')
	SET_NEAR = SET('NEAR')
	APPEND_YN = .F.
	REC_NUM2 = RECNO()
	APPQRY2 = CREATEOBJECT('SEL_ITEM')
	APPQRY2.CAPTION = PLSCREEN
	SELECT (PLFROMDBF)
	IF  .NOT. EMPTY(PLFILTER)
		SET FILTER TO  &plFILTER.
	ENDIF
	APPQRY2.TXTBROWSER.RECORDSOURCE = PLFROMDBF
	APPQRY2.TXTBROWSER.ENABLED = .T.
	APPQRY2.TXTBROWSER.COLUMN1.CONTROLSOURCE = PLSF1
	APPQRY2.TXTBROWSER.COLUMN2.CONTROLSOURCE = PLSF2
	APPQRY2.TXTBROWSER.COLUMN3.CONTROLSOURCE = PLSF3
	APPQRY2.TXTBROWSER.COLUMN1.HEADER1.CAPTION = PLSFN1
	APPQRY2.TXTBROWSER.COLUMN2.HEADER1.CAPTION = PLSFN2
	APPQRY2.TXTBROWSER.COLUMN3.HEADER1.CAPTION = PLSFN3
	APPQRY2.DBF = PLFROMDBF
	APPQRY2.KEY1.VALUE = SPACE(20)
	APPQRY2.KEYNAME1.CAPTION = PLKEYNAME1
	APPQRY2.SEEKFIELD = PLSEEK1
	APPQRY2.KEYFIELD = PLKEY1
	APPQRY2.KEY2.VALUE = SPACE(27)
	APPQRY2.KEYNAME2.CAPTION = PLKEYNAME2
	APPQRY2.SEEKFIELD2 = PLSEEK2
	APPQRY2.KEYFIELD2 = PLKEY2
	OAPP.OTOOLBAR.ENABLED = .F.
	APPQRY2.SHOW()
	OAPP.OTOOLBAR.ENABLED = .T.
	RELEASE APPQRY2
	IF APPEND_YN
		SELECT (PLFROMDBF)
		DO OUTPUT_WIN
		ACTIVATE WINDOW OUTPUT_WIN
		SET_EXACT = SET('EXACT')
		GO TOP
		SEEK_YN = SEEK(.F.,PLFROMDBF,'CLICK')
		DO WHILE SEEK_YN
			IF SEEK_YN
				REPLACE CLICK WITH .T.
				@ 2 , 4 SAY PLSF1
				@ 2 , 24 SAY PLSFN1
				@ 3 , 4 SAY PLSF2
				@ 3 , 24 SAY PLSFN2
				@ 4 , 4 SAY PLSF3
				@ 4 , 24 SAY PLSFN3
				SELECT (PLTODBF)
				APPEND BLANK
				REPLACE_YN = PAULREPLACE(PLREP1,PLWITH1)
				REPLACE_YN = PAULREPLACE(PLREP2,PLWITH2)
				REPLACE_YN = PAULREPLACE(PLREP3,PLWITH3)
				REPLACE_YN = PAULREPLACE(PLREP4,PLWITH4)
				REPLACE_YN = PAULREPLACE(PLREP5,PLWITH5)
				REPLACE_YN = PAULREPLACE(PLREP6,PLWITH6)
				REPLACE_YN = PAULREPLACE(PLREP7,PLWITH7)
				REPLACE_YN = PAULREPLACE(PLREP8,PLWITH8)
				REPLACE_YN = PAULREPLACE(PLREP9,PLWITH9)
				REPLACE_YN = PAULREPLACE(PLREP10,PLWITH10)
				SELECT (PLFROMDBF)
			ENDIF
			SEEK_YN = SEEK(.F.,PLFROMDBF,'CLICK')
		ENDDO
		DEACTIVATE WINDOW OUTPUT_WIN
		RELEASE WINDOW OUTPUT_WIN
		SELECT (PLFROMDBF)
		SET FILTER TO
		SELECT (PLTODBF)
		IF  .NOT. EOF()
			GO RECNO() IN (PLTODBF)
		ENDIF
	ENDIF
	SELECT (SELECT_WK)
	SET DELETED &SET_DEL.
	SET EXACT &SET_EXACT.
	SET NEAR &SET_NEAR.
	RETURN APPEND_YN
ENDPROC
*------
PROCEDURE paulREPLACE
	LPARAMETER PAULREPLACE , PAULWITH , PAULDBF , PLIF , PLREP1 , PLW1 , PLREP2 , PLW2 , PLREP3 ,  ;
		PLW3 , PLREP4 , PLW4
	IF EMPTY(PAULREPLACE)
		RETURN .T.
	ENDIF
	IF  .NOT. EMPTY(PAULDBF)
		LOCAL PAULTOTAL
		SELECT (PAULDBF)
		GO TOP
		IF EOF()
			WAIT WINDOW NOWAIT 'Nothing to replace ...'
			RETURN
		ENDIF
		PAULTOTAL = RECCOUNT()
		PAULNOOFREC = 1
		DO WHILE  .NOT. EOF()
			IF &plIF.
				IF  .NOT. EMPTY(PAULREPLACE)
					REPLACE &paulREPLACE. WITH &paulWITH.
				ENDIF
				IF  .NOT. EMPTY(PLREP1)
					REPLACE &plREP1. WITH &plW1.
				ENDIF
				IF  .NOT. EMPTY(PLREP2)
					REPLACE &plREP2. WITH &plW2.
				ENDIF
				IF  .NOT. EMPTY(PLREP3)
					REPLACE &plREP3. WITH &plW3.
				ENDIF
				IF  .NOT. EMPTY(PLREP4)
					REPLACE &plREP4. WITH &plW4.
				ENDIF
			ENDIF
			WAIT WINDOW NOWAIT  ;
				'Record # : ' + STR(RECNO(),8) + '  No. of Record Updated :' + STR(PAULNOOFREC,8) +  ;
				' of ' + STR(PAULTOTAL,8)
			SELECT (PAULDBF)
			SKIP
			PAULNOOFREC = PAULNOOFREC + 1
		ENDDO
		RETURN
	ENDIF
	REPLACE &paulREPLACE. WITH &paulWITH.
	RETURN .T.
ENDPROC
*------
PROCEDURE tsIS_GENNO
	LPARAMETER PAULDBF , PAULKEY , PAULSEEK , PAULGENNO
	SELECT_WK = SELECT()
	IF  .NOT. USED(PAULDBF)
		USE IN 0 paulDBF
	ENDIF
	SELECT (PAULDBF)
	IF SEEK(PAULKEY,PAULDBF,PAULSEEK)
		tsISGENO=&paulGENNO.
	ELSE
		TSISGENO = .F.
	ENDIF
	SELECT (SELECT_WK)
	RETURN TSISGENO
ENDPROC
*------
PROCEDURE paulCHANGEMEMO
	LPARAMETER PAULDBF , PAULMEMO , PAULSCREEN_KEY
	LOCAL SELECT_WK6 , REC_NUM2 , APPQRY3
	SELECT_WK6 = SELECT()
	REC_NUM2 = RECNO()
	IF  .NOT. EMPTY(PAULDBF)
		SELECT (PAULDBF)
		IF EOF()
			SELECT (SELECT_WK6)
			RETURN
		ENDIF
	ENDIF
	SCREEN_KEY = PAULSCREEN_KEY
	APPQRY3 = CREATEOBJECT('CHGMEMO')
	APPQRY3.TXTDEFMEMO.MEMO_ID.CONTROLSOURCE = 'DEFMEMO.CODE'
	APPQRY3.TXTDEFMEMO.MEMO_NAME.CONTROLSOURCE = 'DEFMEMO.NAME'
	APPQRY3.TXTDEFMEMO.MEMO_DEF.CONTROLSOURCE = 'DEFMEMO.DEF_VALUE'
	APPQRY3.REMARKS.CONTROLSOURCE = 'DEFMEMO.REMARKS'
	APPQRY3.KEYFIELD = PAULMEMO
	APPQRY3.SHOW()
	SELECT (SELECT_WK6)
	IF  .NOT. EOF()
		GO REC_NUM2
	ENDIF
	RELEASE SELECT_WK6
	RELEASE APPQRY3
	RELEASE REC_NUM2
ENDPROC
*------
PROCEDURE paulCHECK_NO
	LPARAMETER PAULDBF , PAULID , PAULSEEK , PAULWARN , PAULWARN1 , PAULCURRNO
	LOCAL SEEK_YN , SET_DELETED , SELECT_WK , SET_EXACT
	SELECT_WK = SELECT()
	SET_DELETED = SET('DELETED')
	SET_EXACT = SET('EXACT')
	IF  .NOT. USED(PAULDBF)
		use (pauldbf) order &paulseek. in 0 AGAIN
	ENDIF
	SET DELETED OFF
	SET EXACT ON
	SEEK_YN = SEEK(PAULID,PAULDBF,PAULSEEK)
	IF  .NOT. EMPTY(PAULCURRNO)
		IF SEEK_YN AND PAULCURRNO = RECNO(PAULDBF)
			SEEK_YN = .F.
		ENDIF
	ENDIF
	SET EXACT &SET_EXACT.
	IF  .NOT. EMPTY(PAULWARN)
		IF SEEK_YN
			IF DELETED(PAULDBF)
				= PAULMESSAGE('This Document ID/Code already exists in Rubbish Bin !')
			ELSE
				= PAULMESSAGE(PAULWARN)
			ENDIF
		ENDIF
	ELSE
		IF SEEK_YN
			IF DELETED(PAULDBF)
				SEEK_YN = .F.
				= PAULMESSAGE(PAULWARN1)
			ENDIF
		ELSE
			IF  .NOT. EMPTY(PAULWARN1)
				= PAULMESSAGE(PAULWARN1)
			ENDIF
		ENDIF
	ENDIF
	SET DELETED &SET_DELETED.
	SELECT (SELECT_WK)
	RETURN SEEK_YN
ENDPROC
*------
PROCEDURE paulMESSAGE
	LPARAMETER PLMAG1 , PLWAR1
	IF EMPTY(PLWAR1)
		PLWAR1 = ITMSG('00080')
	ENDIF
	= MESSAGEBOX(PLMAG1,304,PLWAR1)
ENDPROC
*------
PROCEDURE paulASK_YN
	LPARAMETER PLMESSAGE , PLWARNING , PLDEFAULT , PLBUTTONS , PLICON
	LOCAL PLBUTTON2
	IF  .NOT. EMPTY(PLDEFAULT)
	ELSE
		PLDEFAULT = '256'
	ENDIF
	IF  .NOT. EMPTY(PLBUTTONS)
	ELSE
		PLBUTTONS = '4'
	ENDIF
	IF  .NOT. EMPTY(PLICON)
	ELSE
		PLICON = '32'
	ENDIF
	IF EMPTY(PLWARNING)
		PLWARNING = ITMSG('00080')
	ENDIF
	IF  .NOT. EMPTY(PLDEFAULT) AND PLDEFAULT = '1'
		PLDEFAULT = '0'
	ENDIF
	IF  .NOT. EMPTY(PLDEFAULT) AND PLDEFAULT = '3'
		PLDEFAULT = '512'
	ENDIF
	PLBUTTON2 = PLBUTTONS + '+' + PLICON + '+' + PLDEFAULT
	IF MessageBox(alltrim(plMESSAGE),  &plbutton2. ,  alltrim(plWARNING)) = 7
		RETURN .F.
	ELSE
		RETURN .T.
	ENDIF
ENDPROC
*------
PROCEDURE output_WIN
	DEFINE WINDOW OUTPUT_WIN FROM 1 , 1 TO 13 , 79 FONT 'ARIAL' , 10 STYLE 'B' GROW FLOAT  ;
		CLOSE ZOOM SHADOW TITLE 'Add Item' DOUBLE
	RETURN
ENDPROC
*------
PROCEDURE paulItemOrdering
	LPARAMETER PAULDBF , PAULMASTER , PAULSCREEN_NAME , PLSOURCE1 , PLSOURCE2 , PLSOURCE3 ,  ;
		PLHEAD1 , PLHEAD2 , PLHEAD3
	LOCAL SELECT_WK6 , REC_NUM2 , APPQRY3 , CURSOR_GET
	SELECT_WK6 = SELECT()
	SELECT (PAULDBF)
	REC_NUM2 = RECNO()
	IF EOF()
		SELECT (SELECT_WK6)
		RETURN .F.
	ENDIF
	CURSOR_GET = CURSORGETPROP('BUFFERING',PAULDBF)
	APPQRY3 = CREATEOBJECT('Item_reorder')
	APPQRY3.TXTBROWSER.RECORDSOURCE = PAULDBF
	APPQRY3.TXTBROWSER.LINKMASTER = PAULMASTER
	APPQRY3.TXTBROWSER.RELATIONALEXPR = 'somast.so_id'
	APPQRY3.TXTBROWSER.COLUMN1.CONTROLSOURCE = PLSOURCE1
	APPQRY3.TXTBROWSER.COLUMN1.READONLY = .F.
	APPQRY3.TXTBROWSER.COLUMN2.CONTROLSOURCE = PLSOURCE2
	APPQRY3.TXTBROWSER.COLUMN3.CONTROLSOURCE = PLSOURCE3
	APPQRY3.TXTBROWSER.COLUMN1.HEADER1.CAPTION = PLHEAD1
	APPQRY3.TXTBROWSER.COLUMN2.HEADER1.CAPTION = PLHEAD2
	APPQRY3.TXTBROWSER.COLUMN3.HEADER1.CAPTION = PLHEAD3
	APPQRY3.SHOW()
	IF  .NOT. EOF()
		GO REC_NUM2
	ENDIF
	SELECT (SELECT_WK6)
	RELEASE SELECT_WK6
	RELEASE APPQRY3
	RELEASE REC_NUM2
	RETURN .T.
ENDPROC
*------
PROCEDURE paulNavigator
	LPARAMETER PAULDBF , PAULID , PAULSEEK , PAULSEEK2 , PAULVALUE , PAULKEYNAME , PAULWARN1 ,  ;
		PAULWARN2
	LOCAL SEEK_YN , SET_DELETED , SELECT_WK
	IF UPPER(ALLTRIM(PAULDBF)) <> UPPER(ALLTRIM(ALIAS()))
		RETURN .F.
	ENDIF
	IF UPPER(ALLTRIM(ORDER())) = UPPER(ALLTRIM(PAULSEEK2))
		PAULSEEK = PAULSEEK2
	ENDIF
	IF PAULID = 'LAST'
		SEEK  paulVALUE ORDER &paulSEEK. DESCENDING
		SET ORDER TO &paulSEEK. ASCENDING
		RETURN .T.
	ENDIF
	IF PAULID = 'FIRST'
		SET ORDER TO &paulSEEK. ASCENDING
		SEEK PAULVALUE
		RETURN .T.
	ENDIF
	IF PAULID = 'NEXT'
		IF EOF() .OR. BOF()
			RETURN .T.
		ENDIF
		IF  .NOT. EOF()
			RECORD_NUM = RECNO()
		ELSE
			RECORD_NUM = 0
		ENDIF
		set order to &paulSEEK.
		IF  .NOT. EOF()
			SKIP 1
		ENDIF
		IF EOF() .OR. upper(&paulKEYNAME.)<>UPPER(paulVALUE)
			IF RECORD_NUM <> 0
				GO RECORD_NUM
				= PAULMESSAGE(PAULWARN1)
			ENDIF
		ENDIF
		RETURN .T.
	ENDIF
	IF PAULID = 'PRIOR'
		IF BOF() .OR. EOF()
			RETURN .T.
		ENDIF
		IF  .NOT. EOF()
			RECORD_NUM = RECNO()
		ELSE
			RECORD_NUM = 0
		ENDIF
		set order to &paulSEEK.
		IF  .NOT. BOF()
			SKIP -1
		ENDIF
		IF BOF() .OR. upper(&paulKEYNAME.)<>UPPER(paulVALUE)
			IF RECORD_NUM <> 0
				GO RECORD_NUM
				= PAULMESSAGE(PAULWARN1)
			ENDIF
		ENDIF
		RETURN .T.
	ENDIF
ENDPROC
*------
PROCEDURE paulTOOLBAR
	LPARAMETER TOOLBARID
	LOCAL TOOLCMD , TOOLBARID , SELECT_WKAREA , TOOLTIP
	SELECT_WKAREA = SELECT()
	IF  .NOT. USED('toolbar')
		USE IN 0 toolbar
	ENDIF
	SEEK_YN = SEEK(DEF_LANG,'toolbar','def_lang')
	IF EMPTY(&toolbarid.)
		TOOLCMD = 'TOOLBAR.' + ALLTRIM(TOOLBARID)
		&toolbarid.=&toolcmd.
	ELSE
		store '' to &TOOLBARID.
	ENDIF
	TOOLCMD = 'oAPP.OTOOLBAR.CMD' + SUBSTR(ALLTRIM(TOOLBARID),4) + '.VISIBLE'
	TOOLTIP = 'oAPP.OTOOLBAR.CMD' + SUBSTR(ALLTRIM(TOOLBARID),4) + '.toolTiptext'
	&toolCMD.=.NOT. EMPTY(&toolbarid.)
	&toolTip.=alltrim(&toolbarid.)
	DO (TB_MENU)
	SELECT (SELECT_WKAREA)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulSaveToolbar
	LOCAL SELECT_WK
	ON ERROR RETURN
	SELECT_WK = SELECT()
	IF  .NOT. FILE('ITOOLBAR.DBF')
		RETURN .F.
	ENDIF
	IF  .NOT. USED('itoolbar')
		USE IN 0 itoolbar
	ENDIF
	SELECT ITOOLBAR
	LOCATE FOR DEF_LANG = 'ENG'
	USE IN 0 PARAMETE
	SELECT PARAMETE
	IF EMPTY(TB_FIRST)
		REPLACE ITOOLBAR.TB_FIRST WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_FIRST WITH .T.
	ENDIF
	IF EMPTY(TB_LAST)
		REPLACE ITOOLBAR.TB_LAST WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_LAST WITH .T.
	ENDIF
	IF EMPTY(TB_NEW)
		REPLACE ITOOLBAR.TB_NEW WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_NEW WITH .T.
	ENDIF
	IF EMPTY(TB_SAVE)
		REPLACE ITOOLBAR.TB_SAVE WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_SAVE WITH .T.
	ENDIF
	IF EMPTY(TB_DEL)
		REPLACE ITOOLBAR.TB_DEL WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_DEL WITH .T.
	ENDIF
	IF EMPTY(TB_DUP)
		REPLACE ITOOLBAR.TB_DUP WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_DUP WITH .T.
	ENDIF
	IF EMPTY(TB_QRY)
		REPLACE ITOOLBAR.TB_QRY WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_QRY WITH .T.
	ENDIF
	IF EMPTY(TB_FLT)
		REPLACE ITOOLBAR.TB_FLT WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_FLT WITH .T.
	ENDIF
	IF EMPTY(TB_RECALL)
		REPLACE ITOOLBAR.TB_RECALL WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_RECALL WITH .T.
	ENDIF
	IF EMPTY(TB_PRN)
		REPLACE ITOOLBAR.TB_PRN WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_PRN WITH .T.
	ENDIF
	IF EMPTY(TB_COPY)
		REPLACE ITOOLBAR.TB_COPY WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_COPY WITH .T.
	ENDIF
	IF EMPTY(TB_PAST)
		REPLACE ITOOLBAR.TB_PAST WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_PAST WITH .T.
	ENDIF
	IF EMPTY(TB_CUT)
		REPLACE ITOOLBAR.TB_CUT WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_CUT WITH .T.
	ENDIF
	IF EMPTY(TB_RESTORE)
		REPLACE ITOOLBAR.TB_RESTORE WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_RESTORE WITH .T.
	ENDIF
	IF EMPTY(TB_CAL)
		REPLACE ITOOLBAR.TB_CAL WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_CAL WITH .T.
	ENDIF
	IF EMPTY(TB_DIRARY)
		REPLACE ITOOLBAR.TB_DIRARY WITH .F.
	ELSE
		REPLACE ITOOLBAR.TB_DIRARY WITH .T.
	ENDIF
	USE IN ITOOLBAR
	USE IN PARAMETE
	SELECT (SELECT_WK)
	RETURN .T.
ENDPROC
*------
PROCEDURE pauluser_create
	PLCREATOR =  ;
		SUBSTR(DTOS(DATE()),1,4) + '/' + SUBSTR(DTOS(DATE()),5,2) + '/' +  ;
		SUBSTR(DTOS(DATE()),7,2) + ' ' + LEFT(TIME(),5) + ' ' + USERID
	RETURN PLCREATOR
ENDPROC
*------
PROCEDURE pauluser_depart
	RETURN USERDEPART
ENDPROC
*------
PROCEDURE pauluserid
	RETURN USERID
ENDPROC
*------
PROCEDURE paulDEL_SUBTABLE
	LPARAMETER PAULDBF , PAULSEEKEXP , PAULSEEKDBF , PAULSEEKID , PAULFIELDNAME1 ,  ;
		PAULFIELDNAME2 , PAULFIELDNAME3 , PAULREP1 , PAULWITH1 , PAULREP2 , PAULWITH2 ,  ;
		PAULREP3 , PAULWITH3
	LOCAL SELECT_WK , SET_EXACT , SET_NEAR , SEEK_RECORD
	SELECT_WK = SELECT()
	SELECT (PAULDBF)
	SET NEAR OFF
	SET EXACT ON
	SET DELETED ON
	SEEK_RECORD = SEEK(PAULSEEKEXP,PAULSEEKDBF,PAULSEEKID)
	DO WHILE SEEK_RECORD AND  .NOT. EOF()
		IF FOUND(PAULDBF)
			IF  .NOT. EMPTY(PAULREP1)
				REPLACE &paulREP1. WITH &paulWITH1.
				WAIT WINDOW &paulFIELDNAME1. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP2)
				REPLACE &paulREP2. WITH &paulWITH2.
				WAIT WINDOW &paulFIELDNAME2. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP3)
				REPLACE &paulREP3. WITH &paulWITH3.
				WAIT WINDOW &paulFIELDNAME3. NOWAIT
			ENDIF
			DELETE IN (PAULDBF)
		ENDIF
		SEEK_RECORD = SEEK(PAULSEEKEXP,PAULSEEKDBF,PAULSEEKID)
	ENDDO
	SELECT (SELECT_WK)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulREMOVE_SUBTABLE
	LPARAMETER PAULDBF , PAULSEEKEXP , PAULSEEKDBF , PAULSEEKID , PAULYES , PAULFIELDNAME1 ,  ;
		PAULFIELDNAME2 , PAULFIELDNAME3 , PAULREP1 , PAULWITH1 , PAULREP2 ,  ;
		PAULWITH2 , PAULREP3 , PAULWITH3
	LOCAL SELECT_WK , SET_EXACT , SET_NEAR , SEEK_RECORD
	SELECT_WK = SELECT()
	SELECT (PAULDBF)
	SET NEAR OFF
	SET EXACT ON
	SET DELETED ON
	SEEK_RECORD = SEEK(PAULSEEKEXP,PAULSEEKDBF,PAULSEEKID)
	DO WHILE MACROS  ???FUN[CA] ('paulSEEKEXP=&paulYES. .AND. .NOT. EOF()')
		IF  paulSEEKEXP=&paulYES.
			IF  .NOT. EMPTY(PAULREP1)
				REPLACE &paulREP1. WITH &paulWITH1.
				WAIT WINDOW &paulFIELDNAME1. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP2)
				REPLACE &paulREP2. WITH &paulWITH2.
				WAIT WINDOW &paulFIELDNAME2. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP3)
				REPLACE &paulREP3. WITH &paulWITH3.
				WAIT WINDOW &paulFIELDNAME3. NOWAIT
			ENDIF
		ENDIF
		SKIP
	ENDDO
	SELECT (SELECT_WK)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulLOGIN_OUT
	LPARAMETER PAULUSER_NAME , PAULLOGIN_OUT
	LOCAL SELECT_LOGIN , PAULSEEK_YN
	SELECT_LOGIN = SELECT()
	IF  .NOT. USED('USERLIST')
		USE IN 0 USERLIST
	ENDIF
	SELECT USERLIST
	IF PAULLOGIN_OUT = 'LOGIN'
		APPEND BLANK
		REPLACE USER_NAME WITH PAULUSER_NAME
	ELSE
		SET ORDER TO USER_NAME
		SEEK ALLTRIM(UPPER(PAULUSER_NAME))
		IF FOUND()
			REPLACE LOGOUT_TIME WITH DATETIME()
			DELETE WHILE USER_NAME = PAULUSER_NAME
		ENDIF
	ENDIF
	USE IN USERLIST
	IF PAULLOGIN_OUT = 'LOGOUT'
		= ITSYSTEMLOG('','LOGOUT','','','','','LOGOUT')
	ENDIF
	SELECT (SELECT_LOGIN)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulUSERLIST
	LPARAMETER PAULSCREEN_NAME , PAULUSER_NAME , PAUL_LOGIN
	ON ERROR RETURN .T.
	OAPP.DOFORM('USERLIST')
	RETURN
	LOCAL APPQRY2
	IF EMPTY(PAULSCREEN_NAME)
		PAULSCREEN_NAME = 'USER LIST'
		PAULUSER_NAME = 'User Name'
		PAUL_LOGIN = 'Login Time'
	ENDIF
	SELECT_WK = SELECT()
	IF  .NOT. USED('USERLIST')
		USE IN 0 USERLIST
	ENDIF
	SELECT USERLIST
	GO TOP
	APPQRY2 = CREATEOBJECT('REC_SELECT')
	APPQRY2.CAPTION = PAULSCREEN_NAME
	APPQRY2.TXTBROWSER.RECORDSOURCE = 'USERLIST'
	APPQRY2.TXTBROWSER.COLUMN1.CONTROLSOURCE = 'USERLIST.USER_NAME'
	APPQRY2.TXTBROWSER.COLUMN2.CONTROLSOURCE = 'USERLIST.LOGIN_TIME'
	APPQRY2.TXTBROWSER.COLUMN1.HEADER1.CAPTION = PAULUSER_NAME
	APPQRY2.TXTBROWSER.COLUMN2.HEADER1.CAPTION = PAUL_LOGIN
	APPQRY2.TABLE_NAME = 'USERLIST'
	APPQRY2.KEY1.VISIBLE = .F.
	APPQRY2.KEYNAME1.VISIBLE = .F.
	APPQRY2.KEY2.VISIBLE = .F.
	APPQRY2.CANCEL.CAPTION = '\<OK'
	APPQRY2.KEYNAME1.VISIBLE = .F.
	APPQRY2.KEYNAME2.VISIBLE = .F.
	APPQRY2.SHAPE4.VISIBLE = .F.
	APPQRY2.TSGROUPOPTION.VISIBLE = .F.
	APPQRY2.TSLABEL.VISIBLE = .F.
	APPQRY2.CFIND.VISIBLE = .F.
	APPQRY2.CSELECT.VISIBLE = .F.
	APPQRY2.TXTBROWSER.HEIGHT = 263
	APPQRY2.CONTROLBOX = .T.
	APPQRY2.SHOW()
	IF USED('USERLIST')
		USE IN USERLIST
	ENDIF
	SELECT (SELECT_WK)
	RELEASE APPQRY2
	RETURN .T.
ENDPROC
*------
PROCEDURE paulZEROCHECK
	LPARAMETER PAULVALUE , PLMESSAGE , PLDEFAULT , PLMESSAGE2
	LOCAL TXTMESSAGE , TXTMESSAGE2 , PAULVALUE , PLMESSAGE , PLDEFAULT , PLMESSAGE2
	IF  .NOT. EMPTY(PLMESSAGE)
		TXTMESSAGE = PLMESSAGE
	ELSE
		TXTMESSAGE = 'Exchange Rate cannot be zero !'
	ENDIF
	IF  .NOT. EMPTY(PLMESSAGE2)
		TXTMESSAGE2 = PLMESSAGE2
	ELSE
		TXTMESSAGE2 = 'Exchange Rate is different from default value!'
	ENDIF
	IF PAULVALUE = 0
		= MESSAGEBOX(TXTMESSAGE,304,'WARNING') = 7
		RETURN .F.
	ELSE
		IF  .NOT. EMPTY(PLDEFAULT)
			if &pldefault. <> paulVALUE
				=paulmessage(txtmessage2+transform(&pldefault.,'999.999999'))
			ENDIF
		ENDIF
		RETURN .T.
	ENDIF
ENDPROC
*------
PROCEDURE paulCHKDATE
	LPARAMETER PAULDBF , PAULPERIOD , PAULDATE , PAULMESSAGE1 , PAULMESSAGE2
	LOCAL PAULSELECT , PAULFROM , PAULTO
	IF PAULPERIOD > 24 .OR. PAULPERIOD <= 0
		WAIT WINDOW NOWAIT 'Out of period !!!   24<= Period Number >=1 '
		RETURN .T.
	ENDIF
	PAULSELECT = SELECT()
	PAULFROM = 'FROM' + ALLTRIM(STR(PAULPERIOD,2,0))
	PAULTO = 'TO' + ALLTRIM(STR(PAULPERIOD,2,0))
	SELECT (PAULDBF)
	IF PAULDATE < OPENDATEFR .OR. PAULDATE > OPENDATETO AND  .NOT. EMPTY(PAULMESSAGE1)
		= PAULMESSAGE(PAULMESSAGE1)
		SELECT (PAULSELECT)
		RETURN .F.
	ELSE
		IF paulDATE < &paulFROM. OR paulDATE >&paulTO. .and. !empty(paulMESSAGE2)
			= PAULMESSAGE(PAULMESSAGE2)
			SELECT (PAULSELECT)
			RETURN .F.
		ENDIF
	ENDIF
	SELECT (PAULSELECT)
	RETURN .T.
ENDPROC
*------
PROCEDURE itVOUCH_DATE
	LPARAMETER PAULDBF , PAULPERIOD , PAULDATE , PAULTYPE
	LOCAL PAULSELECT , PAULFROM , PAULTO , PAULVALUE
	IF PAULPERIOD > 24 .OR. PAULPERIOD <= 0
		WAIT WINDOW NOWAIT 'Out of period !!!   24<= Period Number >=1 '
		RETURN DATE()
	ENDIF
	PAULSELECT = SELECT()
	PAULFROM = 'FROM' + ALLTRIM(STR(PAULPERIOD,2,0))
	PAULTO = 'TO' + ALLTRIM(STR(PAULPERIOD,2,0))
	SELECT (PAULDBF)
	IF paulDATE >= &paulFROM. .AND. paulDATE <=&paulTO.
		PAULVALUE = DATE()
	ELSE
		IF  .NOT. EMPTY(ITPC(11))
			PAULTYPE = ITPC(11)
		ENDIF
		IF VAL(PAULTYPE) = 0
			paulvalue=&paulTO.
		ENDIF
		IF VAL(PAULTYPE) = 1
			paulvalue=&paulFROM.
		ENDIF
		IF VAL(PAULTYPE) = 2
			PAULVALUE = DATE()
		ENDIF
	ENDIF
	SELECT (PAULSELECT)
	RETURN PAULVALUE
ENDPROC
*------
PROCEDURE paulchangetable
	LPARAMETER PAULDBF
	LOCAL PLSELECTWK , PLCHANGE
	IF EMPTY(PAULDBF)
		RETURN .T.
	ENDIF
	PLCHANGE = .F.
	PLSELECTWK = SELECT()
	IF  .NOT. USED(PAULDBF)
		RETURN .F.
	ENDIF
	SELECT (PAULDBF)
	IF ('2' $ GETFLDSTATE(-1) .OR. '3' $ GETFLDSTATE(-1) .OR. '4' $ GETFLDSTATE(-1))
		PLCHANGE = .T.
	ELSE
		PLCHANGE = .F.
	ENDIF
	SELECT (PLSELECTWK)
	RETURN PLCHANGE
ENDPROC
*------
PROCEDURE paulDEBIT
	LPARAMETER PAULTYPE , PAULORG_TYPE , PAULORG_ID , PAULDEBIT_VALUE , PAULMESS
	LOCAL PAULSELECT , PAULDBF , PAULSEEK , PAULSEEK_YN
	PAULSELECT = SELECT()
	PAULDBF = ''
	PAULSEEK = ''
	IF PAULORG_TYPE = 'C'
		PAULDBF = 'CUSTOMER_JV'
		PAULSEEK = 'CUSTOMER_I'
	ENDIF
	IF PAULORG_TYPE = 'S'
		PAULDBF = 'SUPPLIER_JV'
		PAULSEEK = 'SUPPLIER_I'
	ENDIF
	IF PAULORG_TYPE = 'A'
		PAULDBF = 'AGENT_JV'
		PAULSEEK = 'AGENT_ID'
	ENDIF
	IF PAULORG_TYPE = 'B'
		PAULDBF = 'BANK_JV'
		PAULSEEK = 'BANK_ID'
	ENDIF
	IF PAULORG_TYPE = 'F'
		PAULDBF = 'SHIPPERS_JV'
		PAULSEEK = 'SHIPPER_ID'
	ENDIF
	IF PAULORG_TYPE = 'E'
		PAULDBF = 'EMPLOYEE_JV'
		PAULSEEK = 'EMPLOYEE_I'
	ENDIF
	IF EMPTY(PAULDBF)
		RETURN .T.
	ENDIF
	SELECT (PAULDBF)
	IF  .NOT. SEEK(ALLTRIM(PAULORG_ID),PAULDBF,PAULSEEK)
		IF  .NOT. EMPTY(PAULMESS)
			= PAULMESSAGE(PAULMESS)
		ENDIF
		RETURN .F.
	ENDIF
	IF PAULTYPE = 'AR'
		REPLACE DEBIT WITH DEBIT + PAULDEBIT_VALUE
	ENDIF
	IF PAULTYPE = 'AP'
		REPLACE CREDIT WITH CREDIT + PAULDEBIT_VALUE
	ENDIF
	IF PAULTYPE = 'CR'
		REPLACE CREDIT WITH CREDIT + PAULDEBIT_VALUE
	ENDIF
	IF PAULTYPE = 'CP'
		REPLACE DEBIT WITH DEBIT + PAULDEBIT_VALUE
	ENDIF
	IF PAULTYPE = 'DN'
		REPLACE DEBIT WITH DEBIT + PAULDEBIT_VALUE
	ENDIF
	IF PAULTYPE = 'CN'
		REPLACE CREDIT WITH CREDIT + PAULDEBIT_VALUE
	ENDIF
	= TABLEUPDATE(.T.)
	SELECT (PAULSELECT)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulACCT_IDDEBIT
	LPARAMETER PAULDBF , PAULPERIOD , PAULACCT_ID , PAULVALUE , PAULDATE , PAULOPENDATEFR ,  ;
		PAULOPENDATETO , PLTHIS_CCY , PLCCYDBF , PLCCY , PLAC_CURR , PLFORWARD ,  ;
		PLDEBIT , PLCREDIT
	LOCAL PAULSELECT , PAULSEEK , PAULPERIODN , PLCOUNT , PLV1 , PLV2
	IF PAULPERIOD > 24 .OR. PAULPERIOD < 1
		RETURN
	ENDIF
	PLCOUNT = 2
	PAULSELECT = SELECT()
	SELECT (PAULDBF)
	PAULPERIODN = 'PERIOD' + ALLTRIM(STR(PAULPERIOD,3))
	PAULDEBIT = 'debit' + ALLTRIM(STR(PAULPERIOD,3))
	PAULCREDIT = 'credit' + ALLTRIM(STR(PAULPERIOD,3))
	SEEK ORDER ACCT_ID PAULACCT_ID
	IF FOUND()
		IF PAULDATE < PAULOPENDATEFR .OR. PAULDATE > PAULOPENDATETO
			IF PAULDATE > PAULOPENDATETO AND EMPTY(PLFORWARD)
				REPLACE FORWARD_BAL WITH FORWARD_BAL + PAULVALUE
			ENDIF
			IF PAULDATE < PAULOPENDATEFR AND EMPTY(PLFORWARD)
				REPLACE BACKWARD_BAL WITH BACKWARD_BAL + PAULVALUE
			ENDIF
			IF PAULDATE > PAULOPENDATETO AND  .NOT. EMPTY(PLFORWARD)
				REPLACE FORWARD_BA WITH FORWARD_BA + PAULVALUE
			ENDIF
			IF PAULDATE < PAULOPENDATEFR AND  .NOT. EMPTY(PLFORWARD)
				REPLACE BACKWARD_B WITH BACKWARD_B + PAULVALUE
			ENDIF
		ELSE
			REPLACE &paulPERIODN. WITH &paulPERIODN.+paulVALUE
			REPLACE BALANCE WITH BALANCE + PAULVALUE
			IF VARTYPE(DEBIT1) <> 'U'
				REPLACE &pauldebit. WITH &pauldebit.+paulVALUE
				REPLACE &paulcredit. WITH &paulcredit.+paulVALUE
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PLDEBIT) .OR.  .NOT. EMPTY(PLCREDIT)
			REPLACE DEBIT WITH DEBIT + PLDEBIT
			REPLACE CREDIT WITH CREDIT + PLCREDIT
		ELSE
			IF PAULVALUE >= 0
				REPLACE DEBIT WITH DEBIT + PAULVALUE
			ELSE
				REPLACE CREDIT WITH CREDIT + ABS(PAULVALUE)
			ENDIF
		ENDIF
		REPLACE LASTUPDATE WITH DATE()
		IF  .NOT. EMPTY(PLCCY)
			IF PLCCY = PLAC_CURR
				REPLACE THIS_CCY1 WITH THIS_CCY1 + PLTHIS_CCY
			ELSE
				DO WHILE PLCOUNT <= 10
					PLV1 = ALLTRIM(PLCCYDBF) + '.ccy' + ALLTRIM(STR(PLCOUNT,2))
					PLV2 = 'this_ccy' + ALLTRIM(STR(PLCOUNT,2))
					if plccy=&plv1.
						replace &plv2. with &plv2.+plthis_ccy
						EXIT
					ENDIF
					PLCOUNT = PLCOUNT + 1
				ENDDO
				PLCOUNT = 2
			ENDIF
		ENDIF
	ENDIF
	SELECT (PAULSELECT)
	RETURN .T.
ENDPROC
*------
PROCEDURE isGEN_NO
	LPARAMETER TSDBF , TSSEEK_VALUE , TSKEY , TSGEN_NO , TSPLUSONE , TSFORMULA , TSMASTER ,  ;
		TSMASTERKEY , TSDOC_NAME , TSAUTOGEN , TSPLUSTWO , TSDBF2 ,  ;
		TSDOC_RUNNINGNO , TSDOC_RUNNINGFROM
	LOCAL PLSELECT_WK , TSDOC_NO , GENNO , NEW_YN , PLTEMPONE , PLTEMPRECNO , TSAUTOGEN ,  ;
		LCOLDEXPR
	PLSELECT_WK = SELECT()
	LCOLDEXPR = ''
	NEW_YN = .F.
	TSDOC_NO = ''
	IF EMPTY(TSAUTOGEN)
		TSAUTOGEN = 'N'
	ENDIF
	IF  .NOT. EMPTY(TSDOC_RUNNINGNO)
		IF  .NOT. EMPTY(TSDOC_RUNNINGFROM)
			&tsDOC_RUNNINGNO.=tsDOC_RUNNINGFROM
		ELSE
			&tsDOC_RUNNINGNO.=1
		ENDIF
	ENDIF
	IF USED(TSDBF)
		SELECT (TSDBF)
		LCOLDEXPR = FILTER()
		SET FILTER TO
	ELSE
		USE IN 0 (TSDBF)
		SELECT (TSDBF)
	ENDIF
	SET DELETED OFF
	IF SEEK(TSSEEK_VALUE,TSDBF,TSKEY)
		IF &tsGEN_NO.
			IF  .NOT. EOF(TSMASTER)
				PLTEMPRECNO = RECNO(TSMASTER)
			ELSE
				PLTEMPRECNO = 0
			ENDIF
			IF  .NOT. NOCOUNTBACK .OR. TSAUTOGEN = 'Y'
				IF  .NOT. EMPTY(TSPLUSTWO)
					pltemptwo=&tsPLUSTWO.
					IF PLTEMPTWO - 2 > 0
						REPLACE &tsPLUSTWO. WITH &tsPLUSTWO. - 2
					ELSE
						REPLACE &tsPLUSTWO. WITH 1
					ENDIF
				ENDIF
				pltempone=&tsPLUSONE.
				IF PLTEMPONE - 2 > 0
					REPLACE &tsPLUSONE. WITH &tsPLUSONE. - 2
				ELSE
					REPLACE &tsPLUSONE. WITH 1
				ENDIF
			ENDIF
			GENNO=&tsFORMULA.
			tsDOC_NO=&GENNO.
			TSDOCGEN_COUNTER = 1
			DO WHILE SEEK(TSDOC_NO,TSMASTER,TSMASTERKEY)
				GENNO=&tsFORMULA.
				tsDOC_NO=&GENNO.
				REPLACE &tsPLUSONE. WITH &tsPLUSONE.+ 1
				IF  .NOT. EMPTY(TSPLUSTWO)
					SELECT (TSDBF2)
					REPLACE &tsPLUSTWO. WITH &tsPLUSTWO.+ 1
					= TABLEUPDATE(.T.)
				ENDIF
				IF  .NOT. EMPTY(TSDOC_RUNNINGNO)
					&tsDOC_RUNNINGNO.=&tsDOC_RUNNINGNO. +1
				ENDIF
				TSDOCGEN_COUNTER = TSDOCGEN_COUNTER + 1
				IF TSDOCGEN_COUNTER > 9999
					EXIT
				ENDIF
				SELECT (TSDBF)
			ENDDO
			IF  .NOT. NOCOUNTBACK .OR. TSAUTOGEN = 'Y'
				IF  .NOT. EMPTY(TSPLUSTWO)
					REPLACE &tsPLUSTWO. WITH pltemptwo
					= TABLEUPDATE(.T.,.T.,TSDBF2)
				ENDIF
				REPLACE &tsPLUSONE. WITH pltempone
				= TABLEUPDATE(.T.,.T.,TSDBF)
			ENDIF
			IF PLTEMPRECNO <> 0
				GO PLTEMPRECNO IN (TSMASTER)
			ENDIF
		ELSE
			TSDOC_NO = ''
		ENDIF
	ENDIF
	IF DEF_LANG = 'ENG'
		IF MESSAGEBOX('Do you want to create ' + ALLTRIM(TSDOC_NAME) + ' ? ' + TSDOC_NO,292,'NEW') =  ;
				7
			NEW_YN = .F.
		ELSE
			NEW_YN = .T.
		ENDIF
	ELSE
		IF MESSAGEBOX(ITMSG('00086') + ALLTRIM(TSDOC_NAME) + ITMSG('00087') + TSDOC_NO,292,ITMSG('00088')) =  ;
				7
			NEW_YN = .F.
		ELSE
			NEW_YN = .T.
		ENDIF
	ENDIF
	SET DELETED ON
	IF  .NOT. EMPTY(LCOLDEXPR)
		SELECT (TSDBF)
		set filter to &lcOldExpr
	ENDIF
	SELECT (PLSELECT_WK)
	RETURN NEW_YN
ENDPROC
*------
PROCEDURE paulUPC_A
	LPARAMETER PAULBARCODE_VALUE
	LOCAL BARCODE_VALUE , SELECT_UPCA , PAULFIELD_NAME
	SELECT_UPCA = SELECT()
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	IF LEN(BARCODE_VALUE) <> 12
		RETURN ''
	ENDIF
	PAULFIELD_NAME = ''
	BN1 = '0'
	BN2 = STR(VAL(SUBSTR(BARCODE_VALUE,1,1)),1,1)
	BN3 = STR(VAL(SUBSTR(BARCODE_VALUE,2,1)),1,1)
	BN4 = STR(VAL(SUBSTR(BARCODE_VALUE,3,1)),1,1)
	BN5 = STR(VAL(SUBSTR(BARCODE_VALUE,4,1)),1,1)
	BN6 = STR(VAL(SUBSTR(BARCODE_VALUE,5,1)),1,1)
	BN7 = STR(VAL(SUBSTR(BARCODE_VALUE,6,1)),1,1)
	BN8 = STR(VAL(SUBSTR(BARCODE_VALUE,7,1)),1,1)
	BN9 = STR(VAL(SUBSTR(BARCODE_VALUE,8,1)),1,1)
	BN10 = STR(VAL(SUBSTR(BARCODE_VALUE,9,1)),1,1)
	BN11 = STR(VAL(SUBSTR(BARCODE_VALUE,10,1)),1,1)
	BN12 = STR(VAL(SUBSTR(BARCODE_VALUE,11,1)),1,1)
	BN13 = STR(VAL(SUBSTR(BARCODE_VALUE,12,1)),1,1)
	IF  .NOT. USED('BARCODE')
		USE IN 0 BARCODE ORDER TYPE
	ENDIF
	PAULSEEK_YNBAR = SEEK('UPC-A','BARCODE','TYPE')
	IND = 2
	PAULFIELD_NAME = BARCODE.LEFT
	DO WHILE IND <= 13
		PAULVAR = 'bn' + ALLTRIM(STR(IND,2,1))
		IF IND <= 7
			paulA_N='BARCODE.A_'+&paulVAR.
		ELSE
			paulA_N='BARCODE.A_2'+&paulVAR.
		ENDIF
		paulFIELD_NAME=paulFIELD_NAME+&paulA_N.
		IF IND = 7
			PAULFIELD_NAME = PAULFIELD_NAME + BARCODE.CENTER
		ENDIF
		IND = IND + 1
	ENDDO
	PAULFIELD_NAME = PAULFIELD_NAME + BARCODE.RIGHT
	SELECT (SELECT_UPCA)
	RETURN PAULFIELD_NAME
ENDPROC
*------
PROCEDURE IFUPC_A
	LPARAMETER PAULBARCODE_VALUE , PAULWARNING , PAULTEXT6 , PAULTEXT7 , PAULTEXT5 ,  ;
		PAULMESSAGE4 , PAULMESSAGE3
	LOCAL BARCODE_VALUE , SELECT_UPCA
	SELECT_UPCA = SELECT()
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	IF LEN(BARCODE_VALUE) <> 12
		= PAULMESSAGE(ALLTRIM(PAULTEXT6) + '  12',ALLTRIM(PAULWARNING))
		RETURN .F.
	ENDIF
	BN1 = '0'
	BN2 = SUBSTR(BARCODE_VALUE,1,1)
	BN3 = SUBSTR(BARCODE_VALUE,2,1)
	BN4 = SUBSTR(BARCODE_VALUE,3,1)
	BN5 = SUBSTR(BARCODE_VALUE,4,1)
	BN6 = SUBSTR(BARCODE_VALUE,5,1)
	BN7 = SUBSTR(BARCODE_VALUE,6,1)
	BN8 = SUBSTR(BARCODE_VALUE,7,1)
	BN9 = SUBSTR(BARCODE_VALUE,8,1)
	BN10 = SUBSTR(BARCODE_VALUE,9,1)
	BN11 = SUBSTR(BARCODE_VALUE,10,1)
	BN12 = SUBSTR(BARCODE_VALUE,11,1)
	BN13 = SUBSTR(BARCODE_VALUE,12,1)
	BC1 = VAL(BN2) + VAL(BN4) + VAL(BN6) + VAL(BN8) + VAL(BN10) + VAL(BN12)
	BC1 = BC1 * 3
	BC2 = VAL(BN1) + VAL(BN3) + VAL(BN5) + VAL(BN7) + VAL(BN9) + VAL(BN11)
	BC3 = 10 - ((BC1 + BC2) / 10 - INT((BC1 + BC2) / 10)) * 10
	IF BC3 = 10
		BC3 = 0
	ENDIF
	IF VAL(BN13) <> BC3
		= PAULMESSAGE(ALLTRIM(PAULTEXT7) + STR(BC3,3,0),ALLTRIM(PAULWARNING))
		RETURN .F.
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE IFUPC_E
	LPARAMETER PAULBARCODE_VALUE , PAULWARNING , PAULTEXT6 , PAULTEXT7 , PAULTEXT5 ,  ;
		PAULMESSAGE4 , PAULMESSAGE3
	LOCAL BARCODE_VALUE , SELECT_UPCE , PAULNUM
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	IF LEN(BARCODE_VALUE) <> 7
		= PAULMESSAGE(ALLTRIM(PAULTEXT6) + '  7',ALLTRIM(PAULWARNING))
		RETURN .F.
	ENDIF
	PAULNUM = VAL(BARCODE_VALUE)
	BN2 = SUBSTR(BARCODE_VALUE,1,1)
	BN3 = SUBSTR(BARCODE_VALUE,2,1)
	BN4 = SUBSTR(BARCODE_VALUE,3,1)
	BN5 = SUBSTR(BARCODE_VALUE,4,1)
	BN6 = SUBSTR(BARCODE_VALUE,5,1)
	BN7 = SUBSTR(BARCODE_VALUE,6,1)
	BN8 = SUBSTR(BARCODE_VALUE,7,1)
	DO CASE
		CASE PAULNUM = 0
			BARCODE_VALUE = '0' + BN2 + BN3 + '00000' + BN4 + BN5 + BN6 + BN8
		CASE PAULNUM = 1
			BARCODE_VALUE = '0' + BN2 + BN3 + '10000' + BN4 + BN5 + BN6 + BN8
		CASE PAULNUM = 2
			BARCODE_VALUE = '0' + BN2 + BN3 + '20000' + BN4 + BN5 + BN6 + BN8
		CASE PAULNUM = 3
			BARCODE_VALUE = '0' + BN2 + BN3 + BN4 + '00000' + BN5 + BN6 + BN8
		CASE PAULNUM = 4
			BARCODE_VALUE = '0' + BN2 + BN3 + BN4 + BN5 + '00000' + BN6 + BN8
		OTHERWISE
			BARCODE_VALUE = '0' + BN2 + BN3 + BN4 + BN5 + BN6 + '0000' + BN7 + BN8
	ENDCASE
	BN1 = '0'
	BN2 = SUBSTR(BARCODE_VALUE,1,1)
	BN3 = SUBSTR(BARCODE_VALUE,2,1)
	BN4 = SUBSTR(BARCODE_VALUE,3,1)
	BN5 = SUBSTR(BARCODE_VALUE,4,1)
	BN6 = SUBSTR(BARCODE_VALUE,5,1)
	BN7 = SUBSTR(BARCODE_VALUE,6,1)
	BN8 = SUBSTR(BARCODE_VALUE,7,1)
	BN9 = SUBSTR(BARCODE_VALUE,8,1)
	BN10 = SUBSTR(BARCODE_VALUE,9,1)
	BN11 = SUBSTR(BARCODE_VALUE,10,1)
	BN12 = SUBSTR(BARCODE_VALUE,11,1)
	BN13 = SUBSTR(BARCODE_VALUE,12,1)
	BC1 = VAL(BN2) + VAL(BN4) + VAL(BN6) + VAL(BN8) + VAL(BN10) + VAL(BN12)
	BC1 = BC1 * 3
	BC2 = VAL(BN1) + VAL(BN3) + VAL(BN5) + VAL(BN7) + VAL(BN9) + VAL(BN11)
	BC3 = 10 - ((BC1 + BC2) / 10 - INT((BC1 + BC2) / 10)) * 10
	IF BC3 = 10
		BC3 = 0
	ENDIF
	IF VAL(BN13) <> BC3
		= PAULMESSAGE(ALLTRIM(PAULTEXT7) + STR(BC3,3,0),ALLTRIM(PAULWARNING))
		RETURN .F.
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE paulUPC_E
	LPARAMETER PAULBARCODE_VALUE
	LOCAL BARCODE_VALUE , SELECT_UPCE , PAULFIELD_NAME
	SELECT_UPCE = SELECT()
	PAULFIELD_NAME = ''
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	IF LEN(BARCODE_VALUE) <> 7
		RETURN ''
	ENDIF
	BN1 = STR(VAL(SUBSTR(BARCODE_VALUE,1,1)),1,1)
	BN2 = STR(VAL(SUBSTR(BARCODE_VALUE,2,1)),1,1)
	BN3 = STR(VAL(SUBSTR(BARCODE_VALUE,3,1)),1,1)
	BN4 = STR(VAL(SUBSTR(BARCODE_VALUE,4,1)),1,1)
	BN5 = STR(VAL(SUBSTR(BARCODE_VALUE,5,1)),1,1)
	BN6 = STR(VAL(SUBSTR(BARCODE_VALUE,6,1)),1,1)
	BN7 = STR(VAL(SUBSTR(BARCODE_VALUE,7,1)),1,1)
	IF  .NOT. USED('BARCODE')
		USE IN 0 BARCODE ORDER TYPE
	ENDIF
	PAULSEEKBAR = SEEK('UPC-E','BARCODE','TYPE')
	PAULCK_DIGIT = BN7
	PLIND0 = '111000'
	PLIND1 = '110100'
	PLIND2 = '110010'
	PLIND3 = '110001'
	PLIND4 = '101100'
	PLIND5 = '100110'
	PLIND6 = '100011'
	PLIND7 = '101010'
	PLIND8 = '101001'
	PLIND9 = '100101'
	IND = 1
	PAULSCHEME = 'plIND' + PAULCK_DIGIT
	paulSCHEME=&paulSCHEME.
	PAULFIELD_NAME = BARCODE.LEFT
	DO WHILE IND <= 6
		PAULA_N = SUBSTR(PAULSCHEME,IND,1)
		IF PAULA_N = '0'
			PAULA_N = ''
		ENDIF
		PAULA_N = 'BARCODE.A_' + PAULA_N
		PAULA_N = PAULA_N + STR(VAL(SUBSTR(BARCODE_VALUE,IND,1)),1,1)
		paulFIELD_NAME=paulFIELD_NAME+&paulA_N.
		IND = IND + 1
	ENDDO
	PAULFIELD_NAME = PAULFIELD_NAME + BARCODE.RIGHT
	SELECT (SELECT_UPCE)
	RETURN PAULFIELD_NAME
ENDPROC
*------
PROCEDURE paulBARCODE_BIN
	LPARAMETER PAULBN1 , PAULREPLACE , PAULWITH
	LOCAL PAULFIELD_NAME
	PAULFIELD_NAME = PAULWITH + PAULBN1
	replace &paulREPLACE. WITH &paulFIELD_NAME.
	RETURN
ENDPROC
*------
PROCEDURE IFEAN_13
	LPARAMETER PAULBARCODE_VALUE , PAULWARNING , PAULTEXT6 , PAULTEXT7 , PAULTEXT5 ,  ;
		PAULMESSAGE4 , PAULMESSAGE3
	LOCAL BARCODE_VALUE , SELECT_UPCA
	SELECT_UPCA = SELECT()
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	IF LEN(BARCODE_VALUE) <> 13
		= PAULMESSAGE(ALLTRIM(PAULTEXT6) + '  13',ALLTRIM(PAULWARNING))
		RETURN ''
	ENDIF
	BN1 = SUBSTR(BARCODE_VALUE,1,1)
	BN2 = SUBSTR(BARCODE_VALUE,2,1)
	BN3 = SUBSTR(BARCODE_VALUE,3,1)
	BN4 = SUBSTR(BARCODE_VALUE,4,1)
	BN5 = SUBSTR(BARCODE_VALUE,5,1)
	BN6 = SUBSTR(BARCODE_VALUE,6,1)
	BN7 = SUBSTR(BARCODE_VALUE,7,1)
	BN8 = SUBSTR(BARCODE_VALUE,8,1)
	BN9 = SUBSTR(BARCODE_VALUE,9,1)
	BN10 = SUBSTR(BARCODE_VALUE,10,1)
	BN11 = SUBSTR(BARCODE_VALUE,11,1)
	BN12 = SUBSTR(BARCODE_VALUE,12,1)
	BN13 = SUBSTR(BARCODE_VALUE,13,1)
	BC1 = VAL(BN2) + VAL(BN4) + VAL(BN6) + VAL(BN8) + VAL(BN10) + VAL(BN12)
	BC1 = BC1 * 3
	BC2 = VAL(BN1) + VAL(BN3) + VAL(BN5) + VAL(BN7) + VAL(BN9) + VAL(BN11)
	BC3 = 10 - ((BC1 + BC2) / 10 - INT((BC1 + BC2) / 10)) * 10
	IF BC3 = 10
		BC3 = 0
	ENDIF
	IF VAL(BN13) <> BC3
		= PAULMESSAGE(ALLTRIM(PAULTEXT7) + STR(BC3,3,0),ALLTRIM(PAULWARNING))
		RETURN ''
	ENDIF
	SELECT (SELECT_UPCA)
	RETURN ALLTRIM(STR(BC3,3,0))
ENDPROC
*------
PROCEDURE paulEAN_13
	LPARAMETER PAULBARCODE
	LOCAL IND , PAULSCHEME , PAULA_N , PAULEAN_WK
	IF LEN(PAULBARCODE) <> 13
		RETURN ''
	ENDIF
	PAULEAN_WK = SELECT()
	IF  .NOT. USED('BARCODE')
		USE IN 0 BARCODE ORDER TYPE
	ENDIF
	PAULSEEK_YNEAN = SEEK('EAN-13','BARCODE','TYPE')
	PAULCK_DIGIT = SUBSTR(PAULBARCODE,1,1)
	PLIND0 = '0000000222222'
	PLIND1 = '0001011222222'
	PLIND2 = '0001101222222'
	PLIND3 = '0001110222222'
	PLIND4 = '0010011222222'
	PLIND5 = '0011001222222'
	PLIND6 = '0011100222222'
	PLIND7 = '0010101222222'
	PLIND8 = '0010110222222'
	PLIND9 = '0011010222222'
	IND = 2
	PAULSCHEME = 'plIND' + PAULCK_DIGIT
	paulSCHEME=&paulSCHEME.
	PAULFIELD_NAME = BARCODE.LEFT
	DO WHILE IND <= 13
		PAULA_N = SUBSTR(PAULSCHEME,IND,1)
		PAULA_N = STR(VAL(PAULA_N),1,1)
		IF PAULA_N = '0'
			PAULA_N = ''
		ENDIF
		PAULA_N = 'BARCODE.A_' + PAULA_N
		PAULA_N = PAULA_N + SUBSTR(PAULBARCODE,IND,1)
		paulFIELD_NAME=paulFIELD_NAME+&paulA_N.
		IF IND = 7
			PAULFIELD_NAME = PAULFIELD_NAME + BARCODE.CENTER
		ENDIF
		IND = IND + 1
	ENDDO
	PAULFIELD_NAME = PAULFIELD_NAME + BARCODE.RIGHT
	SELECT (PAULEAN_WK)
	RETURN PAULFIELD_NAME
ENDPROC
*------
PROCEDURE IFEAN_8
	LPARAMETER PAULBARCODE_VALUE , PAULWARNING , PAULTEXT6 , PAULTEXT7 , PAULTEXT5 ,  ;
		PAULMESSAGE4 , PAULMESSAGE3
	LOCAL BARCODE_VALUE , SELECT_EAN8
	SELECT_EAN8 = SELECT()
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	IF LEN(BARCODE_VALUE) <> 8
		= PAULMESSAGE(ALLTRIM(PAULTEXT6) + '  8',ALLTRIM(PAULWARNING))
		RETURN ''
	ENDIF
	BN1 = SUBSTR(BARCODE_VALUE,1,1)
	BN2 = SUBSTR(BARCODE_VALUE,2,1)
	BN3 = SUBSTR(BARCODE_VALUE,3,1)
	BN4 = SUBSTR(BARCODE_VALUE,4,1)
	BN5 = SUBSTR(BARCODE_VALUE,5,1)
	BN6 = SUBSTR(BARCODE_VALUE,6,1)
	BN7 = SUBSTR(BARCODE_VALUE,7,1)
	BN8 = SUBSTR(BARCODE_VALUE,8,1)
	BC1 = VAL(BN1) + VAL(BN3) + VAL(BN5) + VAL(BN7)
	BC1 = BC1 * 3
	BC2 = VAL(BN2) + VAL(BN4) + VAL(BN6)
	BC3 = 10 - ((BC1 + BC2) / 10 - INT((BC1 + BC2) / 10)) * 10
	IF BC3 = 10
		BC3 = 0
	ENDIF
	IF VAL(BN8) <> BC3
		= PAULMESSAGE(ALLTRIM(PAULTEXT7) + STR(BC3,3,0),ALLTRIM(PAULWARNING))
		RETURN ''
	ENDIF
	SELECT (SELECT_EAN8)
	RETURN ALLTRIM(STR(BC3,3,0))
ENDPROC
*------
PROCEDURE paulEAN_8
	LPARAMETER PAULBARCODE
	LOCAL IND , PAULSCHEME , PAULA_N , PAULEAN_WK
	IF LEN(PAULBARCODE) <> 8
		RETURN ''
	ENDIF
	PAULEAN_WK = SELECT()
	PAULFIELD_NAME = ''
	BN1 = STR(VAL(SUBSTR(PAULBARCODE,1,1)),1,1)
	BN2 = STR(VAL(SUBSTR(PAULBARCODE,2,1)),1,1)
	BN3 = STR(VAL(SUBSTR(PAULBARCODE,3,1)),1,1)
	BN4 = STR(VAL(SUBSTR(PAULBARCODE,4,1)),1,1)
	BN5 = STR(VAL(SUBSTR(PAULBARCODE,5,1)),1,1)
	BN6 = STR(VAL(SUBSTR(PAULBARCODE,6,1)),1,1)
	BN7 = STR(VAL(SUBSTR(PAULBARCODE,7,1)),1,1)
	BN8 = STR(VAL(SUBSTR(PAULBARCODE,8,1)),1,1)
	IF  .NOT. USED('BARCODE')
		USE IN 0 BARCODE ORDER TYPE
	ENDIF
	IF SEEK('EAN-8','BARCODE','TYPE')
		PAULFIELD_NAME = BARCODE.LEFT
		FIELD_NAME = 'BARCODE.A_' + BN1
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		FIELD_NAME = 'BARCODE.A_' + BN2
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		FIELD_NAME = 'BARCODE.A_' + BN3
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		FIELD_NAME = 'BARCODE.A_' + BN4
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		PAULFIELD_NAME = PAULFIELD_NAME + BARCODE.CENTER
		FIELD_NAME = 'BARCODE.A_2' + BN5
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		FIELD_NAME = 'BARCODE.A_2' + BN6
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		FIELD_NAME = 'BARCODE.A_2' + BN7
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		FIELD_NAME = 'BARCODE.A_2' + BN8
		paulFIELD_NAME=paulFIELD_NAME+&field_name.
		PAULFIELD_NAME = PAULFIELD_NAME + BARCODE.RIGHT
	ENDIF
	SELECT (PAULEAN_WK)
	RETURN PAULFIELD_NAME
ENDPROC
*------
PROCEDURE paulDATE
	LPARAMETER PLDATE , PLTYPE , PLON
	LOCAL PLDATE , PLTYPE , PLMONTH , PLDAY
	SET CENTURY ON
	IF  .NOT. EMPTY(PLON)
		SET CENTURY &plon.
	ENDIF
	IF SET('century') = 'ON'
		PLYEAR = ALLTRIM(STR(YEAR(PLDATE)))
	ELSE
		PLYEAR = SUBSTR(ALLTRIM(STR(YEAR(PLDATE))),3,2)
	ENDIF
	IF PLDATE = {}
		RETURN '  /  / '
	ENDIF
	IF VARTYPE(PLDATE) = 'C'
		PLDATE = CTOD(PLDATE)
	ENDIF
	IF  .NOT. EMPTY(PLTYPE)
		IF VARTYPE(PLTYPE) = 'C' .OR. VARTYPE(PLTYPE) = 'M'
			PLTYPE = VAL(PLTYPE)
		ENDIF
	ELSE
		PLTYPE = 1
	ENDIF
	IF PLTYPE = 1
		PLMONTH = SUBSTR(PAULCMONTH(PLDATE),1,3)
		PLDAY = ALLTRIM(STR(DAY(PLDATE)))
		RETURN PLDAY + '-' + PLMONTH + '-' + PLYEAR
	ENDIF
	IF PLTYPE = 2
		PLMONTH = PAULCMONTH(PLDATE)
		PLDAY = ALLTRIM(STR(DAY(PLDATE)))
		RETURN PLMONTH + ' ' + PLDAY + ', ' + PLYEAR
	ENDIF
	IF PLTYPE = 3
		PLMONTH = PAULCMONTH(PLDATE)
		PLDAY = ALLTRIM(STR(DAY(PLDATE)))
		RETURN PLDAY + ' ' + PLMONTH + ', ' + PLYEAR
	ENDIF
	IF PLTYPE = 4
		IF DEF_LANG = 'CHS'
			PLDATE = DTOS(PLDATE)
			RETURN LEFT(PLDATE,4) + '' + SUBSTR(PLDATE,5,2) + '' + RIGHT(PLDATE,2) + ''
		ELSE
			RETURN DMY(PLDATE)
		ENDIF
	ENDIF
	IF PLTYPE = 5
		IF EMPTY(PLDATE)
			PLDATE = DATE()
		ENDIF
		RETURN PLDATE - DAY(PLDATE) + 1
	ENDIF
	IF PLTYPE = 6
		IF EMPTY(PLDATE)
			PLDATE = DATE()
		ENDIF
		VPLLASTDATE = PLDATE
		VPLCOUNTER = 1
		DO WHILE VPLCOUNTER <= 32
			VPLCOUNTER = VPLCOUNTER + 1
			VPLLASTDATE = VPLLASTDATE + 1
			IF MONTH(PLDATE) <> MONTH(VPLLASTDATE)
				EXIT
			ENDIF
		ENDDO
		RETURN VPLLASTDATE - 1
	ENDIF
	RETURN DTOC(PLDATE)
ENDPROC
*------
PROCEDURE PAULCMONTH
	LPARAMETER VMONTHVALUE
	VMONTHVALUE = MONTH(VMONTHVALUE)
	IF VMONTHVALUE = 1
		RETURN 'January'
	ENDIF
	IF VMONTHVALUE = 2
		RETURN 'February'
	ENDIF
	IF VMONTHVALUE = 3
		RETURN 'March'
	ENDIF
	IF VMONTHVALUE = 4
		RETURN 'April'
	ENDIF
	IF VMONTHVALUE = 5
		RETURN 'May'
	ENDIF
	IF VMONTHVALUE = 6
		RETURN 'June'
	ENDIF
	IF VMONTHVALUE = 7
		RETURN 'July'
	ENDIF
	IF VMONTHVALUE = 8
		RETURN 'August'
	ENDIF
	IF VMONTHVALUE = 9
		RETURN 'September'
	ENDIF
	IF VMONTHVALUE = 10
		RETURN 'October'
	ENDIF
	IF VMONTHVALUE = 11
		RETURN 'November'
	ENDIF
	IF VMONTHVALUE = 12
		RETURN 'December'
	ENDIF
	RETURN ''
ENDPROC
*------
PROCEDURE paulDATAEXCH
	LPARAMETER JKFROM , JKTO , JKUNIQUE_KEY , JKVALUE
	LOCAL JKFROM , JKTO , JKVALUE , JKUNIQUE_KEY
	SELECT (JKFROM)
	SEEK JKVALUE
	IF FOUND()
		DO WHILE MACROS  ???FUN[CA] ('&jkunique_value. = jkvalue .and. .NOT. EOF()')
			IF &jkunique_value. = jkvalue .and. .NOT. EOF()
				WAIT WINDOW 'Append Item :  '+jkunique_key + ' = ' + &jkunique_value. NOWAIT
				SCATTER MEMO MEMVAR
				SELECT (JKTO)
				APPEND BLANK
				GATHER MEMO MEMVAR
			ENDIF
			SELECT (JKFROM)
			SKIP
		ENDDO
	ENDIF
ENDPROC
*------
PROCEDURE paulQTY_UNIT
	LPARAMETER JKQTY1 , JKUNIT1 , JKQTY2 , JKUNIT2 , JKQTY3 , JKUNIT3 , JKQTY4 , JKUNIT4 ,  ;
		JKQTY5 , JKUNIT5
	LOCAL PAULSTRING , JKQTY1 , JKUNIT1 , JKQTY2 , JKUNIT2 , JKQTY3 , JKUNIT3 , JKQTY4 ,  ;
		JKUNIT4 , JKQTY5 , JKUNIT5 , JACKYUSED
	PAULSTRING = ''
	JACKYUSED = .T.
	IF JKQTY1 <> 0
		PAULSTRING = TRANSFORM(JKQTY1,QTY_PICT) + ' ' + JKUNIT1
	ENDIF
	IF JKQTY2 <> 0
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + TRANSFORM(JKQTY2,QTY_PICT) + ' ' + JKUNIT2
	ENDIF
	IF JKQTY3 <> 0
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + TRANSFORM(JKQTY3,QTY_PICT) + ' ' + JKUNIT3
		JACKYUSED = .T.
	ENDIF
	IF JKQTY4 <> 0
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + TRANSFORM(JKQTY4,QTY_PICT) + ' ' + JKUNIT4
		JACKYUSED = .T.
	ENDIF
	IF JKQTY5 <> 0
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + TRANSFORM(JKQTY5,QTY_PICT) + ' ' + JKUNIT5
	ENDIF
	RETURN PAULSTRING
ENDPROC
*------
PROCEDURE paulQTY_LINK
	LPARAMETER PLQTY1 , PLQTY2 , PLQTY3 , PLQTY4 , PLQTY5 , PLQTY6 , PLQTY7
	LOCAL PAULSTRING , PLQTY1 , PLQTY2 , PLQTY3 , PLQTY4 , PLQTY5 , PLQTY6 , PLQTY7
	PAULSTRING = IIF( .NOT. EMPTY(PLQTY1),PLQTY1,'')
	IF  .NOT. EMPTY(PLQTY2)
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + PLQTY2
	ENDIF
	IF  .NOT. EMPTY(PLQTY3)
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + PLQTY3
	ENDIF
	IF  .NOT. EMPTY(PLQTY4)
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + PLQTY4
	ENDIF
	IF  .NOT. EMPTY(PLQTY5)
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + PLQTY5
	ENDIF
	IF  .NOT. EMPTY(PLQTY6)
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + PLQTY6
	ENDIF
	IF  .NOT. EMPTY(PLQTY7)
		IF  .NOT. EMPTY(PAULSTRING)
			PAULSTRING = PAULSTRING + CHR(13)
		ENDIF
		PAULSTRING = PAULSTRING + PLQTY7
	ENDIF
	RETURN PAULSTRING
ENDPROC
*------
PROCEDURE paulrevert
	LPARAMETER PLSTRING
	LOCAL PLSTRING , PLLENGTH , PLFINAL
	PLLENGTH = LEN(PLSTRING)
	PLFINAL = ''
	IF PLLENGTH <= 0
		RETURN ''
	ENDIF
	DO WHILE PLLENGTH >= 1
		PLFINAL = PLFINAL + SUBSTR(PLSTRING,PLLENGTH,1) + CHR(13)
		PLLENGTH = PLLENGTH - 1
	ENDDO
	RETURN PLFINAL
ENDPROC
*------
PROCEDURE paulrevert1
	LPARAMETER PLSTRING
	LOCAL PLSTRING , PLLENGTH , PLFINAL , PLINDEX
	PLLENGTH = LEN(PLSTRING)
	PLFINAL = ''
	PLINDEX = 1
	IF PLLENGTH <= 0
		RETURN ''
	ENDIF
	DO WHILE PLINDEX <= PLLENGTH
		PLFINAL = PLFINAL + SUBSTR(PLSTRING,PLINDEX,1) + CHR(13)
		PLINDEX = PLINDEX + 1
	ENDDO
	RETURN PLFINAL
ENDPROC
*------
PROCEDURE paulFASTRECALL
	LPARAMETER PAULDBF , PAULTEMPDBF , PAULORDER , PAULSEEKFIELD , PAULKEY , PAULKEYNAME ,  ;
		PAULSCREEN_NAME , PAULFIELDNAME1 , PAULFIELD1 , PAULFIELDNAME2 ,  ;
		PAULFIELD2 , PAULDBF1 , PAULDBF2 , PAULDBF3 , PAULDBF4 , PAULDBF5 , PAULFIELD11 ,  ;
		PAULFIELD21
	LOCAL FASTREC_NUM , SET_DEL1 , SET_EXACT1 , SET_NEAR1 , APPQRY2 , SEEK_TF ,  ;
		SELECT_FASTWKD , PAULORDER
	SEEK_VALUE = ''
	APPEND_YN = .F.
	SELECT (PAULDBF)
	FASTREC_NUM = RECNO()
	PAULORDER = ORDER()
	SELECT_FASTWKD = SELECT()
	IF USED(PAULTEMPDBF)
		USE IN (PAULTEMPDBF)
	ENDIF
	COPY TO (PAULTEMPDBF) STRUCTURE
	USE IN 0 (PAULTEMPDBF)
	SELECT (PAULDBF)
	SET DELETED OFF
	WAIT WINDOW NOWAIT 'Filter deleted records ... '
	SET ORDER TO rec_del
	SEEK .T.
	IF FOUND()
		PAULRETRIVE = 1
		DO WHILE DELETED(PAULDBF)
			IF DELETED(PAULDBF) AND  .NOT. EOF(PAULDBF)
				SELECT (PAULDBF)
				SCATTER MEMVAR
				SELECT (PAULTEMPDBF)
				IF ALLTRIM(UPPER(ALIAS())) = ALLTRIM(UPPER(PAULTEMPDBF))
					INSERT INTO (PAULTEMPDBF) FROM MEMVAR
				ENDIF
				IF  .NOT. EMPTY(PAULFIELD11)
					replace &paulfield1. with &paulfield11
				ENDIF
				IF  .NOT. EMPTY(PAULFIELD21)
					replace &paulfield2. with &paulfield21
				ENDIF
				PAULRETRIVE = PAULRETRIVE + 1
			ENDIF
			SELECT (PAULDBF)
			IF  .NOT. EOF()
				SKIP
			ENDIF
			WAIT WINDOW NOWAIT 'Scanning records : ' + ALLTRIM(STR(PAULRETRIVE - 1,7))
			IF PAULRETRIVE / 200 = INT(PAULRETRIVE / 200)
				IF  .NOT. PAULASK_YN(ALLTRIM(STR(PAULRETRIVE - 1,7)) + ' Record(s) retrived !  Continue... ? ','WARNING')
					EXIT
				ENDIF
			ENDIF
		ENDDO
	ENDIF
	SELECT (PAULTEMPDBF)
	GO TOP
	SET_EXACT1 = SET('EXACT')
	SET_NEAR1 = SET('NEAR')
	APPQRY2 = CREATEOBJECT('RECALL_REC')
	APPQRY2.CAPTION = PAULSCREEN_NAME
	APPQRY2.TXTBROWSER.RECORDSOURCE = PAULTEMPDBF
	APPQRY2.TXTBROWSER.ENABLED = .T.
	APPQRY2.TXTBROWSER.COLUMN1.CONTROLSOURCE = PAULFIELD1
	APPQRY2.TXTBROWSER.COLUMN2.CONTROLSOURCE = PAULFIELD2
	APPQRY2.USEDTEMP = .T.
	APPQRY2.TXTBROWSER.COLUMN1.HEADER1.CAPTION = PAULFIELDNAME1
	APPQRY2.TXTBROWSER.COLUMN2.HEADER1.CAPTION = PAULFIELDNAME2
	APPQRY2.DBF = PAULDBF
	APPQRY2.KEYFIELD = PAULKEY
	APPQRY2.KEYNAME1.CAPTION = PAULKEYNAME
	APPQRY2.SEEKFIELD = PAULSEEKFIELD
	APPQRY2.SHOW()
	IF USED(PAULTEMPDBF)
		USE IN (PAULTEMPDBF)
	ENDIF
	IF APPEND_YN
		SELECT (PAULDBF)
		IF SEEK(SEEK_VALUE,PAULDBF,PAULSEEKFIELD)
			seek_value=UPPER(&paulKEY.)
		ENDIF
		IF  .NOT. EMPTY(PAULDBF1)
			SELECT (PAULDBF1)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		IF  .NOT. EMPTY(PAULDBF2)
			SELECT (PAULDBF2)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		IF  .NOT. EMPTY(PAULDBF3)
			SELECT (PAULDBF3)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		IF  .NOT. EMPTY(PAULDBF4)
			SELECT (PAULDBF4)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		IF  .NOT. EMPTY(PAULDBF5)
			SELECT (PAULDBF5)
			RECALL FOR UPPER(&paulKEY.) = seek_value
		ENDIF
		SELECT (PAULDBF)
		IF  .NOT. EMPTY(PAULORDER)
			SET ORDER TO &paulORDER.
		ENDIF
		SEEK_TF = SEEK(SEEK_VALUE,PAULDBF,PAULSEEKFIELD)
	ELSE
		SEEK_VALUE = ''
		SELECT (SELECT_FASTWKD)
		IF  .NOT. EMPTY(PAULORDER)
			SET ORDER TO &paulORDER.
		ENDIF
		IF FASTREC_NUM <= RECCOUNT() AND RECCOUNT() <> 0
			GO FASTREC_NUM
		ENDIF
	ENDIF
	SET DELETED ON
	SET NEAR &SET_NEAR1.
	SET EXACT &SET_EXACT1.
	RELEASE APPQRY2
	RETURN SEEK_VALUE
ENDPROC
*------
PROCEDURE paulSCANDBF
	LPARAMETER PLFROMDBF , PLTEMPDBF , PLUSEDBF , PLSEEK , PLSTART , PLCONDITION , PLNO_REC ,  ;
		SYS_MODIFY , PAULORDER
	LOCAL PAULSET_NEAR , PAULSET_EXACT
	ON ERROR RETURN
	IF SYS_MODIFY
		RETURN .F.
	ENDIF
	PAULALIAS = ALLTRIM(PLFROMDBF) + 'SQL'
	PAULALIASOLD = ALLTRIM(PLTEMPDBF) + 'OLD'
	PAULTEMP = CURDIR() + 'TEMPDBC\' + ALLTRIM(PLTEMPDBF)
	IF USED(PAULALIASOLD)
		USE IN (PAULALIASOLD)
	ENDIF
	IF USED(PAULALIAS)
		USE IN (PAULALIAS)
	ENDIF
	IF USED(PLUSEDBF)
		USE IN (PLUSEDBF)
	ENDIF
	USE IN 0 (PAULTEMP) ALIAS (PAULALIASOLD)
	USE IN (PAULALIASOLD)
	USE IN 0 EXCLUSIVE (PAULTEMP) ALIAS (PAULALIASOLD)
	SELECT (PAULALIASOLD)
	IF AT('TEMPDBC',PAULTEMP) > 0
		ZAP
	ENDIF
	USE IN 0 (PLFROMDBF) AGAIN ALIAS (PAULALIAS) ORDER (PLSEEK)
	SELECT (PAULALIAS)
	PAULSET_NEAR = SET('NEAR')
	SET NEAR ON
	SEEK PLSTART
	SET NEAR &paulSET_NEAR.
	IF EOF()
		USE IN (PAULALIAS)
		USE IN (PAULALIASOLD)
		USE IN 0 (PAULTEMP) ALIAS (PLUSEDBF)
		SELECT (PLUSEDBF)
		IF ID_VALUE <> 'ALERTEML'
			= PAULMESSAGE('Nothing to print !','WARNING')
		ENDIF
		LRPRINT = 999
		RETURN .T.
	ENDIF
	PAULRETRIVE = 1
	DO WHILE MACROS  ???FUN[CA] ('.NOT. EOF(paulALIAS) .AND. &plcondition.  ')
		IF &plcondition.
			SCATTER MEMO MEMVAR
			SELECT (PAULALIASOLD)
			INSERT INTO (PAULALIASOLD) FROM MEMVAR
			PAULRETRIVE = PAULRETRIVE + 1
		ENDIF
		SELECT (PAULALIAS)
		IF  .NOT. EOF()
			SKIP
		ENDIF
		WAIT WINDOW NOWAIT 'Scanning records : ' + ALLTRIM(STR(PAULRETRIVE - 1,7))
		IF PAULRETRIVE / PLNO_REC = INT(PAULRETRIVE / PLNO_REC)
			IF  .NOT. PAULASK_YN(ALLTRIM(STR(PAULRETRIVE - 1,7)) + ' Record(s) retrived !  Continue... ? ','WARNING')
				EXIT
			ENDIF
		ENDIF
	ENDDO
	USE IN (PAULALIAS)
	USE IN (PAULALIASOLD)
	USE IN 0 (PAULTEMP) AGAIN ALIAS (PLUSEDBF)
	SELECT (PLUSEDBF)
	IF  .NOT. EMPTY(PAULORDER)
		SET ORDER TO (PAULORDER)
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE paulCLOSEDBF
	LPARAMETER PAULDBF1 , PAULDBF2 , PAULDBF3 , PAULDBF4 , PAULDBF5 , PAULDBF6 , PLDBF7
	IF USED(PAULDBF1)
		USE IN (PAULDBF1)
	ENDIF
	IF  .NOT. EMPTY(PAULDBF2)
		IF USED(PAULDBF2)
			USE IN (PAULDBF2)
		ENDIF
	ELSE
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PAULDBF3)
		IF USED(PAULDBF3)
			USE IN (PAULDBF3)
		ENDIF
	ELSE
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PAULDBF4)
		IF USED(PAULDBF4)
			USE IN (PAULDBF4)
		ENDIF
	ELSE
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PAULDBF5)
		IF USED(PAULDBF5)
			USE IN (PAULDBF5)
		ENDIF
	ELSE
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PAULDBF6)
		IF USED(PAULDBF6)
			USE IN (PAULDBF6)
		ENDIF
	ELSE
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PAULDBF7)
		IF USED(PAULDBF7)
			USE IN (PAULDBF7)
		ENDIF
	ELSE
		RETURN
	ENDIF
	RETURN
ENDPROC
*------
PROCEDURE paulOUTOFRANGE
	LPARAMETER ANDREWFROM , ANDREWTO , ANDREWWARNING
	IF EMPTY(ANDREWFROM) AND TYPE('andrewFROM') = 'C'
		ANDREWFROM = ' '
	ENDIF
	IF EMPTY(ANDREWTO) AND TYPE('andrewTO') = 'C'
		ANDREWTO = ' '
	ENDIF
	IF ANDREWFROM > ANDREWTO
		= PAULMESSAGE(ANDREWWARNING)
		RETURN .T.
	ELSE
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE paulORDERBY
	LPARAMETER PLORDER1 , PLORDER2 , PLORDER3 , PLORDER4 , PLORDER5 , PLORDER6 , PLYN1 , PLYN2 ,  ;
		PLYN3 , PLYN4 , PLYN5 , PLYN6
	LOCAL PLCOUNT , PLVAR , PLORDER
	PLCOUNT = 1
	PLVAR = 'plyn' + ALLTRIM(STR(PLCOUNT,2,0))
	PLORDER = 'plorder' + ALLTRIM(STR(PLCOUNT,2,0))
	DO WHILE PLCOUNT <= 6
		if &plvar.=1
			RETURN &plorder.
		ENDIF
		PLCOUNT = PLCOUNT + 1
		PLVAR = 'plyn' + ALLTRIM(STR(PLCOUNT,2,0))
		PLORDER = 'plorder' + ALLTRIM(STR(PLCOUNT,2,0))
	ENDDO
	PLCOUNT = 1
	PLORDER = 'plorder' + ALLTRIM(STR(PLCOUNT,2,0))
	DO WHILE PLCOUNT <= 6
		if .not. empty(&plorder.)
			RETURN &plorder.
		ENDIF
		PLCOUNT = PLCOUNT + 1
		PLORDER = 'plorder' + ALLTRIM(STR(PLCOUNT,2,0))
	ENDDO
	RETURN
ENDPROC
*------
PROCEDURE paullrcond
	LOCAL PAULCRIT
	PAULCRIT = 'RECNO()>0'
	IF EMPTY(REPOLIST.FIRSTPROG1) AND EMPTY(REPOLIST.FIRSTPROG2) AND  ;
			EMPTY(REPOLIST.FIRSTPROG3)
		RETURN 'RECNO()>0'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.FIELD_1) AND AT('.',REPOLIST.FIELD_1) = 0
		PAULCRIT =  ;
			PAULCRIT + ' .and. ' + ALLTRIM(REPOLIST.FIELD_1) + '>= DV1_FM .AND. ' +  ;
			ALLTRIM(REPOLIST.FIELD_1) + ' <= DV1_TO'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.FIELD_2) AND AT('.',REPOLIST.FIELD_2) = 0
		PAULCRIT =  ;
			PAULCRIT + ' .and. ' + ALLTRIM(REPOLIST.FIELD_2) + '>= DV2_FM .AND. ' +  ;
			ALLTRIM(REPOLIST.FIELD_2) + ' <= DV2_TO'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.FIELD_3) AND AT('.',REPOLIST.FIELD_3) = 0
		PAULCRIT =  ;
			PAULCRIT + ' .and. ' + ALLTRIM(REPOLIST.FIELD_3) + '>= DV3_FM .AND. ' +  ;
			ALLTRIM(REPOLIST.FIELD_3) + ' <= DV3_TO'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.FIELD_4) AND AT('.',REPOLIST.FIELD_4) = 0
		PAULCRIT =  ;
			PAULCRIT + ' .and. ' + ALLTRIM(REPOLIST.FIELD_4) + '>= DV4_FM .AND. ' +  ;
			ALLTRIM(REPOLIST.FIELD_4) + ' <= DV4_TO'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.FIELD_5) AND AT('.',REPOLIST.FIELD_5) = 0
		PAULCRIT =  ;
			PAULCRIT + ' .and. ' + ALLTRIM(REPOLIST.FIELD_5) + '>= DV5_FM .AND. ' +  ;
			ALLTRIM(REPOLIST.FIELD_5) + ' <= DV5_TO'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.FIELD_6) AND AT('.',REPOLIST.FIELD_6) = 0
		PAULCRIT =  ;
			PAULCRIT + ' .and. ' + ALLTRIM(REPOLIST.FIELD_6) + '>= DV6_FM .AND. ' +  ;
			ALLTRIM(REPOLIST.FIELD_6) + ' <= DV6_TO'
	ENDIF
	IF '' = ALLTRIM(PAULCRIT)
		RETURN 'RECNO()>0'
	ELSE
		RETURN PAULCRIT
	ENDIF
ENDPROC
*------
PROCEDURE paullrorder
	LPARAMETER PLV1 , PLV2 , PLV3 , PLV4 , PLV5 , PLV6
	LOCAL PAULCRIT
	PAULCRIT = ''
	IF '' =  ;
			ALLTRIM(REPOLIST.ORDER1 + REPOLIST.ORDER2 + REPOLIST.ORDER3 + REPOLIST.ORDER4 +  ;
			REPOLIST.ORDER5 +  ;
			REPOLIST.ORDER6)
		RETURN PAULCRIT
	ENDIF
	IF PLV1 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER1)
		IF AT(',',REPOLIST.ORDER1) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER1,1,AT(',',REPOLIST.ORDER1) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF PLV2 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER2)
		IF AT(',',REPOLIST.ORDER2) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER2,1,AT(',',REPOLIST.ORDER2) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF PLV3 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER3)
		IF AT(',',REPOLIST.ORDER3) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER3,1,AT(',',REPOLIST.ORDER3) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF PLV4 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER4)
		IF AT(',',REPOLIST.ORDER4) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER4,1,AT(',',REPOLIST.ORDER4) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF PLV5 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER5)
		IF AT(',',REPOLIST.ORDER5) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER5,1,AT(',',REPOLIST.ORDER5) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF PLV6 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER6)
		IF AT(',',REPOLIST.ORDER6) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER6,1,AT(',',REPOLIST.ORDER6) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER1)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER1)
		IF AT(',',REPOLIST.ORDER1) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER1,1,AT(',',REPOLIST.ORDER1) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER2)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER2)
		IF AT(',',REPOLIST.ORDER2) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER2,1,AT(',',REPOLIST.ORDER2) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER3)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER3)
		IF AT(',',REPOLIST.ORDER3) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER3,1,AT(',',REPOLIST.ORDER3) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER4)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER4)
		IF AT(',',REPOLIST.ORDER4) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER4,1,AT(',',REPOLIST.ORDER4) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER5)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER5)
		IF AT(',',REPOLIST.ORDER5) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER5,1,AT(',',REPOLIST.ORDER5) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER6)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER6)
		IF AT(',',REPOLIST.ORDER6) > 0
			PAULCRIT = ALLTRIM(SUBSTR(REPOLIST.ORDER6,1,AT(',',REPOLIST.ORDER6) - 1))
		ENDIF
		RETURN PAULCRIT
	ENDIF
	RETURN PAULCRIT
ENDPROC
*------
PROCEDURE paullrvalue
	LPARAMETER PLV1 , PLV2 , PLV3 , PLV4 , PLV5 , PLV6
	LOCAL PAULCRIT
	PAULCRIT = ''
	IF '' =  ;
			ALLTRIM(REPOLIST.ORDER1 + REPOLIST.ORDER2 + REPOLIST.ORDER3 + REPOLIST.ORDER4 +  ;
			REPOLIST.ORDER5 +  ;
			REPOLIST.ORDER6)
		RETURN PAULCRIT
	ENDIF
	IF PLV1 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER1)
		RETURN 'DV1_FM'
	ENDIF
	IF PLV2 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER2)
		RETURN 'DV2_FM'
	ENDIF
	IF PLV3 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER3)
		RETURN 'DV3_FM'
	ENDIF
	IF PLV4 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER4)
		RETURN 'DV4_FM'
	ENDIF
	IF PLV5 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER5)
		RETURN 'DV5_FM'
	ENDIF
	IF PLV6 = 1
		PAULCRIT = ALLTRIM(REPOLIST.ORDER6)
		RETURN 'DV6_FM'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER1)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER1)
		RETURN 'DV1_FM'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER2)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER2)
		RETURN 'DV2_FM'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER3)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER3)
		RETURN 'DV3_FM'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER4)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER4)
		RETURN 'DV4_FM'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER5)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER5)
		RETURN 'DV5_FM'
	ENDIF
	IF  .NOT. EMPTY(REPOLIST.ORDER6)
		PAULCRIT = ALLTRIM(REPOLIST.ORDER6)
		RETURN 'DV6_FM'
	ENDIF
	RETURN PAULCRIT
ENDPROC
*------
PROCEDURE paulSCANTABLE
	LPARAMETER PLFROMDBF , PLTEMPDBF , PLUSEDBF , PLSEEK , PLFIELD , PLSTART , PLEND ,  ;
		PLCONDITION , PLNO_REC , PAULORDER , PAULAORB , PLZAP , PLSECURITY
	LOCAL PAULSET_NEAR , PAULSET_EXACT , PLFILTER , PAULORDER , PAULAORB , PLTEMPINDEX
	ON ERROR RETURN
	IF  .NOT. EMPTY(PLSECURITY)
		IF UPPER(PLSECURITY) = 'S' AND ID_VALUE <> 'ALERTEML' AND  ;
				.NOT. (SECURITY_ID = 'SUPER' .OR. SECURITY_ID = 'BOS' .OR. SECURITY_ID = 'ADMIN')
			PLCONDITION =  ;
				' .AND. ' +  ;
				'(SECURITY_ID=SEC_GRP .OR. SECURITY_ID2=SEC_GRP .OR. SECURITY_ID3=SEC_GRP .OR. SECURITY_ID4=SEC_GRP .OR. SECURITY_ID5=SEC_GRP)'
		ENDIF
	ENDIF
	PLFILTER = PLFIELD + ' >= ' + PLSTART + ' .AND. ' + PLFIELD + ' <= ' + PLEND
	PAULALIAS = ALLTRIM(PLFROMDBF) + 'SQL'
	PAULALIASOLD = ALLTRIM(PLTEMPDBF) + 'OLD'
	PAULTEMP = CURDIR() + 'TEMPDBC\' + ALLTRIM(PLTEMPDBF)
	PLTEMPINDEX = '_TMP' + ALLTRIM(PLFROMDBF)
	IF USED(PAULALIASOLD)
		USE IN (PAULALIASOLD)
	ENDIF
	IF USED(PAULALIAS)
		USE IN (PAULALIAS)
	ENDIF
	IF USED(PLUSEDBF)
		USE IN (PLUSEDBF)
	ENDIF
	IF EMPTY(PLTEMPDBF)
		USE IN 0 (PLFROMDBF) AGAIN ALIAS (PLUSEDBF)
		SELECT (PLUSEDBF)
		IF  .NOT. EMPTY(PAULORDER)
			IF  .NOT. EMPTY(PAULAORB)
				IF AT('+',PAULORDER) > 0
					WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
					INDEX ON &paulORDER. TO &PLTEMPINDEX. &paulAORB.
				ELSE
					SET ORDER TO &paulORDER. &paulAORB.
				ENDIF
			ELSE
				IF AT('+',PAULORDER) > 0
					WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
					INDEX ON &paulORDER. TO &PLTEMPINDEX.
				ELSE
					SET ORDER TO &paulORDER.
				ENDIF
			ENDIF
		ENDIF
		RETURN .T.
	ENDIF
	USE IN 0 (PAULTEMP) AGAIN ALIAS (PAULALIASOLD)
	USE IN (PAULALIASOLD)
	USE IN 0 EXCLUSIVE (PAULTEMP) AGAIN ALIAS (PAULALIASOLD)
	SELECT (PAULALIASOLD)
	IF AT('TEMPDBC',PAULTEMP) > 0
		IF EMPTY(PLZAP)
			ZAP
		ENDIF
	ENDIF
	USE IN 0 (PLFROMDBF) AGAIN ALIAS (PAULALIAS) ORDER (PLSEEK)
	SELECT (PAULALIAS)
	PAULSET_NEAR = SET('NEAR')
	SET NEAR ON
	GO TOP
	seek &plstart.
	SET NEAR &paulSET_NEAR.
	IF EOF()
		USE IN (PAULALIAS)
		USE IN (PAULALIASOLD)
		USE IN 0 (PAULTEMP) AGAIN ALIAS (PLUSEDBF)
		SELECT (PLUSEDBF)
		IF ID_VALUE <> 'ALERTEML'
			= PAULMESSAGE('Nothing to print !','WARNING')
		ENDIF
		LRPRINT = 999
		RETURN .T.
	ENDIF
	PAULRETRIVE = 1
	DO WHILE MACROS  ???FUN[CA] ('.NOT. EOF(paulALIAS) .AND. &plFILTER.  ')
		IF &plcondition.
			SCATTER MEMO MEMVAR
			SELECT (PAULALIASOLD)
			INSERT INTO (PAULALIASOLD) FROM MEMVAR
			PAULRETRIVE = PAULRETRIVE + 1
		ENDIF
		SELECT (PAULALIAS)
		IF  .NOT. EOF()
			SKIP
		ENDIF
		WAIT WINDOW NOWAIT 'Scanning records : ' + ALLTRIM(STR(PAULRETRIVE - 1,7))
		IF PAULRETRIVE / PLNO_REC = INT(PAULRETRIVE / PLNO_REC)
			IF  .NOT. PAULASK_YN(ALLTRIM(STR(PAULRETRIVE - 1,7)) + ' Record(s) retrived !  Continue... ? ','WARNING')
				EXIT
			ENDIF
		ENDIF
	ENDDO
	USE IN (PAULALIAS)
	USE IN (PAULALIASOLD)
	USE IN 0 (PAULTEMP) AGAIN ALIAS (PLUSEDBF)
	SELECT (PLUSEDBF)
	IF  .NOT. EMPTY(PAULORDER)
		IF  .NOT. EMPTY(PAULAORB)
			IF AT('+',PAULORDER) > 0
				WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
				INDEX ON &paulORDER. TO &PLTEMPINDEX. &paulAORB.
			ELSE
				SET ORDER TO &paulORDER. &paulAORB.
			ENDIF
		ELSE
			IF AT('+',PAULORDER) > 0
				WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
				INDEX ON &paulORDER. TO &PLTEMPINDEX.
			ELSE
				SET ORDER TO &paulORDER.
			ENDIF
		ENDIF
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE paulCLOSETABLE
	LPARAMETER PAULDBF1 , PAULDBF2 , PAULDBF3 , PAULDBF4
	IF USED(PAULDBF1)
		USE IN (PAULDBF1)
	ENDIF
	IF  .NOT. EMPTY(PAULDBF2)
		IF USED(PAULDBF2)
			USE IN (PAULDBF2)
		ENDIF
	ELSE
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PAULDBF3)
		IF USED(PAULDBF3)
			USE IN (PAULDBF3)
		ENDIF
	ELSE
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PAULDBF4)
		IF USED(PAULDBF4)
			USE IN (PAULDBF4)
		ENDIF
	ELSE
		RETURN
	ENDIF
	RETURN
ENDPROC
*------
PROCEDURE paulCHANGECCY
	LPARAMETER PLDBF1 , PLDBF2 , PLSEEK , PLKEY , PLID , PLCCY , PLEXCH , PLVALUE1 , PLVALUE2 ,  ;
		PLCONDITION , PLRATETYPE , PLREP11 , PLWITH11 , PLREP12 , PLWITH12 ,  ;
		PLREADONLY , PLOPEN
	LOCAL APPQRY2 , PLPRICE1 , PLPRICE2 , PLYN , PLCONDITION , PLREP11 , PLWITH11 ,  ;
		PLREP12 , PLWITH12 , PLRATETYPE
	PL_YN = .F.
	IF EOF(PLDBF1)
		RETURN .F.
	ENDIF
	IF EMPTY(PLCONDITION)
		PLCONDITION = '.T.'
	ENDIF
	IF EMPTY(PLOPEN)
		PLOPEN = 'N'
	ELSE
		PLOPEN = UPPER(PLOPEN)
	ENDIF
	APPEND_YN = .F.
	TQUANTITY = 0
	ID_VALUE2 = ''
	APPQRY2 = CREATEOBJECT('CCY_EXCHAN')
	APPQRY2.TXTCCY.VALUE=&plccy.
	IF  .NOT. EMPTY(PLREADONLY) AND UPPER(PLREADONLY) = 'READONLY'
		APPQRY2.TXTRATE.READONLY = .T.
	ENDIF
	APPQRY2.TXTRATE.VALUE=&plexch.
	IF  .NOT. EMPTY(PLRATETYPE)
		APPQRY2.RATETYPE = PLRATETYPE
	ENDIF
	APPQRY2.SHOW()
	VORGINALCCY = 'HKD'
	VORGINALEXCH = 1
	IF APPEND_YN
		IF paulASK_YN('Change currency from '+&plccy.+' to '+id_value2+'  Exchange Rate: ['+alltrim(str(tquantity,12,6))+' ]','WARNING')
			SELECT (PLDBF1)
			vorginalccy=&plccy.
			vorginalexch=&plexch.
			REPLACE &plexch. with tquantity
			if id_value2<>&plccy.
				REPLACE &plccy. with id_value2
			ENDIF
			= TABLEUPDATE(.T.)
		ELSE
			SELECT (PLDBF1)
			RETURN .T.
		ENDIF
	ENDIF
	IF APPEND_YN
		VPLDBFOPEN = .F.
		PAULEXCHDBF = 'PAULEXCHDBF'
		IF ( .NOT. EMPTY(PLREP12) .OR.  .NOT. EMPTY(PLREP11) .OR.  .NOT. EMPTY(PLVALUE1) .OR.  ;
				.NOT. EMPTY(PLVALUE2)) AND TQUANTITY <> 0
			IF PAULASK_YN('Do you want to recalculate with ' + VORGINALCCY + ' to ' + ID_VALUE2 +  ;
					'  Exchange Rate: [' +  ;
					ALLTRIM(STR(TQUANTITY,12,6)) +  ;
					' ]','WARNING')
				IF PLOPEN = 'Y'
					PAULEXCHDBF = PLDBF2
					VPLDBFOPEN = .T.
					SELECT (PAULEXCHDBF)
					VPLDBFORDER = ORDER()
					SET ORDER TO &plseek.
				ELSE
					VPLDBFOPEN = .F.
					PAULEXCHDBF = 'PAULEXCHDBF'
					use &pldbf2. alias PAULEXCHDBF order &plseek. AGAIN IN 0
				ENDIF
				SELECT (PAULEXCHDBF)
				GO TOP
				SEEK PLID
				IF FOUND()
					PL_YN = .T.
					DO WHILE MACROS  ???FUN[CA] ('plid=&plkey. .AND. .NOT. EOF()')
						IF &plkey. ==plid .AND. &plcondition.
							IF  .NOT. EMPTY(PLVALUE1)
								REPLACE &plvalue1. with &plvalue1. * vorginalexch /tquantity
								plprice1=&plvalue1.
								plprice2=&plvalue1. * vorginalexch /tquantity
								WAIT WINDOW &plkey.+ str(plprice1,10,2)+' - > '+str(plprice2,10,2) NOWAIT
							ENDIF
							IF  .NOT. EMPTY(PLVALUE2)
								REPLACE &plvalue2. with &plvalue2. * vorginalexch /tquantity
							ENDIF
							IF  .NOT. EMPTY(PLREP11)
								REPLACE &plrep11. with &plwith11.
							ENDIF
							IF  .NOT. EMPTY(PLREP12)
								REPLACE &plrep12. with &plwith12.
							ENDIF
						ENDIF
						SKIP
					ENDDO
				ENDIF
				IF  .NOT. VPLDBFOPEN
					USE IN (PAULEXCHDBF)
				ELSE
					SELECT (PAULEXCHDBF)
					SET ORDER TO &VPLDBFORDER.
				ENDIF
			ENDIF
			SELECT (PLDBF1)
			= TABLEUPDATE(.T.)
		ENDIF
	ENDIF
	SELECT (PLDBF1)
	RETURN PL_YN
ENDPROC
*------
PROCEDURE paulCREATORINF
	LPARAMETER PLCREATOR
	IF EOF()
		RETURN
	ENDIF
	WAIT WINDOW 'Creator  : '+&plcreator.
	RETURN
ENDPROC
*------
PROCEDURE paulACTREPWIN
	IF WEXIST('Report Designer')
		ACTIVATE WINDOW 'Report Designer'
	ENDIF
ENDPROC
*------
PROCEDURE paulREORDERING
	LPARAMETER JKDBF , JKSEEK , JKVALUE
	SELECT (JKDBF)
	IF JKVALUE = 0
		SET ORDER TO &jkseek. ASCENDING
	ELSE
		SET ORDER TO &jkseek. DESCENDING
	ENDIF
	RETURN
ENDPROC
*------
PROCEDURE paulREPAIR
	LPARAMETER PLDBF
	LOCAL PLREPAIR_WK , PLRECNO , PLORDER
	ON ERROR return
	PLREPAIR_WK = SELECT()
	SELECT (PLDBF)
	PLRECNO = RECNO()
	PLORDER = ORDER()
	SEEK ORDER CLICK .F.
	IF  .NOT. FOUND()
		IF PLRECNO <= RECCOUNT() AND PLRECNO <> 0
			GO PLRECNO
		ENDIF
		SELECT (PLREPAIR_WK)
		RETURN .F.
	ENDIF
	SET ORDER TO CLICK
	SEEK .F.
	IF FOUND()
		WAIT WINDOW NOWAIT 'Repair data ... Please wait ! '
		DO WHILE  .NOT. EOF() AND  .NOT. CLICK
			REPLACE CLICK WITH .T.
			SKIP
		ENDDO
	ENDIF
	IF PLRECNO <= RECCOUNT() AND PLRECNO <> 0
		GO PLRECNO
	ENDIF
	SET ORDER TO (PLORDER)
	SELECT (PLREPAIR_WK)
	RETURN .T.
ENDPROC
*------
PROCEDURE paulISEMPTY
	LPARAMETER JKNO , JKWORD
	IF EMPTY(JKNO)
		= PAULMESSAGE(ALLTRIM(JKWORD) + ' cannot be empty !')
		RETURN .T.
	ELSE
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE PAULACCESS
	LPARAMETER TCSCREEN_KEY , TCSECURITY_ID , TSDBF , TSKEY , TSACCESS
	LOCAL JKACCESS
	IF TRADE_MARK
		RETURN .T.
	ENDIF
	JKACCESS = .F.
	SELECT_WKKK = SELECT()
	IF  .NOT. USED(TSDBF)
		USE &tsdbf. ORDER &tskey. IN 0
	ENDIF
	SELECT (TSDBF)
	SEEK UPPER(tcsecurity_id+tcSCREEN_KEY) ORDER &tskey.
	IF FOUND()
		jkaccess=&tsaccess.
	ENDIF
	IF TRADE_MARK .OR. FOUND()
		SELECT (SELECT_WKKK)
		RETURN JKACCESS
	ELSE
		SELECT (SELECT_WKKK)
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE CDEAN_13
	LPARAMETER PAULBARCODE_VALUE , PAULWARNING , PAULTEXT6 , PAULTEXT7 , PAULTEXT5 ,  ;
		PAULMESSAGE4 , PAULMESSAGE3
	LOCAL BARCODE_VALUE , SELECT_UPCA
	SELECT_UPCA = SELECT()
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	BN1 = SUBSTR(BARCODE_VALUE,1,1)
	BN2 = SUBSTR(BARCODE_VALUE,2,1)
	BN3 = SUBSTR(BARCODE_VALUE,3,1)
	BN4 = SUBSTR(BARCODE_VALUE,4,1)
	BN5 = SUBSTR(BARCODE_VALUE,5,1)
	BN6 = SUBSTR(BARCODE_VALUE,6,1)
	BN7 = SUBSTR(BARCODE_VALUE,7,1)
	BN8 = SUBSTR(BARCODE_VALUE,8,1)
	BN9 = SUBSTR(BARCODE_VALUE,9,1)
	BN10 = SUBSTR(BARCODE_VALUE,10,1)
	BN11 = SUBSTR(BARCODE_VALUE,11,1)
	BN12 = SUBSTR(BARCODE_VALUE,12,1)
	BN13 = SUBSTR(BARCODE_VALUE,13,1)
	BC1 = VAL(BN2) + VAL(BN4) + VAL(BN6) + VAL(BN8) + VAL(BN10) + VAL(BN12)
	BC1 = BC1 * 3
	BC2 = VAL(BN1) + VAL(BN3) + VAL(BN5) + VAL(BN7) + VAL(BN9) + VAL(BN11)
	BC3 = 10 - ((BC1 + BC2) / 10 - INT((BC1 + BC2) / 10)) * 10
	IF BC3 = 10
		BC3 = 0
	ENDIF
	SELECT (SELECT_UPCA)
	RETURN ALLTRIM(STR(BC3,3,0))
ENDPROC
*------
PROCEDURE paulPOS
	LPARAMETER PAULSTRING
	LOCAL PAULCHA , PAULLEN
	PAULCHA = ALLTRIM(PAULSTRING)
	IF LEN(PAULCHA) = 0
		RETURN 0
	ENDIF
	PAULLEN = 1
	DO WHILE PAULLEN <= LEN(PAULCHA)
		IF ASC(SUBSTR(PAULCHA,PAULLEN,1)) >= 48 AND ASC(SUBSTR(PAULCHA,PAULLEN,1)) <= 57
			EXIT
		ENDIF
		PAULLEN = PAULLEN + 1
	ENDDO
	IF PAULLEN = LEN(PAULCHA) + 1
		RETURN 0
	ENDIF
	RETURN VAL(SUBSTR(PAULCHA,PAULLEN))
ENDPROC
*------
PROCEDURE paulCHANGENO
	LPARAMETER PAULDBF1 , PAULDBF2 , PAULDOC_NO , PAULINDEX , PAULNO
	LOCAL APPQRY6
	APPEND_YN = .F.
	KEY_VALUE1 = SPACE(20)
	KEY_VALUE2 = SPACE(20)
	KEY_VALUE3 = SPACE(20)
	SELECT (PAULDBF1)
	SET_DEL = SET('DELETED')
	SET_EXACT = SET('EXACT')
	SET_NEAR = SET('NEAR')
	APPQRY6 = CREATEOBJECT('GET_INFO')
	APPQRY6.CAPTION = 'New ' + PAULNO
	APPQRY6.KEYNAME2.CAPTION = PAULNO
	APPQRY6.KEYNAME2.VISIBLE = .T.
	APPQRY6.KEY2.VISIBLE = .T.
	APPQRY6.SHOW()
	IF APPEND_YN AND  .NOT. EMPTY(KEY_VALUE2)
		SELECT (PAULDBF2)
		SET EXACT ON
		SEEK ORDER (PAULINDEX) UPPER(ALLTRIM(KEY_VALUE2))
		IF FOUND()
			SELECT (PAULDBF1)
			replace &pauldoc_no. with UPPER(ALLTRIM(KEY_VALUE2))
		ELSE
			= PAULMESSAGE(ALLTRIM(PAULNO) + ' Not Found !')
		ENDIF
	ENDIF
	SET EXACT OFF
	SET DELETED &SET_DEL.
	SET EXACT &SET_EXACT.
	SET NEAR &SET_NEAR.
	SELECT (PAULDBF1)
	= TABLEUPDATE(.T.)
	RELEASE APPQRY6
ENDPROC
*------
PROCEDURE paulOUTDATA
	LPARAMETER PLSOURCE , PLPATH , PLINDEX , PLFIELD , PLDATE , PLDATE2
	LOCAL PAULSAFETY1 , PAULEXACT , PAULNEAR
	PAULSAFETY1 = SET('SAFETY')
	PAULEXACT = SET('EXACT')
	PAULNEAR = SET('NEAR')
	SET EXACT OFF
	SET NEAR ON
	SET SAFETY OFF
	SET DELETED OFF
	IF USED(PLPATH)
		USE in &plpath.
	ENDIF
	IF USED('plSOURCEDBF')
		USE IN PLSOURCEDBF
	ENDIF
	IF USED('edi_temp')
		USE IN EDI_TEMP
	ENDIF
	USE &plSOURCE. alias plSOURCEDBF in 0 AGAIN
	SELECT PLSOURCEDBF
	set order to &plindex.
	GO TOP
	SEEK PLDATE
	COPY TO &plpath. while &plfield.>=pldate .and. &plfield.<=pldate2
	IF FILE(PLPATH)
		USE &plpath. in 0 alias edi_temp
		SELECT EDI_TEMP
		WAIT WINDOW NOWAIT 'No. of record copied : ' + STR(RECCOUNT(),8)
		USE IN EDI_TEMP
	ENDIF
	SET SAFETY &paulsafety1.
	SET EXACT &paulEXACT.
	SET NEAR  &paulNEAR.
	IF USED('plSOURCEDBF')
		USE IN PLSOURCEDBF
	ENDIF
	SET EXACT OFF
	SET DELETED ON
	RETURN
ENDPROC
*------
PROCEDURE paulINITDATABASE
	SET TALK OFF
	SET EXACT OFF
	SET DELETED ON
	SET SAFETY OFF
	LOCAL PAULSELECTWK
	PAULSELECTWK = SELECT()
	IF  .NOT. USED('paramete_INIT')
		USE IN 0 PARAMETE AGAIN ALIAS PARAMETE_INIT
	ENDIF
	SELECT PARAMETE_INIT
	LOCATE FOR PARAMETE_INIT.COMPANYID = 'PNJ'
	DATE_TYPE = PARAMETE_INIT.DATETYPE
	SET DATE TO &DATE_TYPE.
	DATE_TYPE = PARAMETE_INIT.CENTURYON
	set century &date_type.
	SET DECIMALS TO PARAMETE_INIT.DECIALPLAC
	USE IN PARAMETE_INIT
	SELECT (PAULSELECTWK)
	RETURN 'OK'
ENDPROC
*------
PROCEDURE paulINDATA
	LPARAMETER PAULINDEX , PAULKEY , PAULOLDDBF , PAULNEWDBF , PLEX1 , PLEX2 , PLEX3 , PLEX4 ,  ;
		PLEX5
	SET EXACT ON
	IF USED('paulOLD')
		USE IN PAULOLD
	ENDIF
	IF USED('paulNEW')
		USE IN PAULNEW
	ENDIF
	PAULKEY_VALUE = ''
	PAULINCONDITION = ''
	CONTINUE_YN = 0
	PAULDELETED = .F.
	SET DELETED OFF
	IF  .NOT. EMPTY(PLEX1) AND  ;
			(AT('<',PLEX1) > 0 .OR. AT('>',PLEX1) > 0 .OR. AT('=',PLEX1) > 0)
		PAULINCONDITION = PLEX1
		PLEX1 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX2) AND  ;
			(AT('<',PLEX2) > 0 .OR. AT('>',PLEX2) > 0 .OR. AT('=',PLEX2) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX2
		PLEX2 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX3) AND  ;
			(AT('<',PLEX3) > 0 .OR. AT('>',PLEX3) > 0 .OR. AT('=',PLEX3) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX3
		PLEX3 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX4) AND  ;
			(AT('<',PLEX4) > 0 .OR. AT('>',PLEX4) > 0 .OR. AT('=',PLEX4) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX4
		PLEX4 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX5) AND  ;
			(AT('<',PLEX5) > 0 .OR. AT('>',PLEX5) > 0 .OR. AT('=',PLEX5) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX5
		PLEX5 = ''
	ENDIF
	use &paulOLDDBF. order &paulindex. in 0 alias paulOLD again
	= CURSORSETPROP('Buffering',3,'PAULOLD')
	PAUL_JPSO = PAULNEWDBF
	IF  .NOT. FILE(PAUL_JPSO)
		WAIT WINDOW TIMEOUT 5 PAUL_JPSO + ' NOT FOUND !'
		USE IN PAULOLD
		SET EXACT OFF
		SET DELETED ON
		RETURN
	ENDIF
	use &paul_jpso. alias paulNew in 0
	SELECT PAULNEW
	IF  .NOT. EMPTY(PAULINCONDITION)
		GO TOP
		set filter to &paulincondition.
	ENDIF
	GO TOP
	IF EOF()
		USE IN PAULNEW
		USE IN PAULOLD
		WAIT WINDOW NOWAIT 'Update completed !'
		LRPRINT = 999
		SET EXACT OFF
		SET DELETED ON
		RETURN
	ENDIF
	LOCAL PAULFIELD , PAULFIELD_VALUE , PAULOLD , PAULNEW
	SELECT PAULNEW
	paulKEY_VALUE=&paulKEY.
	PAULDELETED = DELETED()
	DO WHILE  .NOT. EOF('paulNew')
		SELECT PAULOLD
		GO TOP
		SEEK PAULKEY_VALUE
		IF FOUND('PAULOLD')
			CONTINUE_YN = 1
			IF PAULDELETED
				DELETE
			ELSE
				IF DELETED('PAULOLD') AND PAULNEW.ADATETIME > PAULOLD.ADATETIME
					RECALL
				ENDIF
			ENDIF
		ELSE
			CONTINUE_YN = 0
			SELECT PAULOLD
			APPEND BLANK
			IF PAULDELETED
				DELETE
			ENDIF
		ENDIF
		FOR GNCOUNT = 1 TO FCOUNT()
			PAULFIELD = FIELD(GNCOUNT)
			IF TYPE(FIELD(GNCOUNT)) = 'C'
				paulFIELD_VALUE=FIELD(gnCount)+&paulFIELD.
			ELSE
				PAULFIELD_VALUE = FIELD(GNCOUNT)
			ENDIF
			FPAULOLD = 'paulOLD.' + ALLTRIM(PAULFIELD)
			FPAULNEW = 'paulNEW.' + LEFT(ALLTRIM(PAULFIELD),10)
			IF UPPER(ALLTRIM(PAULFIELD)) = 'COMPANY_NAME2'
				FPAULOLD = 'paulOLD.COMPANY_NAME2'
				FPAULNEW = 'paulNEW.COMPANY_N2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2'
				FPAULOLD = 'paulOLD.UNIT_PRICE2'
				FPAULNEW = 'paulNEW.UNIT_PRIC2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3'
				FPAULOLD = 'paulOLD.UNIT_PRICE3'
				FPAULNEW = 'paulNEW.UNIT_PRIC3'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE8'
				FPAULOLD = 'paulOLD.UNIT_PRICE8'
				FPAULNEW = 'paulNEW.UNIT_PRIC4'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2'
				FPAULOLD = 'paulOLD.PRICE_UNIT2'
				FPAULNEW = 'paulNEW.PRICE_UNI2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
				FPAULOLD = 'paulOLD.PRICE_UNIT3'
				FPAULNEW = 'paulNEW.PRICE_UNI3'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM2'
				FPAULOLD = 'paulOLD.PRICE_TERM2'
				FPAULNEW = 'paulNEW.PRICE_TER2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM3'
				FPAULOLD = 'paulOLD.PRICE_TERM3'
				FPAULNEW = 'paulNEW.PRICE_TER3'
			ENDIF
			PAULSELECT = .T.
			IF PAULOLDDBF = 'INVMAST' .OR. PAULOLDDBF = 'SDNMAST'
				IF PAULFIELD = 'AR' .OR. PAULFIELD = 'AP' .OR. PAULFIELD = 'A_R_CODE' .OR.  ;
						PAULFIELD = 'A_P_CODE'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF TYPE(FPAULNEW) = 'U' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'ADATETIME'
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX1) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX1))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX2) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX2))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX3) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX3))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX4) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX4))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX5) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX5))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX1) AND UPPER(ALLTRIM(PLEX1)) = 'STOCK'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'OPEN_STOCK' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'STOCK_IN' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'STOCK_OUT' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'INQTY' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'OUTQTY' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'LASTQTY'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX2) AND UPPER(ALLTRIM(PLEX2)) = 'COST'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'STD_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'AVG_COST' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'ACT_COST' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'AVGM_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'MKT_COST'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX3) AND UPPER(ALLTRIM(PLEX3)) = 'BUYING'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST3' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT3'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX4) AND UPPER(ALLTRIM(PLEX4)) = 'SELLING'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			if vartype(&paulFIELD.)="N"
				if left(transform(&paulFIELD.),2)="**"
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF CONTINUE_YN = 1 AND PAULNEW.ADATETIME > PAULOLD.ADATETIME AND PAULSELECT
				REPLACE &FpaulOLD. WITH &FpaulNEW.
			ELSE
				IF CONTINUE_YN = 1 AND PAULNEW.ADATETIME = PAULOLD.ADATETIME AND PAULSELECT
					IF TYPE(FpaulOLD)="M" .AND. EMPTY(&FpaulOLD.) .AND. !EMPTY(&FpaulNEW.)
						REPLACE &FpaulOLD. WITH &FpaulNEW.
					ENDIF
				ENDIF
			ENDIF
			IF CONTINUE_YN = 0 AND PAULSELECT
				REPLACE &FpaulOLD. WITH &FpaulNEW.
			ENDIF
			WAIT WINDOW NOWAIT PAULFIELD_VALUE
		ENDFOR
		IF PAULSELECT
			FPAULOLD = 'paulOLD.ADATETIME'
			FPAULNEW = 'paulNEW.ADATETIME'
			REPLACE &FpaulOLD. WITH &FpaulNEW.
		ENDIF
		SELECT PAULNEW
		SKIP
		PAULDELETED = DELETED()
		paulKEY_VALUE=&paulKEY.
	ENDDO
	SELECT PAULOLD
	= TABLEUPDATE(.T.)
	USE IN PAULNEW
	USE IN PAULOLD
	SET EXACT OFF
	SET DELETED ON
	RETURN
ENDPROC
*------
PROCEDURE paulINDATA2
	LPARAMETER PAULINDEX , PAULKEY , PAULOLDDBF , PAULNEWDBF , PLEX1 , PLEX2 , PLEX3 , PLEX4 ,  ;
		PLEX5 , PAULOLDPEN
	SET EXACT ON
	IF USED('paulOLD')
		USE IN PAULOLD
	ENDIF
	IF USED('paulNEW')
		USE IN PAULNEW
	ENDIF
	PAULKEY_VALUE = ''
	PAULINCONDITION = ''
	CONTINUE_YN = 0
	PAULDELETED = .F.
	SET DELETED OFF
	IF  .NOT. EMPTY(PLEX1) AND  ;
			(AT('<',PLEX1) > 0 .OR. AT('>',PLEX1) > 0 .OR. AT('=',PLEX1) > 0)
		PAULINCONDITION = PLEX1
		PLEX1 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX2) AND  ;
			(AT('<',PLEX2) > 0 .OR. AT('>',PLEX2) > 0 .OR. AT('=',PLEX2) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX2
		PLEX2 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX3) AND  ;
			(AT('<',PLEX3) > 0 .OR. AT('>',PLEX3) > 0 .OR. AT('=',PLEX3) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX3
		PLEX3 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX4) AND  ;
			(AT('<',PLEX4) > 0 .OR. AT('>',PLEX4) > 0 .OR. AT('=',PLEX4) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX4
		PLEX4 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX5) AND  ;
			(AT('<',PLEX5) > 0 .OR. AT('>',PLEX5) > 0 .OR. AT('=',PLEX5) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX5
		PLEX5 = ''
	ENDIF
	PAULOLD = 'paulOLD'
	IF  .NOT. USED(PAULOLDDBF)
		use &paulOLDDBF. order &paulindex. in 0 alias paulOLD again
	ELSE
		IF  .NOT. EMPTY(PAULOLDPEN)
			PAULOLD = PAULOLDDBF
		ELSE
			use &paulOLDDBF. order &paulindex. in 0 alias paulOLD again
		ENDIF
	ENDIF
	= CURSORSETPROP('Buffering',3,PAULOLD)
	PAUL_JPSO = PAULNEWDBF
	IF  .NOT. FILE(PAUL_JPSO)
		WAIT WINDOW TIMEOUT 5 PAUL_JPSO + ' NOT FOUND !'
		IF EMPTY(PAULOLDPEN)
			IF USED('PAULOLD')
				USE IN PAULOLD
			ENDIF
			IF USED(PAULOLD)
				USE IN (PAULOLD)
			ENDIF
		ENDIF
		SET EXACT OFF
		SET DELETED ON
		RETURN
	ENDIF
	use &paul_jpso. alias paulNew in 0
	SELECT PAULNEW
	IF  .NOT. EMPTY(PAULINCONDITION)
		GO TOP
		set filter to &paulincondition.
	ENDIF
	GO TOP
	IF EOF()
		USE IN PAULNEW
		IF EMPTY(PAULOLDPEN)
			IF USED('PAULOLD')
				USE IN PAULOLD
			ENDIF
			IF USED(PAULOLD)
				USE IN (PAULOLD)
			ENDIF
		ENDIF
		WAIT WINDOW NOWAIT 'Update completed !'
		LRPRINT = 999
		SET EXACT OFF
		SET DELETED ON
		RETURN
	ENDIF
	LOCAL PAULFIELD , PAULFIELD_VALUE
	SELECT PAULNEW
	paulKEY_VALUE=&paulKEY.
	PAULDELETED = DELETED()
	DO WHILE  .NOT. EOF('paulNew')
		SELECT (PAULOLD)
		GO TOP
		SEEK PAULKEY_VALUE
		IF FOUND(PAULOLD)
			CONTINUE_YN = 1
			IF PAULDELETED
				DELETE
			ELSE
				IF DELETED(PAULOLD) .AND. paulNEW.adatetime >&paulold..adatetime
					RECALL
				ENDIF
			ENDIF
		ELSE
			CONTINUE_YN = 0
			SELECT (PAULOLD)
			APPEND BLANK
			IF PAULDELETED
				DELETE
			ENDIF
		ENDIF
		FOR GNCOUNT = 1 TO FCOUNT()
			PAULFIELD = FIELD(GNCOUNT)
			IF TYPE(FIELD(GNCOUNT)) = 'C'
				paulFIELD_VALUE=FIELD(gnCount)+&paulFIELD.
			ELSE
				PAULFIELD_VALUE = FIELD(GNCOUNT)
			ENDIF
			FPAULOLD = PAULOLD + '.' + ALLTRIM(PAULFIELD)
			FPAULNEW = 'paulNEW.' + LEFT(ALLTRIM(PAULFIELD),10)
			IF UPPER(ALLTRIM(PAULFIELD)) = 'COMPANY_NAME2'
				FPAULOLD = PAULOLD + '.COMPANY_NAME2'
				FPAULNEW = 'paulNEW.COMPANY_N2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2'
				FPAULOLD = PAULOLD + '.UNIT_PRICE2'
				FPAULNEW = 'paulNEW.UNIT_PRIC2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3'
				FPAULOLD = PAULOLD + '.UNIT_PRICE3'
				FPAULNEW = 'paulNEW.UNIT_PRIC3'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE8'
				FPAULOLD = PAULOLD + '.UNIT_PRICE8'
				FPAULNEW = 'paulNEW.UNIT_PRIC4'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2'
				FPAULOLD = PAULOLD + '.PRICE_UNIT2'
				FPAULNEW = 'paulNEW.PRICE_UNI2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
				FPAULOLD = PAULOLD + '.PRICE_UNIT3'
				FPAULNEW = 'paulNEW.PRICE_UNI3'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM2'
				FPAULOLD = PAULOLD + '.PRICE_TERM2'
				FPAULNEW = 'paulNEW.PRICE_TER2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM3'
				FPAULOLD = PAULOLD + '.PRICE_TERM3'
				FPAULNEW = 'paulNEW.PRICE_TER3'
			ENDIF
			PAULSELECT = .T.
			IF PAULOLDDBF = 'INVMAST' .OR. PAULOLDDBF = 'SDNMAST'
				IF PAULFIELD = 'AR' .OR. PAULFIELD = 'AP' .OR. PAULFIELD = 'A_R_CODE' .OR.  ;
						PAULFIELD = 'A_P_CODE'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF TYPE(FPAULNEW) = 'U' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'ADATETIME'
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX1) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX1))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX2) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX2))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX3) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX3))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX4) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX4))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX5) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX5))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX1) AND UPPER(ALLTRIM(PLEX1)) = 'STOCK'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'OPEN_STOCK' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'STOCK_IN' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'STOCK_OUT' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'INQTY' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'OUTQTY' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'LASTQTY'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX2) AND UPPER(ALLTRIM(PLEX2)) = 'COST'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'STD_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'AVG_COST' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'ACT_COST' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'AVGM_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'MKT_COST'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX3) AND UPPER(ALLTRIM(PLEX3)) = 'BUYING'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST3' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT3'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX4) AND UPPER(ALLTRIM(PLEX4)) = 'SELLING'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			if vartype(&paulFIELD.)="N"
				if left(transform(&paulFIELD.),2)="**"
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF CONTINUE_YN=1 .and. paulNEW.adatetime >&paulold..adatetime .AND. paulselect
				REPLACE &FpaulOLD. WITH &FpaulNEW.
			ELSE
				IF CONTINUE_YN=1 .and. paulNEW.adatetime = &paulold..adatetime .AND. paulselect
					IF TYPE(FpaulOLD)="M" .AND. EMPTY(&FpaulOLD.) .AND. !EMPTY(&FpaulNEW.)
						REPLACE &FpaulOLD. WITH &FpaulNEW.
					ENDIF
				ENDIF
			ENDIF
			IF CONTINUE_YN = 0 AND PAULSELECT
				REPLACE &FpaulOLD. WITH &FpaulNEW.
			ENDIF
			WAIT WINDOW NOWAIT PAULFIELD_VALUE
		ENDFOR
		IF PAULSELECT
			FPAULOLD = PAULOLD + '.ADATETIME'
			FPAULNEW = 'paulNEW.ADATETIME'
			REPLACE &FpaulOLD. WITH &FpaulNEW.
		ENDIF
		SELECT PAULNEW
		SKIP
		PAULDELETED = DELETED()
		paulKEY_VALUE=&paulKEY.
	ENDDO
	SELECT (PAULOLD)
	= TABLEUPDATE(.T.)
	USE IN PAULNEW
	IF EMPTY(PAULOLDPEN)
		IF USED('paulOLD')
			USE IN PAULOLD
		ENDIF
		IF USED('paulNEW')
			USE IN PAULNEW
		ENDIF
	ENDIF
	SET EXACT OFF
	SET DELETED ON
	RETURN
ENDPROC
*------
PROCEDURE paulQTY_PRICE
	LPARAMETER JK_PICT , JK_SIDE , JKQTY1 , JKUNIT1 , JKQTY2 , JKUNIT2 , JKQTY3 , JKUNIT3 ,  ;
		JKQTY4 , JKUNIT4 , JKQTY5 , JKUNIT5
	LOCAL PAULSTRING , JKQTY1 , JKUNIT1 , JKQTY2 , JKUNIT2 , JKQTY3 , JKUNIT3 , JKQTY4 ,  ;
		JKUNIT4 , JKQTY5 , JKUNIT5 , JACKYUSED
	PAULSTRING = ''
	JACKYUSED = .T.
	IF JKQTY1 <> 0
		PAULSTRING = ALLTRIM(TRANSFORM(JKQTY1,JK_PICT)) + ' ' + JKUNIT1
	ENDIF
	IF JKQTY1 <> 0 AND (JKQTY2 <> 0 .OR. JKQTY3 <> 0 .OR. JKQTY4 <> 0 .OR. JKQTY5 <> 0)
		PAULSTRING = PAULSTRING + CHR(13)
		JACKYUSED = .F.
	ENDIF
	IF JKQTY2 <> 0
		PAULSTRING = PAULSTRING + ALLTRIM(TRANSFORM(JKQTY2,JK_PICT)) + ' ' + JKUNIT2
		JACKYUSED = .T.
	ENDIF
	IF JKQTY1 = 0 AND JKQTY2 = 0
		PAULSTRING = ''
	ELSE
		IF (JKQTY3 <> 0 .OR. JKQTY4 <> 0 .OR. JKQTY5 <> 0) AND JACKYUSED
			PAULSTRING = PAULSTRING + CHR(13)
			JACKYUSED = .F.
		ENDIF
	ENDIF
	IF JKQTY3 <> 0
		PAULSTRING = PAULSTRING + ALLTRIM(TRANSFORM(JKQTY3,JK_PICT)) + ' ' + JKUNIT3
		JACKYUSED = .T.
	ENDIF
	IF JKQTY1 = 0 AND JKQTY2 = 0 AND JKQTY3 = 0
		PAULSTRING = ''
	ELSE
		IF (JKQTY4 <> 0 .OR. JKQTY5 <> 0) AND JACKYUSED
			PAULSTRING = PAULSTRING + CHR(13)
			JACKYUSED = .F.
		ENDIF
	ENDIF
	IF JKQTY4 <> 0
		PAULSTRING = PAULSTRING + ALLTRIM(TRANSFORM(JKQTY4,JK_PICT)) + ' ' + JKUNIT4
		JACKYUSED = .T.
	ENDIF
	IF JKQTY1 = 0 AND JKQTY2 = 0 AND JKQTY3 = 0 AND JKQTY4 = 0
		PAULSTRING = ''
	ELSE
		IF JKQTY5 <> 0 AND JACKYUSED
			PAULSTRING = PAULSTRING + CHR(13)
			JACKYUSED = .F.
		ENDIF
	ENDIF
	IF JKQTY5 <> 0
		PAULSTRING = PAULSTRING + ALLTRIM(TRANSFORM(JKQTY5,JK_PICT)) + ' ' + JKUNIT5
	ENDIF
	RETURN PAULSTRING
ENDPROC
*------
PROCEDURE plPSUM
	LPARAMETER PLFIELD , PLPERIOD , PLMAX , PLPLUS , PLEXTRA1 , PLEXTRA2 , PLEXTRA3 , PLEXTRA4 ,  ;
		PLPERIODFM
	LOCAL PLSUM , PLCOUNT
	PLCOUNT = 1
	PLSUM = 0
	IF  .NOT. EMPTY(PLPERIODFM)
		plcount=&plperiodfm.
		IF PLCOUNT > PLPERIOD
			RETURN
		ENDIF
	ENDIF
	IF PLMAX < PLPERIOD AND  .NOT. EMPTY(PLPLUS)
		plsum=&plplus.
		RETURN PLSUM
	ENDIF
	IF  .NOT. EMPTY(PLFIELD) AND PLPERIOD <= 24 AND PLPERIOD >= 1
		DO WHILE PLCOUNT <= PLPERIOD
			PLV1 = ALLTRIM(PLFIELD) + ALLTRIM(STR(PLCOUNT,2))
			plsum=plsum+&plv1.
			PLCOUNT = PLCOUNT + 1
		ENDDO
	ENDIF
	IF  .NOT. EMPTY(PLEXTRA1) AND  .NOT. EMPTY(PLPERIODFM)
		if  &plperiodfm.=1
			plsum=plsum+&plextra1.
		ENDIF
	ENDIF
	IF  .NOT. EMPTY(PLEXTRA2)
		plsum=plsum+&plextra2.
	ENDIF
	IF  .NOT. EMPTY(PLEXTRA3)
		plsum=plsum+&plextra3.
	ENDIF
	IF  .NOT. EMPTY(PLEXTRA4)
		plsum=plsum+&plextra4.
	ENDIF
	RETURN PLSUM
ENDPROC
*------
PROCEDURE paulGET_VALUE
	LPARAMETER PLDBF , PLSEEK , PLVALUE , PLSCREEN , PLKEYNAME , PLUNIQUE , PLCKBOX , PLSELECT ,  ;
		PLTEMPDBF , PLCCOUNT , PLROWTYPE , PLWIDTHS
	KEY_VALUE = PLVALUE
	REC_CUST = RECNO()
	SET_EXACT = SET('EXACT')
	SET_NEAR = SET('NEAR')
	PLSELECTWK = SELECT()
	APPQRY6 = CREATEOBJECT('GET_ID')
	APPQRY6.CAPTION = PLSCREEN
	APPQRY6.KEYNAME1.CAPTION = PLKEYNAME
	APPQRY6.SEEKFIELD = PLSEEK
	APPQRY6.DBF = PLDBF
	APPQRY6.UNIQUE_KEY = PLUNIQUE
	IF PLCKBOX = 'Y'
		APPQRY6.KEY1.VISIBLE = .F.
		APPQRY6.TXTPERIOD.VISIBLE = .T.
		APPQRY6.TXTPERIOD.ROWSOURCE = PLSELECT
		APPQRY6.TXTPERIOD.ROWSOURCETYPE = PLROWTYPE
		APPQRY6.TXTPERIOD.COLUMNCOUNT = PLCCOUNT
		APPQRY6.TXTPERIOD.COLUMNWIDTHS = PLWIDTHS
		APPQRY6.TXTPERIOD.BOUNDCOLUMN = 1
		APPQRY6.TXTPERIOD.VALUE = PLVALUE
		APPQRY6.CMDACCT.VISIBLE = .T.
		APPQRY6.CMDOK.VISIBLE = .F.
		APPQRY6.CMDCANCEL.VISIBLE = .F.
		APPQRY6.SHOW()
		IF USED(PLTEMPDBF)
			use in &pltempdbf.
		ENDIF
	ELSE
		APPQRY6.KEY1.VALUE = PLVALUE
		APPQRY6.SHOW()
	ENDIF
	SET DELETED ON
	SET EXACT &SET_EXACT.
	SET NEAR &SET_NEAR.
	RELEASE APPQRY6
	SELECT (PLSELECTWK)
	RETURN KEY_VALUE
ENDPROC
*------
PROCEDURE paulITEMDESC
	LPARAMETER PLDBF , PLCAPTION , PLSOURCE , PLFORM , PLSCREENKEY , PLREADONLY , PLPROPERTY
	IF EOF(PLDBF)
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PLFORM)
		KEYVALUE1 = PLDBF
		KEYVALUE2 = PLCAPTION
		KEYVALUE3 = PLSOURCE
		KEYVALUE4 = PLSCREENKEY
		KEYVALUE5 = ALIAS()
		DO FORM &plform.
		RETURN
	ENDIF
	LOCAL APPQRY9 , SELECT_WKSM
	SELECT_WKSM = SELECT()
	APPQRY9 = CREATEOBJECT('PK_MEMO')
	APPQRY9.CAPTION = PLCAPTION
	APPQRY9.DBF = PLDBF
	APPQRY9.TXTMEMO.CONTROLSOURCE = PLSOURCE
	APPQRY9.TXTMEMO.HEIGHT = 308
	APPQRY9.LBNETWT.VISIBLE = .F.
	APPQRY9.LBGRSWT.VISIBLE = .F.
	APPQRY9.LBCTNNO.VISIBLE = .F.
	APPQRY9.LBCBM.VISIBLE = .F.
	APPQRY9.LBCUFT.VISIBLE = .F.
	APPQRY9.LBPACKING.VISIBLE = .F.
	APPQRY9.SQUARE.VISIBLE = .F.
	APPQRY9.TTL_NET_WT.VISIBLE = .F.
	APPQRY9.TTL_GRS_WT.VISIBLE = .F.
	APPQRY9.TTL_CTNS.VISIBLE = .F.
	APPQRY9.TTL_CBM.VISIBLE = .F.
	APPQRY9.TTL_CUFT.VISIBLE = .F.
	IF  .NOT. EMPTY(PLPROPERTY)
		APPQRY9.TXTMEMO.WIDTH = VAL(PLPROPERTY)
	ENDIF
	IF  .NOT. EMPTY(PLREADONLY)
		IF PLREADONLY
			APPQRY9.TXTMEMO.READONLY = PLREADONLY
			APPQRY9.CMDOK.VISIBLE =  .NOT. PLREADONLY
			APPQRY9.CMDCANCEL.CAPTION = SYSBUTTON_EXIT
		ENDIF
	ENDIF
	APPQRY9.SHOW()
	RELEASE APPQRY9
	SELECT (SELECT_WKSM)
ENDPROC
*------
PROCEDURE paulITEMDESC2
	LPARAMETER PLDBF , PLCAPTION , PLSOURCE , PLFORM , PLSCREENKEY , PLREADONLY , PLPROPERTY
	IF EOF(PLDBF)
		RETURN
	ENDIF
	IF  .NOT. EMPTY(PLFORM)
		KEYVALUE1 = PLDBF
		KEYVALUE2 = PLCAPTION
		KEYVALUE3 = PLSOURCE
		KEYVALUE4 = PLSCREENKEY
		KEYVALUE5 = ALIAS()
		DO FORM &plform.
		RETURN
	ENDIF
	LOCAL APPQRY9 , SELECT_WKSM
	SELECT_WKSM = SELECT()
	APPQRY9 = CREATEOBJECT('ITDESC')
	APPQRY9.CAPTION = PLCAPTION
	APPQRY9.DBF = PLDBF
	APPQRY9.TXTMEMO.CONTROLSOURCE = PLSOURCE
	IF  .NOT. EMPTY(PLPROPERTY)
		APPQRY9.TXTMEMO.WIDTH = VAL(PLPROPERTY)
	ENDIF
	IF  .NOT. EMPTY(PLREADONLY)
		IF PLREADONLY
			APPQRY9.TXTMEMO.READONLY = PLREADONLY
			APPQRY9.CMDEXIT.CAPTION = SYSBUTTON_EXIT
		ENDIF
	ENDIF
	APPQRY9.SHOW()
	RELEASE APPQRY9
	SELECT (SELECT_WKSM)
ENDPROC
*------
PROCEDURE paulCHANGEVALUE
	LPARAMETER PLEXISTDBF , PLDBF1 , PLDBF2 , PLSEEK1 , PLKEY1 , PLID1 , PLRELATION , PLSEEK2 ,  ;
		PLKEY2 , PLID2 , PLREP11 , PLWITH11 , PLREP12 , PLWITH12 , PLREP13 ,  ;
		PLWITH13 , PLREP21 , PLWITH21 , PLREP22 , PLWITH22 , PLREP23 ,  ;
		PLWITH23 , PLCONDITION
	LOCAL PLSEEKWK , PLSETEXACT , PLCOUNTER , PLCONDITION
	PLSEEKWK = SELECT()
	PLSETEXACT = SET('exact')
	PLCOUNTER = 0
	IF EMPTY(PLCONDITION)
		PLCONDITION = '.T.'
	ENDIF
	IF USED('plalias1')
		USE IN PLALIAS1
	ENDIF
	IF USED('plalias2')
		USE IN PLALIAS2
	ENDIF
	SET EXACT ON
	IF PLEXISTDBF = 'Y'
		PLALIAS1 = PLDBF1
		select &plalias1.
		set order to &plseek1.
	ELSE
		PLALIAS1 = 'plalias1'
		use &pldbf1. alias &plalias1. order &plseek1. AGAIN IN 0
	ENDIF
	IF  .NOT. EMPTY(PLDBF2)
		use &pldbf2. alias plalias2 order &plseek2. AGAIN IN 0
	ENDIF
	SELECT &plalias1.
	SEEK PLID1
	IF FOUND()
		DO WHILE MACROS  ???FUN[CA] ('plid1=&plkey1. .AND. .NOT. EOF()')
			IF &plkey1. ==plid1 .and. &plcondition.
				PLCOUNTER = PLCOUNTER + 1
				REPLACE &plrep11. with &plwith11.
				IF  .NOT. EMPTY(PLREP12)
					REPLACE &plrep12. with &plwith12.
				ENDIF
				IF  .NOT. EMPTY(PLREP13)
					REPLACE &plrep13. with &plwith13.
				ENDIF
				WAIT WINDOW NOWAIT '# of record replaced: ' + STR(PLCOUNTER,5)
			ENDIF
			IF  .NOT. EMPTY(PLDBF2)
				SELECT PLALIAS2
				seek &plrelation.
				IF FOUND()
					REPLACE &plrep21. with &plwith21.
					IF  .NOT. EMPTY(PLREP22)
						REPLACE &plrep22. with &plwith22.
					ENDIF
					IF  .NOT. EMPTY(PLREP23)
						REPLACE &plrep23. with &plwith23.
					ENDIF
				ENDIF
			ENDIF
			SELECT &plalias1.
			SKIP
		ENDDO
	ENDIF
	IF PLEXISTDBF = 'Y'
		SELECT &plalias1.
	ELSE
		USE IN &plalias1.
	ENDIF
	IF  .NOT. EMPTY(PLDBF2)
		USE IN PLALIAS2
	ENDIF
	SELECT (PLSEEKWK)
	SET EXACT  &plsetexact.
ENDPROC
*------
PROCEDURE paulRETURN
	LPARAMETER PLEXISTDBF , PLDBF1 , PLSEEK1 , PLKEY1 , PLID1 , PLRKEY1 , PLINIT
	LOCAL PLSEEKWK , PLSETEXACT , PLCOUNTER , PLVALUE
	ON ERROR return
	PLSEEKWK = SELECT()
	PLSETEXACT = SET('exact')
	PLCOUNTER = 0
	SET EXACT ON
	IF PLEXISTDBF = 'Y'
		PLALIAS1 = PLDBF1
		select &plalias1.
	ELSE
		PLALIAS1 = 'plalias1'
		use &pldbf1. alias &plalias1. order &plseek1. AGAIN IN 0
	ENDIF
	SELECT &plalias1.
	seek plid1 order &plseek1.
	IF FOUND()
		plvalue=&plrkey1.
	ELSE
		PLVALUE = PLINIT
	ENDIF
	IF PLEXISTDBF = 'Y'
		SELECT &plalias1.
	ELSE
		USE IN &plalias1.
	ENDIF
	IF  .NOT. EMPTY(PLSEEKWK)
		SELECT (PLSEEKWK)
	ENDIF
	SET EXACT  &plsetexact.
	RETURN PLVALUE
ENDPROC
*------
PROCEDURE ITSCANDBF
	LPARAMETER PLFROMDBF , PLTEMPDBF , PLUSEDBF , PLSEEK , PLFIELD , PLSTART , PLEND ,  ;
		PLCONDITION , PLNO_REC , PAULORDER , PAULAORB , PLE1 , PLD1 , PLS1 , PLK1 ,  ;
		PLID1 , PLRP1 , PLRK1 , PLINIT1 , PLRP2 , PLRK2 , PLINIT2 , PLRP3 ,  ;
		PLRK3 , PLINIT3
	LOCAL PAULSET_NEAR , PAULSET_EXACT , PLFILTER , PAULORDER , PAULAORB
	PLFILTER = PLFIELD + ' >= ' + PLSTART + ' .AND. ' + PLFIELD + ' <= ' + PLEND
	PAULALIAS = ALLTRIM(PLFROMDBF) + 'SQL'
	PAULALIASOLD = ALLTRIM(PLTEMPDBF) + 'OLD'
	PAULTEMP = CURDIR() + 'TEMPDBC\' + ALLTRIM(PLTEMPDBF)
	IF  .NOT. EMPTY(PLD1)
		PAULSUBDBF = ALLTRIM(PLD1) + 'R'
		IF USED(PAULSUBDBF)
			USE IN (PAULSUBDBF)
		ENDIF
	ENDIF
	IF USED(PAULALIASOLD)
		USE IN (PAULALIASOLD)
	ENDIF
	IF USED(PAULALIAS)
		USE IN (PAULALIAS)
	ENDIF
	IF USED(PLUSEDBF)
		USE IN (PLUSEDBF)
	ENDIF
	IF  .NOT. EMPTY(PLD1)
		PAULSUBDBF = ALLTRIM(PLD1) + 'R'
		USE IN 0 (PLD1) AGAIN ALIAS (PAULSUBDBF)
	ENDIF
	IF EMPTY(PLTEMPDBF)
		USE IN 0 (PLFROMDBF) AGAIN ALIAS (PLUSEDBF)
		SELECT (PLUSEDBF)
		IF  .NOT. EMPTY(PAULORDER)
			IF  .NOT. EMPTY(PAULAORB)
				IF AT('+',PAULORDER) > 0
					WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
					INDEX ON &paulORDER. TO &PLTEMPINDEX. &paulAORB.
				ELSE
					SET ORDER TO &paulORDER. &paulAORB.
				ENDIF
			ELSE
				IF AT('+',PAULORDER) > 0
					WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
					INDEX ON &paulORDER. TO &PLTEMPINDEX.
				ELSE
					SET ORDER TO &paulORDER.
				ENDIF
			ENDIF
		ENDIF
		RETURN .T.
	ENDIF
	USE IN 0 (PAULTEMP) AGAIN ALIAS (PAULALIASOLD)
	USE IN (PAULALIASOLD)
	USE IN 0 EXCLUSIVE (PAULTEMP) AGAIN ALIAS (PAULALIASOLD)
	SELECT (PAULALIASOLD)
	IF AT('TEMPDBC',PAULTEMP) > 0
		ZAP
	ENDIF
	USE IN 0 (PLFROMDBF) AGAIN ALIAS (PAULALIAS) ORDER (PLSEEK)
	SELECT (PAULALIAS)
	PAULSET_NEAR = SET('NEAR')
	SET NEAR ON
	GO TOP
	seek &plstart.
	SET NEAR &paulSET_NEAR.
	IF EOF()
		USE IN (PAULALIAS)
		USE IN (PAULALIASOLD)
		USE IN 0 (PAULTEMP) AGAIN ALIAS (PLUSEDBF)
		SELECT (PLUSEDBF)
		IF ID_VALUE <> 'ALERTEML'
			= PAULMESSAGE('Nothing to print !','WARNING')
		ENDIF
		LRPRINT = 999
		RETURN .T.
	ENDIF
	PAULRETRIVE = 1
	DO WHILE MACROS  ???FUN[CA] ('.NOT. EOF(paulALIAS) .AND. &plFILTER.  ')
		IF &plcondition.
			SCATTER MEMO MEMVAR
			SELECT (PAULALIASOLD)
			INSERT INTO (PAULALIASOLD) FROM MEMVAR
			IF  .NOT. EMPTY(PLRP1)
				REPLACE &plrp1. with paulRETURN(ple1,PaulSUBDBF,pls1,plk1,&plid1.,plrk1,plinit1)
			ENDIF
			IF  .NOT. EMPTY(PLRP2)
				REPLACE &plrp2. with paulRETURN(ple1,PaulSUBDBF,pls1,plk1,&plid1.,plrk3,plinit3)
			ENDIF
			IF  .NOT. EMPTY(PLRP3)
				REPLACE &plrp3. with paulRETURN(ple1,PaulSUBDBF,pls1,plk1,&plid1.,plrk3,plinit3)
			ENDIF
			PAULRETRIVE = PAULRETRIVE + 1
		ENDIF
		SELECT (PAULALIAS)
		IF  .NOT. EOF()
			SKIP
		ENDIF
		WAIT WINDOW NOWAIT 'Scanning records : ' + ALLTRIM(STR(PAULRETRIVE - 1,7))
		IF PAULRETRIVE / PLNO_REC = INT(PAULRETRIVE / PLNO_REC)
			IF  .NOT. PAULASK_YN(ALLTRIM(STR(PAULRETRIVE - 1,7)) + ' Record(s) retrived !  Continue... ? ','WARNING')
				EXIT
			ENDIF
		ENDIF
	ENDDO
	USE IN (PAULALIAS)
	USE IN (PAULALIASOLD)
	USE IN 0 (PAULTEMP) AGAIN ALIAS (PLUSEDBF)
	SELECT (PLUSEDBF)
	IF  .NOT. EMPTY(PAULORDER)
		IF  .NOT. EMPTY(PAULAORB)
			IF AT('+',PAULORDER) > 0
				WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
				INDEX ON &paulORDER. TO &PLTEMPINDEX. &paulAORB.
			ELSE
				SET ORDER TO &paulORDER. &paulAORB.
			ENDIF
		ELSE
			IF AT('+',PAULORDER) > 0
				WAIT WINDOW NOWAIT 'Sorting on :' + SUBSTR(PAULORDER,1,20) + '...'
				INDEX ON &paulORDER. TO &PLTEMPINDEX.
			ELSE
				SET ORDER TO &paulORDER.
			ENDIF
		ENDIF
	ENDIF
	RETURN .T.
ENDPROC
*------
PROCEDURE paulFUNCTION
	LPARAMETER PLFUNC
	ON ERROR return ''
	IF EMPTY(PLFUNC)
		RETURN ''
	ELSE
		return &plfunc.
	ENDIF
ENDPROC
*------
PROCEDURE paulREC_SKIP
	LPARAMETER PAULREFRESH , PLDBF , PLKEY1 , PLKEY2
	IF EOF()
		RETURN
	ENDIF
	LNRECNO = RECNO()
	SKIP
	IF EOF()
		SKIP -1
		IF  .NOT. BOF()
			IF PAULREFRESH = 'Y'
				_SCREEN.ACTIVEFORM.REFRESHFORM()
			ENDIF
		ELSE
		ENDIF
	ELSE
		IF LNRECNO = RECNO()
			LLRETVAL = .F.
		ELSE
			IF PAULREFRESH = 'Y'
				_SCREEN.ACTIVEFORM.REFRESHFORM()
			ENDIF
		ENDIF
	ENDIF
	RETURN
ENDPROC
*------
PROCEDURE itADDMODULE
	LPARAMETER PAULSCREEN
	LOCAL PLSETEXACT , PLSCREEN_NAME
	PLSETEXACT = SET('EXACT')
	PLSCREEN_NAME = ''
	PAULSCREEN = UPPER(ALLTRIM(PAULSCREEN))
	IF EMPTY(PAULSCREEN)
		RETURN
	ENDIF
	SET EXACT ON
	USE IN 0 caption AGAIN ALIAS CAPTION_MODULE ORDER screen_id
	SELECT CAPTION_MODULE
	SEEK UPPER(PAULSCREEN)
	IF FOUND()
		PLSCREEN_NAME = SCREEN_NAME
	ELSE
		WAIT WINDOW 'This module not found in caption.dbf ! ' + PAULSCREEN
		SET EXACT &plsetexact.
		USE IN CAPTION_MODULE
		RETURN
	ENDIF
	USE IN CAPTION_MODULE
	IF  .NOT. EMPTY(PLSCREEN_NAME)
		USE IN 0 sec_grp AGAIN ALIAS PAULSECGRP
		USE IN 0 security AGAIN ALIAS PAULSEC ORDER screen_id
		SELECT PAULSEC
		SEEK PAULSCREEN
		IF FOUND()
			WAIT WINDOW ' This module already exists in security group control !'
			USE IN PAULSEC
			USE IN PAULSECGRP
			SET EXACT &plsetexact.
			RETURN
		ENDIF
		SELECT PAULSECGRP
		GO TOP
		DO WHILE  .NOT. EOF()
			SELECT PAULSEC
			APPEND BLANK
			REPLACE CODE WITH PAULSECGRP.CODE
			REPLACE SCREEN_ID WITH PAULSCREEN
			REPLACE SCREEN_NAME WITH PLSCREEN_NAME
			SELECT PAULSECGRP
			SKIP
		ENDDO
	ENDIF
	USE IN PAULSEC
	USE IN PAULSECGRP
	SET EXACT &plsetexact.
	WAIT WINDOW 'Add module security control completed !'
	RETURN
ENDPROC
*------
PROCEDURE paulZAP
	LPARAMETER PAULDBF , PAULTYPE
	LOCAL PLSELECTWK , PLSETSAFETY
	ON ERROR return
	PAULDBF = ALLTRIM(PAULDBF)
	PLSELECTWK = SELECT()
	PLSETSAFETY = SET('SAFETY')
	SET SAFETY OFF
	PAULSTATUS = USED(PAULDBF)
	IF  .NOT. PAULSTATUS
		use &pauldbf. in 0
		use in &pauldbf.
		use &pauldbf. in 0  exclusive again
		SELECT (PAULDBF)
		IF  .NOT. EMPTY(PAULTYPE) AND UPPER(PAULTYPE) = 'ZAP'
			IF UPPER(ALIAS()) = UPPER(PAULDBF)
				ZAP
			ENDIF
		ELSE
			DELETE ALL
			IF ISEXCLUSIVE()
				PACK
			ENDIF
		ENDIF
	ELSE
		SELECT (PAULDBF)
		IF  .NOT. EMPTY(PAULTYPE) AND UPPER(PAULTYPE) = 'ZAP'
			IF UPPER(ALIAS()) = UPPER(PAULDBF)
				ZAP
			ENDIF
		ELSE
			DELETE ALL
			IF ISEXCLUSIVE()
				PACK
			ENDIF
		ENDIF
	ENDIF
	IF  .NOT. PAULSTATUS
		use in &pauldbf.
	ENDIF
	SELECT (PLSELECTWK)
	SET SAFETY &plsetsafety.
	RETURN
ENDPROC
*------
PROCEDURE IT_TB
	LPARAMETER PLTYPE , PLLAST , PLALIAS , PLSOURCE , PAULORDER , PAULAORB , PLACFM , PLACTO ,  ;
		PLDATEFM , PLDATETO
	ON ERROR return
	IF PLLAST = 'Y'
		IF PAULASK_YN('Do you want to use previous data ?','WARNING MESSAGE')
			RETURN
		ENDIF
	ENDIF
	LOCAL SET_SAFETY , SET_EXACT , PLSELECT
	PLSELECT = SELECT()
	SELECT 0
	IF PLSOURCE = 'Y'
		PLTYPE =  ;
			PAULGET_VALUE('','','CA','DATA SOURCE','Select data from ',.T.,'Y','CA,Chart of Account,JV,Journal Ledger','',2,1,'50,190')
	ENDIF
	SET_SAFETY = SET('SAFETY')
	SET_EXACT = SET('EXACT')
	SET_NEAR = SET('NEAR')
	SET SAFETY OFF
	SET EXACT OFF
	SET NEAR ON
	IF USED('JPAC')
		USE IN JPAC
	ENDIF
	IF USED('JPACR')
		USE IN JPACR
	ENDIF
	USE IN 0 EXCLUSIVE JPAC ORDER acct_id
	SELECT JPAC
	IF UPPER(ALIAS()) = 'JPAC'
		ZAP
	ENDIF
	SET SAFETY &set_safety.
	USE IN 0 ACCT_CA AGAIN ALIAS PAULACCT_CA ORDER acct_id
	SELECT PAULACCT_CA
	GO TOP
	IF  .NOT. EMPTY(PLACFM)
		SEEK ALLTRIM(PLACFM)
	ENDIF
	DO WHILE  ;
			INKEY() <> 27 AND  .NOT. EOF('paulACCT_CA') AND  ;
			(PAULACCT_CA.ACCT_ID >= DV1_FM AND PAULACCT_CA.ACCT_ID <= PLACTO)
		WAIT WINDOW NOWAIT PAULACCT_CA.ACCT_ID + STR(RECNO(),9)
		SELECT JPAC
		APPEND BLANK
		REPLACE AC_CODE WITH PAULACCT_CA.AC_CODE
		REPLACE YEAR WITH PAULACCT_CA.YEAR
		REPLACE ACCT_ID WITH PAULACCT_CA.ACCT_ID
		REPLACE LEVEL WITH PAULACCT_CA.LEVEL
		REPLACE TYPE WITH PAULACCT_CA.TYPE
		REPLACE PROFIT WITH PAULACCT_CA.PROFIT
		REPLACE GROUP1 WITH PAULACCT_CA.GROUP1
		REPLACE GROUP2 WITH PAULACCT_CA.GROUP2
		REPLACE GROUP3 WITH PAULACCT_CA.GROUP3
		REPLACE LOOKUPID WITH PAULACCT_CA.LOOKUPID
		REPLACE AC_DESC WITH PAULACCT_CA.AC_DESC
		REPLACE AC_TYPE WITH PAULACCT_CA.AC_TYPE
		REPLACE ORG_TYPE WITH PAULACCT_CA.ORG_TYPE
		REPLACE ORG_ID WITH PAULACCT_CA.ORG_ID
		REPLACE AC_PAREN WITH PAULACCT_CA.AC_PAREN
		REPLACE CCY_CONTRO WITH PAULACCT_CA.CCY_CONTROL
		REPLACE CCY WITH PAULACCT_CA.CCY
		REPLACE BANK_AC WITH PAULACCT_CA.BANK_AC
		REPLACE PRIOR_BAL WITH PAULACCT_CA.PRIOR_BAL
		REPLACE LAST_BAL WITH PAULACCT_CA.LAST_BAL
		REPLACE BALANCE WITH PAULACCT_CA.BALANCE
		REPLACE FORWARD_BA WITH PAULACCT_CA.FORWARD_BAL
		REPLACE BACKWARD_B WITH PAULACCT_CA.BACKWARD_BAL
		REPLACE DEBIT WITH PAULACCT_CA.DEBIT
		REPLACE CREDIT WITH PAULACCT_CA.CREDIT
		REPLACE YEARBUDGET WITH PAULACCT_CA.YEARBUDGET
		REPLACE LASTBUDGET WITH PAULACCT_CA.LASTBUDGET
		REPLACE BAL_OPEN WITH PAULACCT_CA.BAL_OPEN
		REPLACE STATUS WITH PAULACCT_CA.STATUS
		REPLACE SUPPRESS_R WITH PAULACCT_CA.SUPPRESS_REV
		REPLACE CHECK_ACCT WITH PAULACCT_CA.CHECK_ACCT
		REPLACE ORG_CODE WITH PAULACCT_CA.ORG_CODE
		REPLACE CREDIT_LIM WITH PAULACCT_CA.CREDIT_LIMIT
		REPLACE PAY_METHOD WITH PAULACCT_CA.PAY_METHOD
		REPLACE TERMS WITH PAULACCT_CA.TERMS
		REPLACE TAX_CODE WITH PAULACCT_CA.TAX_CODE
		REPLACE DIRECT_DBT WITH PAULACCT_CA.DIRECT_DBT
		REPLACE DISC_DAY1 WITH PAULACCT_CA.DISC_DAY1
		REPLACE DISC_DAY2 WITH PAULACCT_CA.DISC_DAY2
		REPLACE DISCOUNT1 WITH PAULACCT_CA.DISCOUNT1
		REPLACE DISCOUNT2 WITH PAULACCT_CA.DISCOUNT2
		REPLACE TRANSACT WITH PAULACCT_CA.TRANSACT
		REPLACE A1 WITH PAULACCT_CA.A1
		REPLACE A2 WITH PAULACCT_CA.A2
		REPLACE A3 WITH PAULACCT_CA.A3
		REPLACE A4 WITH PAULACCT_CA.A4
		REPLACE A5 WITH PAULACCT_CA.A5
		REPLACE A6 WITH PAULACCT_CA.A6
		REPLACE BUDGET1 WITH PAULACCT_CA.BUDGET1
		REPLACE BUDGET2 WITH PAULACCT_CA.BUDGET2
		REPLACE BUDGET3 WITH PAULACCT_CA.BUDGET3
		REPLACE BUDGET4 WITH PAULACCT_CA.BUDGET4
		REPLACE BUDGET5 WITH PAULACCT_CA.BUDGET5
		REPLACE BUDGET6 WITH PAULACCT_CA.BUDGET6
		REPLACE BUDGET7 WITH PAULACCT_CA.BUDGET7
		REPLACE BUDGET8 WITH PAULACCT_CA.BUDGET8
		REPLACE BUDGET9 WITH PAULACCT_CA.BUDGET9
		REPLACE BUDGET10 WITH PAULACCT_CA.BUDGET10
		REPLACE BUDGET11 WITH PAULACCT_CA.BUDGET11
		REPLACE BUDGET12 WITH PAULACCT_CA.BUDGET12
		REPLACE BUDGET13 WITH PAULACCT_CA.BUDGET13
		REPLACE BUDGET14 WITH PAULACCT_CA.BUDGET14
		REPLACE BUDGET15 WITH PAULACCT_CA.BUDGET15
		REPLACE BUDGET16 WITH PAULACCT_CA.BUDGET16
		REPLACE BUDGET17 WITH PAULACCT_CA.BUDGET17
		REPLACE BUDGET18 WITH PAULACCT_CA.BUDGET18
		REPLACE BUDGET19 WITH PAULACCT_CA.BUDGET19
		REPLACE BUDGET20 WITH PAULACCT_CA.BUDGET20
		REPLACE BUDGET21 WITH PAULACCT_CA.BUDGET21
		REPLACE BUDGET22 WITH PAULACCT_CA.BUDGET22
		REPLACE BUDGET23 WITH PAULACCT_CA.BUDGET23
		REPLACE BUDGET24 WITH PAULACCT_CA.BUDGET24
		REPLACE PRIOR1 WITH PAULACCT_CA.PRIOR1
		REPLACE PRIOR2 WITH PAULACCT_CA.PRIOR2
		REPLACE PRIOR3 WITH PAULACCT_CA.PRIOR3
		REPLACE PRIOR4 WITH PAULACCT_CA.PRIOR4
		REPLACE PRIOR5 WITH PAULACCT_CA.PRIOR5
		REPLACE PRIOR6 WITH PAULACCT_CA.PRIOR6
		REPLACE PRIOR7 WITH PAULACCT_CA.PRIOR7
		REPLACE PRIOR8 WITH PAULACCT_CA.PRIOR8
		REPLACE PRIOR9 WITH PAULACCT_CA.PRIOR9
		REPLACE PRIOR10 WITH PAULACCT_CA.PRIOR10
		REPLACE PRIOR11 WITH PAULACCT_CA.PRIOR11
		REPLACE PRIOR12 WITH PAULACCT_CA.PRIOR12
		REPLACE PRIOR13 WITH PAULACCT_CA.PRIOR13
		REPLACE PRIOR14 WITH PAULACCT_CA.PRIOR14
		REPLACE PRIOR15 WITH PAULACCT_CA.PRIOR15
		REPLACE PRIOR16 WITH PAULACCT_CA.PRIOR16
		REPLACE PRIOR17 WITH PAULACCT_CA.PRIOR17
		REPLACE PRIOR18 WITH PAULACCT_CA.PRIOR18
		REPLACE PRIOR19 WITH PAULACCT_CA.PRIOR19
		REPLACE PRIOR20 WITH PAULACCT_CA.PRIOR20
		REPLACE PRIOR21 WITH PAULACCT_CA.PRIOR21
		REPLACE PRIOR22 WITH PAULACCT_CA.PRIOR22
		REPLACE PRIOR23 WITH PAULACCT_CA.PRIOR23
		REPLACE PRIOR24 WITH PAULACCT_CA.PRIOR24
		REPLACE PERIOD1 WITH PAULACCT_CA.PERIOD1
		REPLACE PERIOD2 WITH PAULACCT_CA.PERIOD2
		REPLACE PERIOD3 WITH PAULACCT_CA.PERIOD3
		REPLACE PERIOD4 WITH PAULACCT_CA.PERIOD4
		REPLACE PERIOD5 WITH PAULACCT_CA.PERIOD5
		REPLACE PERIOD6 WITH PAULACCT_CA.PERIOD6
		REPLACE PERIOD7 WITH PAULACCT_CA.PERIOD7
		REPLACE PERIOD8 WITH PAULACCT_CA.PERIOD8
		REPLACE PERIOD9 WITH PAULACCT_CA.PERIOD9
		REPLACE PERIOD10 WITH PAULACCT_CA.PERIOD10
		REPLACE PERIOD11 WITH PAULACCT_CA.PERIOD11
		REPLACE PERIOD12 WITH PAULACCT_CA.PERIOD12
		REPLACE PERIOD13 WITH PAULACCT_CA.PERIOD13
		REPLACE PERIOD14 WITH PAULACCT_CA.PERIOD14
		REPLACE PERIOD15 WITH PAULACCT_CA.PERIOD15
		REPLACE PERIOD16 WITH PAULACCT_CA.PERIOD16
		REPLACE PERIOD17 WITH PAULACCT_CA.PERIOD17
		REPLACE PERIOD18 WITH PAULACCT_CA.PERIOD18
		REPLACE PERIOD19 WITH PAULACCT_CA.PERIOD19
		REPLACE PERIOD20 WITH PAULACCT_CA.PERIOD20
		REPLACE PERIOD21 WITH PAULACCT_CA.PERIOD21
		REPLACE PERIOD22 WITH PAULACCT_CA.PERIOD22
		REPLACE PERIOD23 WITH PAULACCT_CA.PERIOD23
		REPLACE PERIOD24 WITH PAULACCT_CA.PERIOD24
		REPLACE THIS_CCY1 WITH PAULACCT_CA.THIS_CCY1
		REPLACE THIS_CCY2 WITH PAULACCT_CA.THIS_CCY2
		REPLACE THIS_CCY3 WITH PAULACCT_CA.THIS_CCY3
		REPLACE THIS_CCY4 WITH PAULACCT_CA.THIS_CCY4
		REPLACE THIS_CCY5 WITH PAULACCT_CA.THIS_CCY5
		REPLACE THIS_CCY6 WITH PAULACCT_CA.THIS_CCY6
		REPLACE THIS_CCY7 WITH PAULACCT_CA.THIS_CCY7
		REPLACE THIS_CCY8 WITH PAULACCT_CA.THIS_CCY8
		REPLACE THIS_CCY9 WITH PAULACCT_CA.THIS_CCY9
		REPLACE THIS_CCY10 WITH PAULACCT_CA.THIS_CCY10
		REPLACE LAST_CCY1 WITH PAULACCT_CA.LAST_CCY1
		REPLACE LAST_CCY2 WITH PAULACCT_CA.LAST_CCY2
		REPLACE LAST_CCY3 WITH PAULACCT_CA.LAST_CCY3
		REPLACE LAST_CCY4 WITH PAULACCT_CA.LAST_CCY4
		REPLACE LAST_CCY5 WITH PAULACCT_CA.LAST_CCY5
		REPLACE LAST_CCY6 WITH PAULACCT_CA.LAST_CCY6
		REPLACE LAST_CCY7 WITH PAULACCT_CA.LAST_CCY7
		REPLACE LAST_CCY8 WITH PAULACCT_CA.LAST_CCY8
		REPLACE LAST_CCY9 WITH PAULACCT_CA.LAST_CCY9
		REPLACE LAST_CCY10 WITH PAULACCT_CA.LAST_CCY10
		SELECT PAULACCT_CA
		SKIP
	ENDDO
	IF USED('paulACCT_CA')
		USE IN PAULACCT_CA
	ENDIF
	SELECT JPAC
	GO TOP
	IF PLTYPE = 'CA'
		IF EMPTY(PLALIAS)
			USE IN JPAC
			SELECT (PLSELECT)
		ELSE
			USE IN JPAC
			USE IN 0 JPAC AGAIN ALIAS (PLALIAS)
			SELECT (PLALIAS)
			IF  .NOT. EMPTY(PAULORDER)
				IF  .NOT. EMPTY(PAULAORB)
					SET ORDER TO &paulORDER. &paulAORB.
				ELSE
					SET ORDER TO (PAULORDER)
				ENDIF
			ENDIF
		ENDIF
		set exact &set_exact.
		set safety &set_safety.
		set near &set_near.
		RETURN
	ENDIF
	LOCAL SET_SAFETY , APPQRY9 , PLCOUNTER
	APPEND_YN = .T.
	PLCOUNTER = 1
	KEY_VALUE1 = {}
	KEY_VALUE2 = DATE()
	SELECT JPAC
	LOCAL PAULTOTAL_REC1
	PAULTOTAL_REC1 = RECCOUNT()
	GO TOP
	DO WHILE  .NOT. EOF()
		REPLACE BALANCE WITH 0
		REPLACE FORWARD_BA WITH 0
		REPLACE BACKWARD_B WITH 0
		REPLACE DEBIT WITH 0
		REPLACE CREDIT WITH 0
		REPLACE THIS_CCY1 WITH 0
		REPLACE THIS_CCY2 WITH 0
		REPLACE THIS_CCY3 WITH 0
		REPLACE THIS_CCY4 WITH 0
		REPLACE THIS_CCY5 WITH 0
		REPLACE THIS_CCY6 WITH 0
		REPLACE THIS_CCY7 WITH 0
		REPLACE THIS_CCY8 WITH 0
		REPLACE THIS_CCY9 WITH 0
		REPLACE THIS_CCY10 WITH 0
		WAIT WINDOW NOWAIT 'Record No. : ' + STR(RECNO(),8) + ' OF ' + STR(PAULTOTAL_REC1,8)
		IF  .NOT. EOF()
			SKIP
		ENDIF
	ENDDO
	I = 1
	WAIT WINDOW NOWAIT 'RE-SET PERIOD VALUE .... PLEASE WAIT !'
	DO WHILE I <= 24
		PERIOD_LET = ALLTRIM(STR(I,3,0))
		PERIOD_LET = 'PERIOD' + PERIOD_LET
		REPLACE &PERIOD_LET. WITH 0 FOR .T.
		I = I + 1
		WAIT WINDOW NOWAIT 'Period : ' + STR(I)
	ENDDO
	SET_SAFETY = SET('SAFETY')
	SET SAFETY OFF
	SET EXACT ON
	SELECT JPAC
	SET SAFETY &set_safety.
	IF USED('ACCT_DEFR')
		USE IN ACCT_DEFR
	ENDIF
	IF PLTYPE = 'JV'
		USE IN 0 jvmast AGAIN ALIAS PAULJVMAST ORDER voucher_no
		USE IN 0 jvdtl AGAIN ALIAS PAULJVDTL ORDER acct_id
	ELSE
		USE IN 0 glmast AGAIN ALIAS PAULJVMAST ORDER voucher_no
		USE IN 0 gldtl AGAIN ALIAS PAULJVDTL ORDER acct_id
	ENDIF
	USE IN 0 ACCT_DEF AGAIN ALIAS ACCT_DEFR
	SELECT PAULJVDTL
	SET RELATION TO VOUCHER_NO INTO PAULJVMAST
	GO TOP
	SELECT JPAC
	GO TOP
	SELECT PAULJVDTL
	GO TOP
	SEEK JPAC.ACCT_ID
	PLCOUNTER = 1
	SELECT PAULJVDTL
	GO TOP
	IF  .NOT. EMPTY(DV1_FM)
		SET EXACT OFF
		SET NEAR ON
		SEEK ALLTRIM(DV1_FM)
		SET EXACT ON
	ENDIF
	DO WHILE  ;
			INKEY() <> 27 AND  .NOT. EOF('pauljvdtl') AND  ;
			(ALLTRIM(PAULJVDTL.ACCT_ID) >= DV1_FM AND ALLTRIM(PAULJVDTL.ACCT_ID) <= PLACTO)
		SELECT JPAC
		SEEK PAULJVDTL.ACCT_ID
		IF FOUND()
			IF PAULJVMAST.VOUCH_DATE >= PLDATEFM AND PAULJVMAST.VOUCH_DATE <= PLDATETO
				= PAULACCT_IDDEBIT('JPAC',PAULJVMAST.PERIOD,PAULJVDTL.ACCT_ID,ITROUND((PAULJVDTL.DEBIT - PAULJVDTL.CREDIT) * PAULJVDTL.EXCHAN,AC_DECIMAL),PAULJVMAST.VOUCH_DATE,ACCT_DEFR.OPENDATEFR,ACCT_DEFR.OPENDATETO,PAULJVDTL.DEBIT - PAULJVDTL.CREDIT,'ACCT_DEFR',PAULJVDTL.CCY,ACCT_CURR,'Y')
			ENDIF
			IF PAULJVMAST.VOUCH_DATE < PLDATEFM
				REPLACE JPAC.BEGIN_CRE WITH  ;
					JPAC.BEGIN_CRE + ITROUND(PAULJVDTL.CREDIT * PAULJVDTL.EXCHAN,AC_DECIMAL)
				REPLACE JPAC.BEGIN_DEB WITH  ;
					JPAC.BEGIN_DEB + ITROUND(PAULJVDTL.DEBIT * PAULJVDTL.EXCHAN,AC_DECIMAL)
			ENDIF
			IF PAULJVMAST.VOUCH_DATE >= PLDATETO - DAY(PLDATETO) + 1 AND  ;
					PAULJVMAST.VOUCH_DATE <= PLDATETO
				REPLACE JPAC.CURRCREDIT WITH  ;
					JPAC.CURRCREDIT + ITROUND(PAULJVDTL.CREDIT * PAULJVDTL.EXCHAN,AC_DECIMAL)
				REPLACE JPAC.CURRDEBIT WITH  ;
					JPAC.CURRDEBIT + ITROUND(PAULJVDTL.DEBIT * PAULJVDTL.EXCHAN,AC_DECIMAL)
			ENDIF
		ENDIF
		SELECT PAULJVDTL
		WAIT WINDOW NOWAIT  ;
			'Account ID :' + PAULJVDTL.ACCT_ID + STR(RECNO('pauljvdtl'),9) +  ;
			'  # of transaction :' + STR(PLCOUNTER)
		SKIP
		PLCOUNTER = PLCOUNTER + 1
	ENDDO
	IF USED('pauljvmast')
		USE IN PAULJVMAST
	ENDIF
	IF USED('pauljvdtl')
		USE IN PAULJVDTL
	ENDIF
	IF USED('acct_car')
		USE IN ACCT_CAR
	ENDIF
	IF EMPTY(PLALIAS)
		USE IN JPAC
		SELECT (PLSELECT)
	ELSE
		USE IN JPAC
		USE IN 0 JPAC AGAIN ALIAS (PLALIAS)
		SELECT (PLALIAS)
		IF  .NOT. EMPTY(PAULORDER)
			IF  .NOT. EMPTY(PAULAORB)
				SET ORDER TO &paulORDER. &paulAORB.
			ELSE
				SET ORDER TO (PAULORDER)
			ENDIF
		ENDIF
	ENDIF
	set exact &set_exact.
	set safety &set_safety.
	set near &set_near.
	RETURN
ENDPROC
*------
PROCEDURE paulRUN
	LPARAMETER PLFIELD , PLDBF , PLSEEK , PLVALUE
	LOCAL PLLENGTH , PLRUN , PLNAME , PLSELECTWK , PLSETEXACT , PLCOUNTER
	IF  .NOT. EMPTY(PLDBF)
		PLSELECTWK = SELECT()
		IF USED('paulrundbf')
			USE IN PAULRUNDBF
		ENDIF
		use &pldbf. alias paulrundbf order &plseek.
		SELECT PAULRUNDBF
		PLSETEXACT = SET('EXACT')
		SET EXACT ON
		SEEK PLVALUE
		set exact &plsetexact.
		PLFIELD = 'paulrundbf.' + ALLTRIM(PLFIELD)
		SELECT (PLSELECTWK)
	ENDIF
	pllength=memlines(&plfield.)
	IF PLLENGTH = 0
		RETURN
	ENDIF
	PLCOUNTER = 1
	DO WHILE PLLENGTH >= 1
		plrun=alltrim(mline(&plfield.,plcounter))
		IF  .NOT. EMPTY(PLRUN)
			&plrun.
		ENDIF
		PLCOUNTER = PLCOUNTER + 1
		PLLENGTH = PLLENGTH - 1
	ENDDO
	IF USED('paulrundbf')
		USE IN PAULRUNDBF
	ENDIF
	RETURN
ENDPROC
*------
PROCEDURE ITPASSWORD
	LPARAMETER PAULSEEK , PLNO
	IF PLNO < 1 .OR. PLNO > 18
		RETURN
	ENDIF
	PAULSEEK = RAND(PAULSEEK) * 10000
	LOCAL PLCOUNTER , PLPASSWORD
	PLPASSWORD = ''
	PLCOUNTER = 1
	DO WHILE PLCOUNTER <= PLNO
		PLPASSWORD = PLPASSWORD + CHR(48 + MOD(RAND(PLCOUNTER + PAULSEEK) * 100,43))
		PLCOUNTER = PLCOUNTER + 1
	ENDDO
	RETURN UPPER(ALLTRIM(PLPASSWORD))
ENDPROC
*------
PROCEDURE ITDATEPERIOD
	LPARAMETER PAULDBF , PAULDATE , PAULACCT_ID
	LOCAL PAULSELECT , PAULSEEK , PAULPERIODN , PLCOUNT , PLV1 , PLV2 , PLUSED , PLPERIOD
	PLPERIOD = CURRENT_PERIOD
	IF USED(PAULDBF)
		PLUSED = .T.
	ELSE
		IF USED('plperioddbf')
			USE IN PLPERIODDBF
		ENDIF
		USE IN 0 (PAULDBF) AGAIN ALIAS PLPERIODDBF
		PAULDBF = 'plperioddbf'
		PLUSED = .F.
	ENDIF
	PAULSELECT = SELECT()
	SELECT (PAULDBF)
	SEEK ORDER COMPANYID PAULACCT_ID
	IF FOUND()
		IF PAULDATE <= OPENDATEFR
			PLPERIOD = 1
			IF  .NOT. PLUSED
				USE IN PLPERIODDBF
			ENDIF
			SELECT (PAULSELECT)
			RETURN 1
		ENDIF
		IF PAULDATE > OPENDATETO
			PLPERIOD = MAXPERIOD
			IF  .NOT. PLUSED
				USE IN PLPERIODDBF
			ENDIF
			SELECT (PAULSELECT)
			RETURN PLPERIOD
		ENDIF
		PLCOUNT = 1
		DO WHILE PLCOUNT <= 24
			PLV1 = ALLTRIM(PAULDBF) + '.from' + ALLTRIM(STR(PLCOUNT,2))
			PLV2 = ALLTRIM(PAULDBF) + '.to' + ALLTRIM(STR(PLCOUNT,2))
			if paulDATE>=&plv1. .and. paulDATE<=&plv2.
				PLPERIOD = PLCOUNT
				EXIT
			ENDIF
			PLCOUNT = PLCOUNT + 1
		ENDDO
		IF  .NOT. PLUSED
			USE IN PLPERIODDBF
		ENDIF
		SELECT (PAULSELECT)
		RETURN PLPERIOD
	ENDIF
	RETURN 13
ENDPROC
*------
PROCEDURE ITSTOCKUPDATE
	LPARAMETER PLITEM , PLITEMSEEK , PLITEMKEY , PLDTL , PLDTLSEEK , PLDTLKEY , PLVALUE ,  ;
		PLDTLITEM , PLITEM1 , PLITEM2 , PLITEM3 , PLDTL1 , PLDTL2 , PLDTL3 , PLFLAG ,  ;
		PLPOSTED , PLDOC , PLSHIP , PLCUST , PLSUPP , PLQTYTYPE , PLREP1 ,  ;
		PLWITH1 , PLREP2 , PLWITH2 , PLDOCTYPE , PLTRANBAL
	LOCAL PLSELECTWK , VPLSTOCK
	PLSELECTWK = SELECT()
	IF USED('paulSTOCK_DTL')
		USE IN PAULSTOCK_DTL
	ENDIF
	IF USED('paulSTOCK_ITEM')
		USE IN PAULSTOCK_ITEM
	ENDIF
	PLDTLITEM = 'paulSTOCK_DTL.' + ALLTRIM(PLDTLITEM)
	PLITEMKEY = 'paulSTOCK_ITEM.' + ALLTRIM(PLITEMKEY)
	PLDTLKEY = 'paulSTOCK_DTL.' + ALLTRIM(PLDTLKEY)
	IF USED('tranbalUPDATEx')
		USE IN TRANBALUPDATEX
	ENDIF
	USE IN 0 (PLDTL) AGAIN ALIAS PAULSTOCK_DTL ORDER (PLDTLSEEK)
	USE IN 0 (PLITEM) AGAIN ALIAS PAULSTOCK_ITEM ORDER (PLITEMSEEK)
	IF  .NOT. EMPTY(PLTRANBAL)
		USE IN 0 tranbal AGAIN ALIAS TRANBALUPDATEX ORDER stock_key
	ENDIF
	SET_EXACT = SET('exact')
	SET EXACT ON
	SET DELETED OFF
	PAULCOUNTER = 1
	SELECT PAULSTOCK_DTL
	GO TOP
	SEEK PLVALUE
	DO WHILE MACROS  ???FUN[CA] ("plvalue=&pldtlkey. .and. .not. eof('paulSTOCK_DTL')")
		if upper(alltrim(&pldtlkey.))==alltrim(upper(plvalue))
			WAIT WINDOW NOWAIT '# of record add : ' + STR(PAULCOUNTER)
			PLDTL11 = 0
			PLDTL21 = 0
			PLDTL31 = 0
			IF  .NOT. EMPTY(PLDTL1)
				pldtl11=&pldtl1.
			ENDIF
			IF  .NOT. EMPTY(PLDTL2)
				pldtl21=&pldtl2.
			ENDIF
			IF  .NOT. EMPTY(PLDTL3)
				pldtl31=&pldtl3.
			ENDIF
			SELECT PAULSTOCK_ITEM
			GO TOP
			seek &pldtlitem.
			IF FOUND() AND  .NOT. DELETED() AND  .NOT. DELETED('paulSTOCK_DTL')
				IF  .NOT. EMPTY(PLITEM1) AND AT('DUMMY_QTY',UPPER(PLITEM1)) = 0
					replace &plitem1. with &plitem1.+pldtl11
				ENDIF
				IF  .NOT. EMPTY(PLITEM2) AND AT('DUMMY_QTY',UPPER(PLITEM2)) = 0
					replace &plitem2. with &plitem2.+pldtl21
				ENDIF
				IF  .NOT. EMPTY(PLITEM3) AND AT('DUMMY_QTY',UPPER(PLITEM3)) = 0
					replace &plitem3. with &plitem3.+pldtl31
				ENDIF
				IF  .NOT. EMPTY(PLQTYTYPE) AND  .NOT. DELETED() AND  .NOT. DELETED('paulSTOCK_DTL')
					IF VAL(ALLTRIM(PAULSTOCK_DTL.STOCK_ID)) >= 0 AND  ;
							VAL(ALLTRIM(PAULSTOCK_DTL.STOCK_ID)) <= 9
						VPLSTOCK =  ;
							ALLTRIM(PLQTYTYPE) + ALLTRIM(STR(VAL(ALLTRIM(PAULSTOCK_DTL.STOCK_ID))))
						replace &vplstock. with &vplstock. + pldtl11
					ENDIF
				ENDIF
				REPLACE ADATETIME WITH DATETIME()
				IF  .NOT. EMPTY(PLDOCTYPE) AND PLDOCTYPE = 'SDN'
					IF PAULSTOCK_DTL.UNIT_PRICE <> 0
						REPLACE SDN_COST WITH PAULSTOCK_DTL.UNIT_PRICE * SDNMAST.PUR_EXCHAN
						REPLACE SDN_DATE WITH SDNMAST.SDN_DATE
					ENDIF
				ENDIF
				IF  .NOT. EMPTY(PLDOCTYPE) AND PLDOCTYPE = 'INVOICE'
					IF PAULSTOCK_DTL.UNIT_PRICE <> 0
						REPLACE INV_PRICE WITH PAULSTOCK_DTL.UNIT_PRICE * INVMAST.SAL_EXCHAN
						REPLACE INV_DATE WITH INVMAST.INV_DATE
					ENDIF
				ENDIF
			ENDIF
			SELECT PAULSTOCK_DTL
			IF PLFLAG = 'Y'
				REPLACE ADATETIME WITH DATETIME()
				REPLACE POSTED WITH PLPOSTED
			ENDIF
			IF  .NOT. EMPTY(PLREP1)
				replace &plrep1. with &plwith1.
			ENDIF
			IF  .NOT. EMPTY(PLREP2)
				replace &plrep2. with &plwith2.
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PLTRANBAL)
			SELECT TRANBALUPDATEX
			GO TOP
			SEEK SUBSTR(PAULSTOCK_DTL.STOCK_ID,1,6) + PAULSTOCK_DTL.PRODUCT_ID +  ;
				SUBSTR(PAULSTOCK_DTL.CODE,1,8) + SUBSTR(PAULSTOCK_DTL.SIZE,1,8)
			IF UPPER(ALLTRIM(ALIAS())) = 'TRANBALUPDATEX'
				IF  .NOT. FOUND()
					APPEND BLANK
					REPLACE PRODUCT_ID WITH PAULSTOCK_DTL.PRODUCT_ID
					REPLACE STOCK_ID WITH PAULSTOCK_DTL.STOCK_ID
					REPLACE CODE WITH PAULSTOCK_DTL.CODE
					REPLACE SIZE WITH PAULSTOCK_DTL.SIZE
					REPLACE BRAND WITH PAULSTOCK_ITEM.BRAND
					REPLACE CATEGORY_I WITH PAULSTOCK_ITEM.CATEGORY_ID
					REPLACE GROUP1 WITH PAULSTOCK_ITEM.GROUP1
					REPLACE GROUP2 WITH PAULSTOCK_ITEM.GROUP2
					REPLACE CUSTOMER_I WITH PAULSTOCK_ITEM.CUSTOMER_ID
					REPLACE SUPPLIER_I WITH PAULSTOCK_ITEM.SUPPLIER_ID
					REPLACE DATE WITH DATE()
					REPLACE ADATETIME WITH DATETIME()
					REPLACE PRODUCT_NA WITH PAULSTOCK_DTL.PRODUCT_NAME
					REPLACE CODE WITH PAULSTOCK_DTL.CODE
					REPLACE SIZE WITH PAULSTOCK_DTL.SIZE
					REPLACE MAT_CODE WITH PAULSTOCK_DTL.MAT_CODE
					REPLACE MAT_SIZE WITH PAULSTOCK_DTL.MAT_SIZE
					REPLACE LOT_NO WITH PAULSTOCK_DTL.LOT_NO
					REPLACE BIN_NO WITH PAULSTOCK_DTL.BIN_NO
					REPLACE CTN_UNIT WITH PAULSTOCK_DTL.CTN_UNIT
					REPLACE COMPANY WITH SYS_COMPANYID
				ENDIF
				IF  .NOT. EMPTY(PLITEM1)
					replace &plitem1. with &plitem1.+pldtl11
				ENDIF
				GO TOP
			ENDIF
		ENDIF
		SELECT PAULSTOCK_DTL
		SKIP
		PAULCOUNTER = PAULCOUNTER + 1
	ENDDO
	set exact &set_exact.
	IF USED('paulSTOCK_DTL')
		USE IN PAULSTOCK_DTL
	ENDIF
	IF USED('paulSTOCK_ITEM')
		USE IN PAULSTOCK_ITEM
	ENDIF
	IF USED('tranbalUPDATEx')
		USE IN TRANBALUPDATEX
	ENDIF
	SELECT (PLSELECTWK)
	SET DELETED ON
	WAIT WINDOW NOWAIT ' Job Completed !'
	RETURN
ENDPROC
*------
PROCEDURE IT_DISPLAY
	LPARAMETER PLMODULE , PLDOC_NO , PLKEY , PLIT_DISPLAY
	LOCAL PLDISPLAY
	PLDISPLAY = ''
	IF  .NOT. EMPTY(PLIT_DISPLAY)
		PLDISPLAY = ALLTRIM(PLIT_DISPLAY)
		pldisplay=&pldisplay.
	ENDIF
	IF  .NOT. EMPTY(PLKEY)
		PLDISPLAY =  ;
			ALLTRIM(PLMODULE) + '      ' + ALLTRIM(PLDOC_NO) + ' : ' + PLKEY + '   ' +  ;
			PLDISPLAY
	ELSE
		PLDISPLAY = ALLTRIM(PLMODULE)
	ENDIF
	RETURN PLDISPLAY
ENDPROC
*------
PROCEDURE paulSPACE
	LPARAMETER PLVALUE , PLSUB , PLLEN , PLLEFRIGHT
	LOCAL PLSTRING , PLVALUE , PLSUB , PLLEN , PLLEFRIGHT
	PLSTRING = LEN(ALLTRIM(PLVALUE))
	IF PLSTRING = 0
		RETURN
	ENDIF
	IF PLSTRING >= PLLEN
		PLVALUE = SUBSTR(PLVALUE,1,PLLEN)
	ELSE
		IF  .NOT. EMPTY(PLLEFRIGHT)
			PLVALUE = REPLICATE(PLSUB,PLLEN - PLSTRING) + ALLTRIM(PLVALUE)
		ELSE
			PLVALUE = ALLTRIM(PLVALUE) + REPLICATE(PLSUB,PLLEN - PLSTRING)
		ENDIF
	ENDIF
	RETURN PLVALUE
ENDPROC
*------
PROCEDURE paulACTIVATE
	LPARAMETER PLDBF , PLTOOLBAR , PLFORM , PLSCREEN_KEY , PLYN1 , PLYN2
	IF  .NOT. EMPTY(PLDBF)
		SELECT (PLDBF)
	ENDIF
	IF PLTOOLBAR = 'Y'
		OAPP.OTOOLBAR.REFRESH
	ENDIF
	IF PLFORM = 'Y'
		_SCREEN.ACTIVEFORM.REFRESH
	ENDIF
	RETURN
ENDPROC
*------
PROCEDURE paulStockChk
	LPARAMETER PLHEADER , PLTYPE , PAULVALUE , PLDBF , PLSEEK , PLKEY , PLREP11 , PLWITH12 ,  ;
		PLREP21 , PLWITH22 , PLREP31 , PLWITH32 , PLREP41 , PLWITH42
	IF  .NOT. PAULASK_YN('Do you want to check your stock ?','Ask for stock check ...')
		RETURN
	ENDIF
	LOCAL PAULSELECTWK
	PAULSELECTWK = SELECT()
	KEYCAPTION = PLHEADER
	IF USED('paulSTOCK_DTL')
		USE IN PAULSTOCK_DTL
	ENDIF
	PAULKEY = 'paulSTOCK_DTL.' + ALLTRIM(PLKEY)
	PAULWITH12 = 'paulSTOCK_DTL.' + ALLTRIM(PLWITH12)
	PAULWITH22 = 'paulSTOCK_DTL.' + ALLTRIM(PLWITH22)
	PAULWITH32 = 'paulSTOCK_DTL.' + ALLTRIM(PLWITH32)
	PAULWITH42 = 'paulSTOCK_DTL.' + ALLTRIM(PLWITH42)
	IF USED('qrystock')
		USE IN QRYSTOCK
	ENDIF
	IF USED('qrystockR')
		USE IN QRYSTOCKR
	ENDIF
	use (pldbf) alias paulSTOCK_DTL order &plseek. IN 0 AGAIN
	USE IN 0 EXCLUSIVE qrystock AGAIN
	SELECT QRYSTOCK
	IF UPPER(ALIAS()) = 'QRYSTOCK'
		ZAP
	ENDIF
	SET_EXACT = SET('exact')
	SET EXACT OFF
	PAULCOUNTER = 1
	SELECT PAULSTOCK_DTL
	SEEK PAULVALUE
	DO WHILE MACROS  ;
			???FUN[CA] ("paulVALUE=&paulKEY. .and. .not. eof('paulSTOCK_DTL')")
		if upper(alltrim(&paulKEY.))==alltrim(upper(paulVALUE))
			WAIT WINDOW NOWAIT ' # of record add : ' + STR(PAULCOUNTER)
			SELECT QRYSTOCK
			APPEND BLANK
			IF  .NOT. EMPTY(PLREP11)
				replace &plrep11. with &paulwith12.
			ENDIF
			IF  .NOT. EMPTY(PLREP21)
				replace &plrep21. with &paulwith22.
			ENDIF
			IF  .NOT. EMPTY(PLREP31)
				replace &plrep31. with &paulwith32.
			ENDIF
			IF  .NOT. EMPTY(PLREP41)
				replace &plrep41. with &paulwith42.
			ENDIF
			REPLACE PRODUCT_NA WITH PAULSTOCK_DTL.PRODUCT_NAME
			REPLACE CTN_UNIT WITH PAULSTOCK_DTL.CTN_UNIT
			REPLACE QUANTITY WITH PAULSTOCK_DTL.QUANTITY
		ENDIF
		SELECT PAULSTOCK_DTL
		SKIP
		PAULCOUNTER = PAULCOUNTER + 1
	ENDDO
	set exact &set_exact.
	IF USED('paulSTOCK_DTL')
		USE IN PAULSTOCK_DTL
	ENDIF
	SELECT QRYSTOCK
	IF USED('qrystock')
		USE IN QRYSTOCK
	ENDIF
	IF USED('qrystockR')
		USE IN QRYSTOCKR
	ENDIF
	DO FORM qrystock
	SELECT (PAULSELECTWK)
	RETURN
ENDPROC
*------
PROCEDURE paulDAYS
	LPARAMETER PLDATE
	IF EMPTY(PLDATE)
		RETURN 0
	ENDIF
	VPLCOUNT = 1
	VPYEAR1 = 0
	VPYEAR2 = 0
	VPYEAR = YEAR(PLDATE)
	VPMONTH = MONTH(PLDATE)
	VPDAYS = DAY(PLDATE)
	VPLFLAG = .F.
	DO WHILE VPLCOUNT <= VPYEAR
		IF PAULLEAP(VPLCOUNT) = .T.
			VPYEAR1 = VPYEAR1 + 1
			VPLFLAG = .T.
		ELSE
			VPYEAR2 = VPYEAR2 + 1
			VPLFLAG = .F.
		ENDIF
		VPLCOUNT = VPLCOUNT + 1
	ENDDO
	IF VPLFLAG
		VPYEAR1 = VPYEAR1 - 1
	ELSE
		VPYEAR2 = VPYEAR2 - 1
	ENDIF
	VPLCOUNT = VPMONTH - 1
	DO WHILE VPLCOUNT >= 1
		IF INLIST(VPLCOUNT,1,3,5,7,8,10,12)
			VPDAYS = VPDAYS + 31
		ENDIF
		IF VPLCOUNT = 2 AND VPLFLAG
			VPDAYS = VPDAYS + 29
		ENDIF
		IF VPLCOUNT = 2 AND  .NOT. VPLFLAG
			VPDAYS = VPDAYS + 28
		ENDIF
		IF INLIST(VPLCOUNT,4,6,9,11)
			VPDAYS = VPDAYS + 30
		ENDIF
		VPLCOUNT = VPLCOUNT - 1
	ENDDO
	RETURN VPYEAR1 * 366 + VPYEAR2 * 365 + VPDAYS
ENDPROC
*------
PROCEDURE paulLEAP
	LPARAMETER VPLYEAR
	LOCAL VPLCOUNT1 , VPLYEAR , VPYEAR
	VPLCOUNT1 = VPLYEAR
	VPYEAR = 0
	IF MOD(VPLCOUNT1,100) <> 0
		VPYEAR = MOD(VPLCOUNT1,100)
		IF MOD(VPYEAR,4) = 0
			RETURN .T.
		ELSE
			RETURN .F.
		ENDIF
	ELSE
		VPYEAR = INT(VPLCOUNT1 / 100)
		IF MOD(VPYEAR,4) = 0
			RETURN .T.
		ELSE
			RETURN .F.
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE paulY2K
	LPARAMETER PLDATE
	PAULDATE = PLDATE
	PAMELADATE = DTOC(PAULDATE)
	IF VAL(RIGHT(PAMELADATE,2)) <= 50
		TEMPDATE = VAL(RIGHT(PAMELADATE,2)) + 2000
	ELSE
		TEMPDATE = VAL(RIGHT(PAMELADATE,2)) + 1900
	ENDIF
	PAULDATE = LEFT(PAMELADATE,6) + ALLTRIM(STR(TEMPDATE,4))
	IF YEAR(PLDATE) <= 1990
		RETURN CTOD(PAULDATE)
	ELSE
		RETURN PLDATE
	ENDIF
ENDPROC
*------
PROCEDURE paulADDMEMO
	LPARAMETER PLMEMO , PLID_VALUE , PLTYPE , PLSUBITEM
	LOCAL VPAUL , VCOUNTER , VPLREPL , VPLVAR , VPAULOK
	VPAUL = PLMEMO
	VPAULOK = PLMEMO
	VCOUNTER = AT('[<',VPAUL)
	VLOOPNO = 1
	IF VCOUNTER > 0
		DO WHILE VLOOPNO <= OCCURS('[<',VPAUL)
			VPLVAR =  ;
				SUBSTR(VPAUL,AT('[<',VPAUL,VLOOPNO) + 2,AT('>]',VPAUL,VLOOPNO) - AT('[<',VPAUL,VLOOPNO) - 2)
			VPLREPL =  ;
				SUBSTR(VPAUL,AT('[<',VPAUL,VLOOPNO),AT('>]',VPAUL,VLOOPNO) - AT('[<',VPAUL,VLOOPNO) + 2)
			APPEND_YN = .F.
			VPAULOK = STRTRAN(VPAULOK,VPLREPL,PAULFUNCTION(VPLVAR))
			VLOOPNO = VLOOPNO + 1
		ENDDO
	ENDIF
	RETURN VPAULOK
ENDPROC
*------
PROCEDURE paulRATIO
	LPARAMETER PLMEMO , PLNOOFSNC , PLROUND , PLQUANTITY , PLFIELD , PLDBF
	LOCAL VPAUL , VCOUNTER , VLOOPNO , VPLSNCNO , VPLSNC , VPLVAR , VPLSUM , VPLS1 , VPLS2 ,  ;
		VPLS3 , VPLS4 , VPLS5 , VPLS6 , VPLS7 , VPLS8 , VPLS9 , VPLS10 ,  ;
		VPLS11 , VPLS12 , VPLS13 , VPLS14 , VPLS15 , VPLS16 , VPLS17 , VPLS18
	ON ERROR return .F.
	VPAUL = ALLTRIM(PLMEMO) + ' '
	VPAULOK = PLMEMO
	VCOUNTER = LEN(VPAUL)
	VLOOPNO = 1
	VPLSNCNO = 1
	VPLSNC = ''
	IF VCOUNTER = 0
		RETURN .F.
	ENDIF
	IF  .NOT. EMPTY(PLDBF)
		SELECT (PLDBF)
	ENDIF
	DO WHILE VPLSNCNO <= PLNOOFSNC
		VPLVAR = 'vpls' + ALLTRIM(STR(VPLSNCNO,5))
		&vplvar.=0
		VPLSNCNO = VPLSNCNO + 1
	ENDDO
	VPLSNCNO = 1
	DO WHILE VLOOPNO <= VCOUNTER AND VPLSNCNO <= PLNOOFSNC
		IF ASC(SUBSTR(VPAUL,VLOOPNO,1)) >= 48 AND ASC(SUBSTR(VPAUL,VLOOPNO,1)) <= 57
			VPLSNC = VPLSNC + SUBSTR(VPAUL,VLOOPNO,1)
		ELSE
			VPLVAR = 'vpls' + ALLTRIM(STR(VPLSNCNO,5))
			&vplvar.=val(vplsnc)
			VPLSNCNO = VPLSNCNO + 1
			VPLSNC = ''
		ENDIF
		VLOOPNO = VLOOPNO + 1
	ENDDO
	VPLSUM = 0
	VPLSNCNO = 1
	DO WHILE VPLSNCNO <= PLNOOFSNC
		VPLVAR = 'vpls' + ALLTRIM(STR(VPLSNCNO,5))
		vplsum=vplsum+&vplvar.
		VPLSNCNO = VPLSNCNO + 1
	ENDDO
	IF VPLSUM = 0
		RETURN .F.
	ENDIF
	VPLSNCNO = 1
	DO WHILE VPLSNCNO <= PLNOOFSNC
		VPAUL = PLFIELD + ALLTRIM(STR(VPLSNCNO,5))
		VPLVAR = 'vpls' + ALLTRIM(STR(VPLSNCNO,5))
		if &vpaul.<>0
			replace &vpaul. with 0
		ENDIF
		if &vplvar.<>0
			VCOUNTER = PLQUANTITY
			vcounter=vcounter*&vplvar.
			VCOUNTER = VCOUNTER / VPLSUM
			replace &vpaul. with ROUND(vcounter,plround)
		ENDIF
		VPLSNCNO = VPLSNCNO + 1
	ENDDO
	RETURN .T.
ENDPROC
*------
PROCEDURE paulRATIO2
	LPARAMETER PLMEMO , PLNOOFSNC , PLROUND , PLNTH
	LOCAL VPAUL , VCOUNTER , VLOOPNO , VPLSNCNO , VPLSNC , VPLVAR , VPLS1 , VPLS2 , VPLS3 ,  ;
		VPLS4 , VPLS5 , VPLS6 , VPLS7 , VPLS8 , VPLS9 , VPLS10 , VPLS11 ,  ;
		VPLS12 , VPLS13 , VPLS14 , VPLS15 , VPLS16 , VPLS17 , VPLS18
	VPAUL = ALLTRIM(PLMEMO) + ' '
	VPAULOK = PLMEMO
	VCOUNTER = LEN(VPAUL)
	VLOOPNO = 1
	VPLSNCNO = 1
	VPLSNC = ''
	VPLSUM = 0
	IF VCOUNTER = 0
		RETURN 0
	ENDIF
	ON ERROR return 0
	DO WHILE VPLSNCNO <= PLNOOFSNC
		VPLVAR = 'vpls' + ALLTRIM(STR(VPLSNCNO,5))
		&vplvar.=0
		VPLSNCNO = VPLSNCNO + 1
	ENDDO
	VPLSNCNO = 1
	DO WHILE VLOOPNO <= VCOUNTER AND VPLSNCNO <= PLNOOFSNC
		IF ASC(SUBSTR(VPAUL,VLOOPNO,1)) >= 48 AND ASC(SUBSTR(VPAUL,VLOOPNO,1)) <= 57
			VPLSNC = VPLSNC + SUBSTR(VPAUL,VLOOPNO,1)
		ELSE
			VPLVAR = 'vpls' + ALLTRIM(STR(VPLSNCNO,5))
			&vplvar.=val(vplsnc)
			VPLSNCNO = VPLSNCNO + 1
			VPLSNC = ''
		ENDIF
		VLOOPNO = VLOOPNO + 1
	ENDDO
	VPLSUM = 0
	VPLSNCNO = 1
	DO WHILE VPLSNCNO <= PLNOOFSNC
		VPLVAR = 'vpls' + ALLTRIM(STR(VPLSNCNO,5))
		vplsum=vplsum+&vplvar.
		VPLSNCNO = VPLSNCNO + 1
	ENDDO
	VPLVAR = 'vpls' + ALLTRIM(STR(PLNTH,5))
	return ROUND(&vplvar.,plround)
ENDPROC
*------
PROCEDURE paulCHGGENNO
	LPARAMETER PLDBF , PLKEY , PLINDEX , PLVALUE , PLHEADER , PLNAME , PLREPL
	LOCAL PAULSEEKWK , PAULRETURN , PAULINITVALUE
	ON ERROR return
	PAULSEEKWK = SELECT()
	IF USED('paulGENNODBF')
		USE IN PAULGENNODBF
	ENDIF
	PAULRETURN = .F.
	use (pldbf) alias paulGENNODBF ORDER &plindex. in 0 AGAIN
	SELECT PAULGENNODBF
	SEEK PLVALUE
	IF FOUND()
		APPEND_YN = .F.
		paulinitvalue=&plrepl.
		IF  .NOT. NOCOUNTBACK
			IF PAULINITVALUE > 2
				PAULINITVALUE = PAULINITVALUE - 2
			ENDIF
		ENDIF
		KEY_VALUE =  ;
			PAULGET_VALUE('','',PAULINITVALUE,PLHEADER,PLNAME,'','N','','',1,1,'200')
		IF APPEND_YN
			IF  .NOT. NOCOUNTBACK
				replace &plrepl. with Key_value+2
			ELSE
				replace &plrepl. with Key_value
			ENDIF
			PAULRETURN = .T.
		ELSE
			PAULRETURN = .F.
		ENDIF
	ENDIF
	USE IN PAULGENNODBF
	SELECT (PAULSEEKWK)
	RETURN PAULRETURN
ENDPROC
*------
PROCEDURE iTtransform
	LPARAMETER TKVALUE , TKINDEX , TKDP , TKROUND , TKEXTRADP
	LOCAL TKVALUE , TKINDEX , TKDP , TKROUND , TKHUNDRED , TKEXTRADP
	IF EMPTY(TKEXTRADP)
		TKEXTRADP = 0
	ENDIF
	IF TKROUND = 1
		TKVALUE = ROUND(TKVALUE,TKDP + TKEXTRADP)
	ENDIF
	IF TKROUND = 2
		TKHUNDRED = '1' + REPLICATE('0',TKDP + TKEXTRADP)
		TKHUNDRED = VAL(TKHUNDRED)
		TKVALUE = CEILING(TKVALUE * TKHUNDRED) / TKHUNDRED
	ENDIF
	IF TKROUND = 3
		TKHUNDRED = '1' + REPLICATE('0',TKDP + TKEXTRADP)
		TKHUNDRED = VAL(TKHUNDRED)
		TKVALUE = FLOOR(TKVALUE * TKHUNDRED) / TKHUNDRED
	ENDIF
	IF TKINDEX = 0
		IF INT(TKVALUE) = TKVALUE
			RETURN ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999'))
		ELSE
			RETURN ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999.' + REPLICATE('9',TKDP)))
		ENDIF
	ENDIF
	IF TKINDEX = 1
		IF TKDP = 0
			RETURN ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999'))
		ELSE
			RETURN ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999.' + REPLICATE('9',TKDP)))
		ENDIF
	ENDIF
	IF TKINDEX = 2
		IF TKDP = 0
			RETURN ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999'))
		ELSE
			IF INT(TKVALUE * 10 ** TKDP) = TKVALUE * 10 ** TKDP
				RETURN ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999.' + REPLICATE('9',TKDP)))
			ELSE
				RETURN ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999.' + REPLICATE('9',TKDP + TKEXTRADP)))
			ENDIF
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE iTordering
	LPARAMETER PLDBF , PLINDEX , PLKEY , PLVALUE , PLSCREENKEY , PLSOURCE , PLFIELDNAME , PLADD
	LOCAL PLVSTRING , PLDBF , PLINDEX , PLKEY , PLSELECTWK , PLEXACT , PLNEAR , PLVALUE ,  ;
		PLSCREENKEY , PLSOURCE , PLFIELDNAME
	IF PLVALUE >= 33 AND PLVALUE <= 126
		PLVSTRING = CHR(PLVALUE)
		IF DATETIME() - TDATETIME > 3
			TDATETIME = DATETIME()
			TCHARACTER = UPPER(PLVSTRING)
			PLVSTRING = TCHARACTER
		ELSE
			TCHARACTER = UPPER(TCHARACTER) + PLVSTRING
			PLVSTRING = TCHARACTER
		ENDIF
	ELSE
		RETURN 'N'
	ENDIF
	IF  .NOT. EMPTY(PLADD)
		PLVSTRING = PLADD + PLVSTRING
	ENDIF
	PLSELECTWK = SELECT()
	PLEXACT = SET('EXACT')
	PLNEAR = SET('NEAR')
	IF  .NOT. USED(PLDBF)
		RETURN 'N'
	ENDIF
	IF EOF(PLDBF)
		RETURN 'N'
	ENDIF
	SELECT (PLDBF)
	SET ORDER TO &plindex.
	SET EXACT OFF
	SET NEAR ON
	SEEK UPPER(PLVSTRING)
	SELECT (PLSELECTWK)
	set EXACT &plexact.
	set NEAR &plnear.
	RETURN 'Y'
ENDPROC
*------
PROCEDURE itorginfomation
	LPARAMETER PLDBF , PLALIAS , PLSOURCE , PLVALUE , PLSEEK , PLSCREEN , PLFORM
	LOCAL PLDBF , PLALIAS , PLSOURCE , PLSCREEN , PLFORM , PLSELECT , PLVALUE , PLSEEK ,  ;
		PLFLAG
	PLSELECT = SELECT()
	PLFLAG = .F.
	IF USED(PLALIAS)
		SELECT (PLALIAS)
	ELSE
		use (pldbf) alias (plalias) order &plseek. again in 0
		SELECT (PLALIAS)
		SEEK PLVALUE
		PLFLAG = .T.
	ENDIF
	KEYVALUE1 = PLDBF
	KEYVALUE2 = PLALIAS
	KEYVALUE3 = PLSOURCE
	KEYVALUE4 = PLSCREEN
	KEYVALUE5 = PLSEEK
	KEYVALUE6 = PLSOURCE
	KEYVALUE7 = ALIAS()
	IF EMPTY(PLFORM)
		DO FORM QRYORG
	ELSE
		DO FORM &plform.
	ENDIF
	IF PLFLAG
		USE IN (PLALIAS)
	ENDIF
	SELECT (PLSELECT)
	RETURN .T.
ENDPROC
*------
PROCEDURE itshowphoto
	LPARAMETER PLPHOTO , PLNAME , PLDESC , PLITEMID , PLPRICE , PLCOST , PLBUYUNIT , PLSELLUNIT
	LOCAL PLPHOTO , PLNAME , PLDESC , SELECT_WK6 , REC_NUM2 , PLPRICE , PLCOST , PLBUYUNIT ,  ;
		PLSELLUNIT
	SELECT_WK6 = SELECT()
	REC_NUM2 = RECNO()
	LOCAL APPQRY3
	APPQRY3 = CREATEOBJECT('PHOTO')
	APPQRY3.OLEPHOTO.CONTROLSOURCE = PLPHOTO
	APPQRY3.TXTPRODUCT_NAME.CONTROLSOURCE = PLNAME
	IF  .NOT. EMPTY(PLITEMID)
		APPQRY3.caption= alltrim(APPQRY3.caption)+"      [ "+alltrim(&plitemid.)+" ]  "+alltrim(&plname.)
	ENDIF
	IF  .NOT. EMPTY(PLDESC)
		APPQRY3.TXTDESC.CONTROLSOURCE = PLDESC
		APPQRY3.TXTSHOWDESC = .T.
	ENDIF
	APPQRY3.SHOW()
	SELECT (SELECT_WK6)
	IF  .NOT. EOF()
		GO REC_NUM2
	ENDIF
	RELEASE SELECT_WK6
	RELEASE APPQRY3
	RELEASE REC_NUM2
	RETURN
ENDPROC
*------
PROCEDURE ITROUND
	LPARAMETER TKVALUE , TKDP , TKROUND
	IF EMPTY(TKVALUE)
		RETURN ROUND(0,TKDP)
	ENDIF
	IF EMPTY(TKDP)
		TKDP = 0
	ENDIF
	IF TKVALUE = 0
		RETURN ROUND(0,TKDP)
	ENDIF
	IF TKDP = 0
		IF TKVALUE > 0
			TKVALUE = ROUND(TKVALUE + 1E-7,TKDP)
		ELSE
			TKVALUE = ROUND(TKVALUE - 1E-7,TKDP)
		ENDIF
		RETURN TKVALUE
	ENDIF
	IF EMPTY(TKROUND)
		IF TKVALUE > 0
			TKVALUE = ROUND(TKVALUE + 1E-7,TKDP)
		ELSE
			TKVALUE = ROUND(TKVALUE - 1E-7,TKDP)
		ENDIF
		RETURN TKVALUE
	ENDIF
	IF TKROUND = 1 .OR. TKROUND = 0
		IF TKVALUE > 0
			TKVALUE = ROUND(TKVALUE + 1E-7,TKDP)
		ELSE
			TKVALUE = ROUND(TKVALUE - 1E-7,TKDP)
		ENDIF
	ENDIF
	IF TKROUND = 2
		TKHUNDRED = '1' + REPLICATE('0',TKDP)
		TKHUNDRED = VAL(TKHUNDRED)
		IF INT(TKVALUE * TKHUNDRED) <> ROUND(TKVALUE * TKHUNDRED,4)
			TKVALUE = CEILING(TKVALUE * TKHUNDRED) / TKHUNDRED
		ENDIF
	ENDIF
	IF TKROUND = 3
		TKHUNDRED = '1' + REPLICATE('0',TKDP)
		TKHUNDRED = VAL(TKHUNDRED)
		TKVALUE = FLOOR(TKVALUE * TKHUNDRED) / TKHUNDRED
	ENDIF
	RETURN TKVALUE
ENDPROC
*------
PROCEDURE ITPV
	LPARAMETER VPLVALUE
	LOCAL VPLVALUE
	RETURN VAL(SUBSTR(SYS_PARAMETE,VPLVALUE,1))
ENDPROC
*------
PROCEDURE ITPC
	LPARAMETER VPLVALUE
	LOCAL VPLVALUE
	RETURN SUBSTR(SYS_PARAMETE,VPLVALUE,1)
ENDPROC
*------
PROCEDURE ITALLPOSTED
	LPARAMETER PLPOSTED
	LOCAL PLPOSTED
	IF  .NOT. PLPOSTED
		= MESSAGEBOX('You Cannot Access !',304,'WARNING MESSAGE')
		RETURN .F.
	ELSE
		RETURN .T.
	ENDIF
ENDPROC
*------
PROCEDURE paulDUPLITEMS
	LPARAMETER PDSOURCE , PDPATH , PDINDEX , PDFIELD , PDDATE , PDDATE2 , PDNEWNO , PDININDEX ,  ;
		PDINKEY , PDREPL , PDWITH , PDREPL2 , PDWITH2 , PDREPL3 , PDWITH3 ,  ;
		PDREPL4 , PDWITH4 , POUTSOURCE , PLREPLKEY , PDREPL5 , PDWITH5 ,  ;
		PDREPL6 , PDWITH6 , PDREPL7 , PDWITH7
	LOCAL PAULWORKSEL1
	PAULWORKSEL1 = SELECT()
	SELECT 0
	= PAULOUTDATA(PDSOURCE,PDPATH,PDINDEX,PDFIELD,PDDATE,PDDATE2)
	IF USED(PDPATH)
		USE IN (PDPATH)
	ENDIF
	USE IN 0 (PDPATH) AGAIN
	SELECT (PDPATH)
	IF UPPER(ALLTRIM(PDPATH)) == ALLTRIM(UPPER(ALIAS())) + '.DBF'
		IF EMPTY(PLREPLKEY)
			replace &pDfield. with pdNewNo for .T.
		ENDIF
		IF  .NOT. EMPTY(PDREPL)
			REPLACE &pDrepl. WITH &pDwith. for .T.
		ENDIF
		IF  .NOT. EMPTY(PDREPL2)
			REPLACE &pDrepl2. WITH &pDwith2. for .T.
		ENDIF
		IF  .NOT. EMPTY(PDREPL3)
			REPLACE &pDrepl3. WITH &pDwith3. for .T.
		ENDIF
		IF  .NOT. EMPTY(PDREPL4)
			REPLACE &pDrepl4. WITH &pDwith4. for .T.
		ENDIF
		IF  .NOT. EMPTY(PDREPL5)
			REPLACE &pDrepl5. WITH &pDwith5. for .T.
		ENDIF
		IF  .NOT. EMPTY(PDREPL6)
			REPLACE &pDrepl6. WITH &pDwith6. for .T.
		ENDIF
		IF  .NOT. EMPTY(PDREPL7)
			REPLACE &pDrepl7. WITH &pDwith7. for .T.
		ENDIF
	ENDIF
	USE IN (PDPATH)
	IF EMPTY(POUTSOURCE)
		= PAULINDATA(PDININDEX,PDINKEY,PDSOURCE,PDPATH)
	ELSE
		IF  .NOT. EMPTY(PLREPLKEY)
			IF UPPER(PLREPLKEY) = 'OPEN'
				= PAULINDATA2(PDININDEX,PDINKEY,POUTSOURCE,PDPATH,'','','','','','OPEN')
			ENDIF
		ELSE
			= PAULINDATA(PDININDEX,PDINKEY,POUTSOURCE,PDPATH)
		ENDIF
	ENDIF
	SELECT (PAULWORKSEL1)
ENDPROC
*------
PROCEDURE groupGEN_NO
	LPARAMETER TSGROUPSELECT , TSGROUPVALUE , TSDBF , TSSEEK_VALUE , TSKEY , TSGEN_NO ,  ;
		TSPLUSONE , TSFORMULA , TSMASTER , TSMASTERKEY , TSDOC_NAME , TSRECEXIST_LOC ,  ;
		TSPLUSTWO , TSDBF2 , TSAUTOGEN , TSDOC_RUNNINGNO , TSDOC_RUNNINGFROM
	LOCAL VPLGENDOC_ID , VPLSELECTWK , VPLKEY_VALUE
	VPLSELECTWK = SELECT()
	SELECT 0
	VPLKEY_VALUE =  ;
		PAULGET_VALUE('','',TSGROUPVALUE,SYSDISP_HEADER,SYSDISP_DOCTYPE,'','Y',TSGROUPSELECT,'',2,3,'60')
	IF USED('vplgroupcursor')
		USE IN VPLGROUPCURSOR
	ENDIF
	ID_VALUE3 = VPLKEY_VALUE
	VPLGENDOC_ID = 'NOTGEN'
	TSSEEK_VALUE = TSSEEK_VALUE + ALLTRIM(VPLKEY_VALUE)
	IF ID_VALUE5 <> 'NOQUESTIONASK'
		IF  .NOT. ISGEN_NO(TSDBF,TSSEEK_VALUE,TSKEY,TSGEN_NO,TSPLUSONE,TSFORMULA,TSMASTER,TSMASTERKEY,TSDOC_NAME,TSAUTOGEN,'','',TSDOC_RUNNINGNO,TSDOC_RUNNINGFROM)
			SELECT (VPLSELECTWK)
			RETURN VPLGENDOC_ID
		ENDIF
	ENDIF
	VPLGENDOC_ID =  ;
		TSGEN_NO(TSDBF,TSSEEK_VALUE,TSKEY,TSGEN_NO,TSPLUSONE,TSFORMULA,TSMASTER,TSMASTERKEY,TSRECEXIST_LOC,TSPLUSTWO,TSDBF2,TSAUTOGEN,TSDOC_RUNNINGNO,TSDOC_RUNNINGFROM)
	SELECT (VPLSELECTWK)
	RETURN VPLGENDOC_ID
ENDPROC
*------
PROCEDURE paullrindex
	LPARAMETER PLDELIMITER , PLDEFINDEX , PLINDEX1 , PLINDEX2 , PLINDEX3 , PLINDEX4 , PLINDEX5 ,  ;
		PLINDEX6
	LOCAL PAULCRIT , PLDELIMITER
	PAULCRIT = ALLTRIM(PLDEFINDEX)
	IF '' =  ;
			ALLTRIM(PLDEFINDEX + PLINDEX1 + PLINDEX2 + PLINDEX3 + PLINDEX4 + PLINDEX5 + PLINDEX6)
		RETURN PAULCRIT
	ENDIF
	IF  .NOT. EMPTY(PLINDEX1)
		PAULCRIT = PAULCRIT + PLDELIMITER + ALLTRIM(PLINDEX1)
	ENDIF
	IF  .NOT. EMPTY(PLINDEX2)
		PAULCRIT = PAULCRIT + PLDELIMITER + ALLTRIM(PLINDEX2)
	ENDIF
	IF  .NOT. EMPTY(PLINDEX3)
		PAULCRIT = PAULCRIT + PLDELIMITER + ALLTRIM(PLINDEX3)
	ENDIF
	IF  .NOT. EMPTY(PLINDEX4)
		PAULCRIT = PAULCRIT + PLDELIMITER + ALLTRIM(PLINDEX4)
	ENDIF
	IF  .NOT. EMPTY(PLINDEX5)
		PAULCRIT = PAULCRIT + PLDELIMITER + ALLTRIM(PLINDEX5)
	ENDIF
	IF  .NOT. EMPTY(PLINDEX6)
		PAULCRIT = PAULCRIT + PLDELIMITER + ALLTRIM(PLINDEX6)
	ENDIF
	PAULCRIT = ALLTRIM(PAULCRIT)
	IF SUBSTR(PAULCRIT,1,1) = PLDELIMITER
		PAULCRIT = SUBSTR(ALLTRIM(PAULCRIT),2,200)
	ENDIF
	RETURN PAULCRIT
ENDPROC
*------
PROCEDURE PAULORDERNAME
	LPARAMETER PLTYPE , PLFIRST , PLEMPTY , PLORDER1 , PLORDERNAME1
	LOCAL PAULORDERNAME , PLTYPE , PLFIRST , PLEMPTY , PLORDER1 , PAULORDERFST ,  ;
		PAULORDERSND , PLORDERNAME1
	PAULORDERNAME = ''
	IF '' = ALLTRIM(PLORDER1)
		RETURN ''
	ENDIF
	PLORDER1 = ALLTRIM(PLORDER1)
	PAULORDERFST = PLORDER1
	PAULORDERSND = PLORDERNAME1
	IF '' = ALLTRIM(PLORDERNAME1)
		PAULORDERSND = PLORDER1
	ENDIF
	IF PLTYPE = '1'
		PAULORDERNAME = PAULORDERFST + PLFIRST + PAULORDERSND
	ENDIF
	IF PLTYPE = '2'
		PAULORDERNAME = PAULORDERSND + PLFIRST + PAULORDERFST
	ENDIF
	IF '' <> ALLTRIM(PLEMPTY)
		PAULORDERNAME = PLFIRST + PAULORDERNAME
	ENDIF
	IF PLTYPE = '3'
		PAULORDERNAME = PAULORDERFST
	ENDIF
	RETURN PAULORDERNAME
ENDPROC
*------
PROCEDURE ITVARS
	LPARAMETER PLVAR1 , PLVAR2 , PLSMALLER , PLLARGER , PLFUNCTION
	LOCAL PLVAR1 , PLVAR2 , PLLARGER , PLSMALLER
	ON ERROR RETURN
	IF PLVAR2 >= PLSMALLER AND PLVAR2 <= PLLARGER
		PLVAR1 = PLVAR1 + ALLTRIM(STR(PLVAR2))
		IF  .NOT. EMPTY(PLFUNCTION)
			PLVAR1=&PLVAR1.
		ENDIF
	ELSE
		PLVAR1 = ''
	ENDIF
	RETURN PLVAR1
ENDPROC
*------
PROCEDURE iTTransformCurr
	LPARAMETER TKVALUE , GENDECIMAL
	LOCAL GNLEN , GENDECIMAL , PLTTLSTRING , PLDESCIMAL
	IF TYPE('tkvalue') <> 'N'
		TKVALUE = 0
	ENDIF
	PLDESCIMAL = 4
	PLDESCIMAL = SET('DECIMAL')
	SET DECIMALS TO 10
	PLTTLSTRING = ALLTRIM(TRANSFORM(TKVALUE,'999,999,999,999.99999999999'))
	GNLEN = LEN(PLTTLSTRING)
	DO WHILE SUBSTR(PLTTLSTRING,GNLEN,1) <> '.' .OR. GNLEN = 1
		IF VAL(SUBSTR(PLTTLSTRING,GNLEN,1)) <> 0
			EXIT
		ENDIF
		GNLEN = GNLEN - 1
	ENDDO
	PLTTLSTRING = SUBSTR(PLTTLSTRING,1,GNLEN)
	IF AT('.',PLTTLSTRING,1) <> 0 AND  ;
			((LEN(PLTTLSTRING) - AT('.',PLTTLSTRING,1)) > GENDECIMAL)
		GENDECIMAL = LEN(PLTTLSTRING) - AT('.',PLTTLSTRING,1)
	ENDIF
	IF AT('.',PLTTLSTRING) = 0
		PLTTLSTRING = PLTTLSTRING + '.' + REPLICATE('0',GENDECIMAL)
	ELSE
		PLTTLSTRING =  ;
			PLTTLSTRING + REPLICATE('0',GENDECIMAL - LEN(PLTTLSTRING) + AT('.',PLTTLSTRING,1))
	ENDIF
	IF RIGHT(PLTTLSTRING,1) = '.'
		PLTTLSTRING = SUBSTR(PLTTLSTRING,1,AT('.',PLTTLSTRING) - 1)
	ENDIF
	SET DECIMALS TO PLDESCIMAL
	RETURN PLTTLSTRING
ENDPROC
*------
PROCEDURE ITFUNCTION
	LPARAMETER PLFUNC
	ON ERROR return
	IF EMPTY(PLFUNC)
		RETURN
	ELSE
		&plfunc.
		RETURN
	ENDIF
ENDPROC
*------
PROCEDURE ITENABLED
	LPARAMETER PLTYPE , PLYES , PLFUNC
	LOCAL PLTEMPFIELD
	PAULFUNCTION1 = ''
	PAULFUNCTION2 = ''
	PAULFUNCTION3 = ''
	PAULFUNCTION4 = ''
	IF PLTYPE = '2'
		IF PLYES
			PLTEMPFIELD = 'THISFORM.' + ALLTRIM(PLFUNC) + '.visible=.F.'
			PAULFUNCTION1 = PLTEMPFIELD
			PLTEMPFIELD = 'THISFORM.' + ALLTRIM(PLFUNC) + '.width=0'
			PAULFUNCTION2 = PLTEMPFIELD
			PLTEMPFIELD = 'THISFORM.' + ALLTRIM(PLFUNC) + '.resizable=.F.'
			PAULFUNCTION3 = PLTEMPFIELD
			PLTEMPFIELD = 'THISFORM.' + ALLTRIM(PLFUNC) + '.ENABLED=.F.'
			PAULFUNCTION4 = PLTEMPFIELD
		ENDIF
		RETURN
	ENDIF
	IF PLTYPE = '1'
		if &plyes.
			PLTEMPFIELD = ALLTRIM(PLFUNC) + '.visible=.F.'
			&pltempfield.
		ENDIF
		RETURN
	ENDIF
	IF EMPTY(PLFUNC)
		RETURN
	ELSE
		&plfunc.
		RETURN
	ENDIF
ENDPROC
*------
PROCEDURE ITACCESS
	LPARAMETER PLACCESS
	LOCAL PLACCESS
	IF TRADE_MARK .OR. PLACCESS
		RETURN .T.
	ELSE
		= MESSAGEBOX('You are not allowed to use this function !',304,'WARNING MESSAGE')
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE ITEND_SIZE
	LPARAMETER PLTYPE , PLQTY , PLCTN_QTY
	ON ERROR return
	PLNB_CTNS = 0
	PLENDSIZE = 0
	VNB_CTNS = 0
	VEND_SIZE = 0
	VQTY_SIZE = 0
	IF PLCTN_QTY <> 0
		VQTY_SIZE = MOD(PLQTY,PLCTN_QTY)
	ENDIF
	IF PLTYPE = '1'
		IF PLCTN_QTY <> 0 AND PLCTN_QTY <> 0
			IF PLQTY / PLCTN_QTY <> INT(PLQTY / PLCTN_QTY)
				PLNB_CTNS = INT(PLQTY / PLCTN_QTY)
				PLEND_SIZE = MOD(PLQTY,PLCTN_QTY) + IIF(PLNB_CTNS > 0,PLCTN_QTY,0)
				VNB_CTNS = PLNB_CTNS
				IF VNB_CTNS = 0
					VNB_CTNS = 1
				ENDIF
				VEND_SIZE = PLEND_SIZE
				IF VNB_CTNS > 999999
					VNB_CTNS = 999999
					VEND_SIZE = 999999
				ENDIF
				RETURN VEND_SIZE
			ELSE
				PLNB_CTNS = INT(PLQTY / PLCTN_QTY)
				PLEND_SIZE = MOD(PLQTY,PLCTN_QTY)
				VNB_CTNS = PLNB_CTNS
				VEND_SIZE = PLEND_SIZE
				IF VNB_CTNS > 999999
					VNB_CTNS = 999999
				ENDIF
				RETURN 0
			ENDIF
		ELSE
			RETURN 0
		ENDIF
	ENDIF
	IF PLTYPE = '2'
		IF PLCTN_QTY <> 0 AND PLCTN_QTY <> 0
			IF PLQTY / PLCTN_QTY <> INT(PLQTY / PLCTN_QTY)
				PLNB_CTNS = INT(PLQTY / PLCTN_QTY)
				PLEND_SIZE = MOD(PLQTY,PLCTN_QTY)
				VNB_CTNS = PLNB_CTNS + 1
				VEND_SIZE = PLEND_SIZE
				IF VNB_CTNS > 999999
					VNB_CTNS = 999999
					VEND_SIZE = 999999
				ENDIF
				RETURN VEND_SIZE
			ELSE
				PLNB_CTNS = INT(PLQTY / PLCTN_QTY)
				PLEND_SIZE = MOD(PLQTY,PLCTN_QTY)
				VNB_CTNS = PLNB_CTNS
				VEND_SIZE = PLEND_SIZE
				IF VNB_CTNS > 999999
					VNB_CTNS = 999999
				ENDIF
				RETURN 0
			ENDIF
		ELSE
			RETURN 0
		ENDIF
	ENDIF
	RETURN 0
ENDPROC
*------
PROCEDURE it_sum
	LPARAMETER PLSOURCE , PLORDER , PLFORMULA , PLSEEK , PLTYPE
	IF EMPTY(PLFORMULA)
		RETURN 0
	ENDIF
	IF EMPTY(PLORDER)
		RETURN 0
	ENDIF
	LOCAL LNOLDAREA , LNOLDRECNO , LUKEY , LCFIELDTOSUM , LCORDER , LCCOLUMNSUM
	LNOLDAREA = SELECT()
	LCCOLUMNSUM = 0
	LCFIELDTOSUM = ''
	LCORDER = PLORDER
	IF  .NOT. EMPTY(PLSEEK)
		LUKEY = PLSEEK
	ELSE
		LUKEY = IIF( .NOT. EMPTY(LCORDER),EVALUATE(LCORDER),'')
	ENDIF
	LNOLDRECNO = IIF(EOF(),0,RECNO())
	LCFIELDTOSUM = PLFORMULA
	IF  .NOT. EMPTY(LCORDER) AND SEEK(LUKEY)
		SUM &lcFieldToSum.  WHILE luKey = EVAL(lcOrder)  TO lcColumnSum
	ELSE
		IF PLTYPE = 'CURSOR'
			SUM &lcFieldToSum.  TO lcColumnSum
		ENDIF
	ENDIF
	IF LNOLDRECNO <> 0
		GO LNOLDRECNO
	ENDIF
	SELECT (LNOLDAREA)
	RETURN LCCOLUMNSUM
ENDPROC
*------
PROCEDURE itupdate
	LPARAMETER PLTYPE , PLCRITERA , PLITEM , PLITEMSEEK , PLITEMKEY , PLDTL , PLDTLSEEK ,  ;
		PLDTLKEY , PLVALUE , PLDTLITEM , PLITEM1 , PLDTL1 , PLITEM2 , PLDTL2 ,  ;
		PLITEM3 , PLDTL3 , PLITEM4 , PLDTL4 , PLSOURCE , PLREP1 , PLWITH1 , PLREP2 ,  ;
		PLWITH2 , PLREP3 , PLWITH3
	LOCAL PLSELECTWK , VPLSTOCK
	PLSELECTWK = SELECT()
	SELECT 0
	IF USED('paulSTOCK_DTL')
		USE IN PAULSTOCK_DTL
	ENDIF
	IF USED('paulSTOCK_ITEM')
		USE IN PAULSTOCK_ITEM
	ENDIF
	PLDTLITEM = 'paulSTOCK_DTL.' + ALLTRIM(PLDTLITEM)
	PLITEMKEY = 'paulSTOCK_ITEM.' + ALLTRIM(PLITEMKEY)
	PLDTLKEY = 'paulSTOCK_DTL.' + ALLTRIM(PLDTLKEY)
	USE IN 0 (PLDTL) AGAIN ALIAS PAULSTOCK_DTL ORDER (PLDTLSEEK)
	USE IN 0 (PLITEM) AGAIN ALIAS PAULSTOCK_ITEM ORDER (PLITEMSEEK)
	SET_EXACT = SET('exact')
	SET EXACT ON
	IF UPPER(PLTYPE) = 'ON' .OR. UPPER(PLTYPE) = 'Y'
		SET DELETED ON
	ELSE
		SET DELETED OFF
	ENDIF
	PAULCOUNTER = 1
	SELECT PAULSTOCK_DTL
	SEEK PLVALUE
	DO WHILE MACROS  ???FUN[CA] ("plvalue=&pldtlkey. .and. .not. eof('paulSTOCK_DTL')")
		if upper(alltrim(&pldtlkey.))==alltrim(upper(plvalue))
			SELECT PAULSTOCK_ITEM
			seek &pldtlitem.
			IF FOUND() AND  .NOT. DELETED()
				IF  .NOT. EMPTY(PLITEM1)
					replace &plitem1. with &pldtl1.
				ENDIF
				IF  .NOT. EMPTY(PLITEM2)
					replace &plitem2. with &pldtl2.
				ENDIF
				IF  .NOT. EMPTY(PLITEM3)
					replace &plitem3. with &pldtl3.
				ENDIF
				IF  .NOT. EMPTY(PLITEM4)
					replace &plitem4. with &pldtl4.
				ENDIF
				REPLACE ADATETIME WITH DATETIME()
			ENDIF
			SELECT PAULSTOCK_DTL
			IF  .NOT. EMPTY(PLREP1)
				replace &plrep1. with &plwith1.
			ENDIF
			IF  .NOT. EMPTY(PLREP2)
				replace &plrep2. with &plwith2.
			ENDIF
			IF  .NOT. EMPTY(PLREP3)
				replace &plrep3. with &plwith3.
			ENDIF
			REPLACE ADATETIME WITH DATETIME()
		ENDIF
		SELECT PAULSTOCK_DTL
		SKIP
		PAULCOUNTER = PAULCOUNTER + 1
	ENDDO
	set exact &set_exact.
	IF USED('paulSTOCK_DTL')
		USE IN PAULSTOCK_DTL
	ENDIF
	IF USED('paulSTOCK_ITEM')
		USE IN PAULSTOCK_ITEM
	ENDIF
	SELECT (PLSELECTWK)
	SET DELETED ON
	WAIT WINDOW NOWAIT ' Job Completed !'
	RETURN
ENDPROC
*------
PROCEDURE itallsearch
	LPARAMETER PLDBF , PLVALUE , PLDISP
	LOCAL VPLSELECTED
	VPLSELECTED = SELECT()
	IF USED('itallsearch')
		USE IN ITALLSEARCH
	ENDIF
	use &pldbf. alias itallsearch again in 0
	SELECT ITALLSEARCH
	DO WHILE  .NOT. EOF()
		FOR GNCOUNT = 1 TO FCOUNT()
			PAULFIELD = FIELD(GNCOUNT)
			IF TYPE(FIELD(GNCOUNT)) = 'C'
				paulFIELD_VALUE="Field Name: "+FIELD(gnCount)+"  Value:"+&paulFIELD.
				paulFvalue=&paulFIELD.
				VPLSEARCHABC = (PAULFIELD_VALUE)
				IF AT(UPPER(PLVALUE),UPPER(PAULFVALUE)) > 0
					WAIT WINDOW &pldisp. +"  "+UPPER(VPLSEARCHABC)
					IF MESSAGEBOX('Search Next Record ?',292,'SEARCH AGAIN') = 7
						EXIT
					ENDIF
				ENDIF
			ELSE
				PAULFIELD_VALUE = FIELD(GNCOUNT)
			ENDIF
		ENDFOR
		WAIT WINDOW NOWAIT ' NO OF REC : ' + STR(RECNO())
		SKIP
	ENDDO
	USE IN ITALLSEARCH
	SELECT (VPLSELECTED)
ENDPROC
*------
PROCEDURE ITSYSTEMLOG
	LPARAMETER PLUSER_ID , PLMODULE , PLSUBMODULE , PLDOC_ID , PLNTH_DTL , PLITEM_ID , PLACTION ,  ;
		PLTAKE , PLAPP , PLFIELDNAME
	LOCAL VPLSELECTSYS
	VPLSELECTSYS = SELECT()
	IF USED('ITSYSLOG')
		SELECT ITSYSLOG
	ELSE
		USE IN 0 ITSYSLOG AGAIN
	ENDIF
	SELECT ITSYSLOG
	APPEND BLANK
	IF EMPTY(PLUSER_ID)
		REPLACE USER_ID WITH USERID
	ELSE
		REPLACE USER_ID WITH UPPER(PLUSER_ID)
	ENDIF
	REPLACE MODULE WITH UPPER(PLMODULE)
	REPLACE SUBMODULE WITH UPPER(PLSUBMODULE)
	REPLACE DOC_ID WITH UPPER(PLDOC_ID)
	IF  .NOT. EMPTY(PLNTH_DTL)
		REPLACE NTH_DTL WITH PLNTH_DTL
	ENDIF
	IF  .NOT. EMPTY(PLITEM_ID)
		REPLACE PRODUCT_ID WITH UPPER(PLITEM_ID)
	ENDIF
	REPLACE ACTION WITH PLACTION
	IF  .NOT. EMPTY(PLTAKE)
		REPLACE TAKEACTION WITH PLTAKE
	ENDIF
	IF  .NOT. EMPTY(PLAPP)
		REPLACE APPROVEBY WITH PLAPP
	ENDIF
	IF  .NOT. EMPTY(PLFIELDNAME)
		REPLACE FIELDNAME WITH PLFIELDNAME
	ENDIF
	REPLACE DATETIME WITH DATETIME()
	REPLACE DATE WITH DATE()
	USE IN ITSYSLOG
	SELECT (VPLSELECTSYS)
ENDPROC
*------
PROCEDURE ITUPDATEDATA
	LPARAMETER PAULINDEX , PAULKEY , PAULOLDDBF , PAULNEWDBF , PAULOLDOPEN , PAULNEWOPEN ,  ;
		PAULCONDITION
	SET EXACT ON
	IF EMPTY(PAULCONDITION)
		PAULCONDITION = '.T.'
	ENDIF
	IF EMPTY(PAULOLDOPEN)
		IF USED(PAULOLD)
			USE IN (PAULOLD)
		ENDIF
		PAULOLD = 'paulOLD'
		use &paulOLDDBF. order &paulindex. in 0 alias (paulOLD) again
		= CURSORSETPROP('Buffering',3,(PAULOLD))
	ELSE
		PAULOLD = PAULOLDDBF
		SELECT (PAULOLD)
		set order to &paulindex.
	ENDIF
	IF EMPTY(PAULNEWOPEN)
		IF USED(PAULNEW)
			USE IN (PAULNEW)
		ENDIF
		PAULNEW = 'paulNEW'
		use &paulNEWDBF. in 0 alias (paulNEW) again
	ELSE
		PAULNEW = PAULNEWDBF
	ENDIF
	PAULKEY_VALUE = ''
	CONTINUE_YN = 0
	PAULDELETED = .F.
	FPAULOLDADATETIME = ALLTRIM(PAULOLD) + '.' + 'ADATETIME'
	FPAULNEWADATETIME = ALLTRIM(PAULNEW) + '.' + 'ADATETIME'
	SELECT (PAULNEW)
	GO TOP
	IF EOF()
		IF EMPTY(PAULOLDOPEN)
			IF USED(PAULOLD)
				USE IN (PAULOLD)
			ENDIF
		ENDIF
		IF EMPTY(PAULNEWOPEN)
			IF USED(PAULNEW)
				USE IN (PAULNEW)
			ENDIF
		ENDIF
		WAIT WINDOW NOWAIT 'Update completed !'
		LRPRINT = 999
		SET EXACT OFF
		RETURN .T.
	ENDIF
	LOCAL PAULFIELD , PAULFIELD_VALUE
	SELECT (PAULNEW)
	paulKEY_VALUE=&paulKEY.
	PAULDELETED = DELETED()
	PAULNOREC = 0
	DO WHILE  .NOT. EOF(PAULNEW)
		if &paulcondition.
			SELECT (PAULOLD)
			GO TOP
			SEEK PAULKEY_VALUE
			IF FOUND(PAULOLD)
				CONTINUE_YN = 1
				IF PAULDELETED
					DELETE
				ELSE
				ENDIF
			ELSE
				CONTINUE_YN = 0
				SELECT (PAULOLD)
				APPEND BLANK
			ENDIF
			PAULNOREC = PAULNOREC + 1
			FOR GNCOUNT = 1 TO FCOUNT()
				PAULFIELD = FIELD(GNCOUNT)
				IF TYPE(FIELD(GNCOUNT)) = 'C'
					paulFIELD_VALUE=FIELD(gnCount)+&paulFIELD.
				ELSE
					PAULFIELD_VALUE = FIELD(GNCOUNT)
				ENDIF
				FPAULOLD = ALLTRIM(PAULOLD) + '.' + ALLTRIM(PAULFIELD)
				FPAULNEW = ALLTRIM(PAULNEW) + '.' + LEFT(ALLTRIM(PAULFIELD),10)
				IF UPPER(ALLTRIM(PAULFIELD)) = 'COMPANY_NAME2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'COMPANY_NAME2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'COMPANY_N2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'UNIT_PRICE2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'UNIT_PRIC2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'UNIT_PRICE3'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'UNIT_PRIC3'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE8'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'UNIT_PRICE8'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'UNIT_PRIC4'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_UNIT2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_UNI2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_UNIT3'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_UNI3'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_TERM2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_TER2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM3'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_TERM3'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_TER3'
				ENDIF
				PAULSELECT = .T.
				IF PAULOLDDBF = 'INVMAST' .OR. PAULOLDDBF = 'SDNMAST'
					IF PAULFIELD = 'AR' .OR. PAULFIELD = 'AP' .OR. PAULFIELD = 'A_R_CODE' .OR.  ;
							PAULFIELD = 'A_P_CODE'
						PAULSELECT = .F.
					ENDIF
				ENDIF
				IF TYPE(FPAULNEW) = 'U' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'ADATETIME'
					PAULSELECT = .F.
				ENDIF
				IF CONTINUE_YN=1 .and. &FpaulNEWADATETIME. >&FpaulOLDADATETIME. .AND. paulselect
					REPLACE &FpaulOLD. WITH &FpaulNEW.
				ELSE
					IF CONTINUE_YN=1 .and. &FpaulNEWADATETIME. = &FpaulOLDADATETIME. .AND. paulselect
						IF TYPE(FpaulOLD)="M" .AND. EMPTY(&FpaulOLD.) .AND. !EMPTY(&FpaulNEW.)
							REPLACE &FpaulOLD. WITH &FpaulNEW.
						ENDIF
					ENDIF
				ENDIF
				IF CONTINUE_YN = 0 AND PAULSELECT
					REPLACE &FpaulOLD. WITH &FpaulNEW.
				ENDIF
			ENDFOR
			WAIT WINDOW NOWAIT '# OF RECORD LOADED: ' + ALLTRIM(STR(PAULNOREC,8))
			IF PAULSELECT
				FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'ADATETIME'
				FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'ADATETIME'
				REPLACE &FpaulOLD. WITH &FpaulNEW.
			ENDIF
		ENDIF
		SELECT (PAULNEW)
		SKIP
		PAULDELETED = DELETED()
		paulKEY_VALUE=&paulKEY.
	ENDDO
	SELECT (PAULOLD)
	VPLUPDATEOK = TABLEUPDATE(.T.,.T.)
	IF  .NOT. VPLUPDATEOK
		= TABLEREVERT(.T.)
	ENDIF
	IF EMPTY(PAULOLDOPEN)
		IF USED(PAULOLD)
			USE IN (PAULOLD)
		ENDIF
	ENDIF
	IF EMPTY(PAULNEWOPEN)
		IF USED(PAULNEW)
			USE IN (PAULNEW)
		ENDIF
	ENDIF
	SET EXACT OFF
	RETURN VPLUPDATEOK
ENDPROC
*------
PROCEDURE ITLOADDATA
	LPARAMETER PAULVALUE , PAULINDEX , PAULKEY , PAULOLDDBF , PAULNEWDBF , PAULOLDOPEN ,  ;
		PAULNEWOPEN
	SET EXACT OFF
	SET DELETED ON
	IF EMPTY(PAULOLDOPEN)
		IF USED(PAULOLD)
			USE IN (PAULOLD)
		ENDIF
		PAULOLD = 'paulOLD'
		use &paulOLDDBF. order &paulindex. in 0 alias (paulOLD) again
	ELSE
		PAULOLD = PAULOLDDBF
		SELECT (PAULOLD)
		set order to &paulindex.
	ENDIF
	IF EMPTY(PAULNEWOPEN)
		IF USED(PAULNEW)
			USE IN (PAULNEW)
		ENDIF
		PAULNEW = 'paulNEW'
		use &paulNEWDBF. in 0 alias (paulNEW) again
	ELSE
		PAULNEW = PAULNEWDBF
	ENDIF
	PAULKEY_VALUE = ''
	CONTINUE_YN = 0
	PAULDELETED = .F.
	FPAULOLDADATETIME = ALLTRIM(PAULOLD) + '.' + 'ADATETIME'
	FPAULNEWADATETIME = ALLTRIM(PAULNEW) + '.' + 'ADATETIME'
	SELECT (PAULOLD)
	GO TOP
	SEEK PAULVALUE
	IF  .NOT. FOUND()
		IF EMPTY(PAULOLDOPEN)
			IF USED(PAULOLD)
				USE IN (PAULOLD)
			ENDIF
		ENDIF
		IF EMPTY(PAULNEWOPEN)
			IF USED(PAULNEW)
				USE IN (PAULNEW)
			ENDIF
		ENDIF
		WAIT WINDOW NOWAIT 'Record Not Found !' + PAULVALUE
		LRPRINT = 999
		SET EXACT OFF
		RETURN
	ENDIF
	LOCAL PAULFIELD , PAULFIELD_VALUE
	SELECT (PAULOLD)
	PAULKEY_VALUE = PAULVALUE
	PAULDELETED = DELETED()
	PAULNOREC = 0
	DO WHILE MACROS  ;
			???FUN[CA] ('inkey()<>27  .AND. .NOT. EOF(paulOLD) .AND. &paulKEY.=paulVALUE')
		SELECT (PAULOLD)
		IF ALLTRIM(&paulKEY.)==paulVALUE
			PAULNOREC = PAULNOREC + 1
			CONTINUE_YN = 1
			SELECT (PAULNEW)
			APPEND BLANK
			SELECT (PAULOLD)
			FOR GNCOUNT = 1 TO FCOUNT()
				PAULFIELD = FIELD(GNCOUNT)
				IF TYPE(FIELD(GNCOUNT)) = 'C'
					paulFIELD_VALUE=FIELD(gnCount)+&paulFIELD.
				ELSE
					PAULFIELD_VALUE = FIELD(GNCOUNT)
				ENDIF
				FPAULOLD = ALLTRIM(PAULOLD) + '.' + ALLTRIM(PAULFIELD)
				FPAULNEW = ALLTRIM(PAULNEW) + '.' + LEFT(ALLTRIM(PAULFIELD),10)
				IF UPPER(ALLTRIM(PAULFIELD)) = 'COMPANY_NAME2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'COMPANY_NAME2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'COMPANY_N2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'UNIT_PRICE2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'UNIT_PRIC2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'UNIT_PRICE3'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'UNIT_PRIC3'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE8'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'UNIT_PRICE8'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'UNIT_PRIC4'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_UNIT2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_UNI2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_UNIT3'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_UNI3'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM2'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_TERM2'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_TER2'
				ENDIF
				IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM3'
					FPAULOLD = ALLTRIM(PAULOLD) + '.' + 'PRICE_TERM3'
					FPAULNEW = ALLTRIM(PAULNEW) + '.' + 'PRICE_TER3'
				ENDIF
				PAULSELECT = .T.
				IF PAULOLDDBF = 'INVMAST' .OR. PAULOLDDBF = 'SDNMAST'
					IF PAULFIELD = 'AR' .OR. PAULFIELD = 'AP' .OR. PAULFIELD = 'A_R_CODE' .OR.  ;
							PAULFIELD = 'A_P_CODE'
						PAULSELECT = .F.
					ENDIF
				ENDIF
				IF TYPE(FPAULNEW) = 'U' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'ADATETIME'
					PAULSELECT = .F.
				ENDIF
				SELECT (PAULNEW)
				IF CONTINUE_YN = 1 AND PAULSELECT
					REPLACE &FpaulNEW. WITH &FpaulOLD.
				ELSE
					IF CONTINUE_YN = 1 AND PAULSELECT
						IF TYPE(FpaulOLD)="M" .AND. EMPTY(&FpaulOLD.) .AND. !EMPTY(&FpaulNEW.)
							REPLACE &FpaulNEW. WITH &FpaulOLD.
						ENDIF
					ENDIF
				ENDIF
				IF CONTINUE_YN = 0 AND PAULSELECT
					REPLACE &FpaulNEW. WITH &FpaulOLD.
				ENDIF
				SELECT (PAULOLD)
			ENDFOR
			WAIT WINDOW NOWAIT '# OF RECORD LOADED: ' + ALLTRIM(STR(PAULNOREC,8))
		ENDIF
		SELECT (PAULOLD)
		SKIP
		PAULDELETED = DELETED()
		paulKEY_VALUE=&paulKEY.
	ENDDO
	IF EMPTY(PAULOLDOPEN)
		IF USED(PAULOLD)
			USE IN (PAULOLD)
		ENDIF
	ENDIF
	IF EMPTY(PAULNEWOPEN)
		IF USED(PAULNEW)
			USE IN (PAULNEW)
		ENDIF
	ENDIF
	SET EXACT OFF
	RETURN
ENDPROC
*------
PROCEDURE itCODE_39
	LPARAMETER PAULBARCODE_VALUE , PLCHK
	LOCAL BARCODE_VALUE , SELECT_CODE39 , PAULFIELD_NAME , PAULCHARS
	SELECT_CODE39 = SELECT()
	BARCODE_VALUE = ALLTRIM(PAULBARCODE_VALUE)
	IF LEN(BARCODE_VALUE) = 0
		RETURN ''
	ENDIF
	PAULFIELD_NAME = ''
	IF  .NOT. USED('BARCODE')
		USE IN 0 BARCODE ORDER TYPE
	ENDIF
	PAULSEEK_YNBAR = SEEK('CODE-39','BARCODE','TYPE')
	IND = 1
	PAULFIELD_NAME = '*'
	DO WHILE IND <= LEN(BARCODE_VALUE)
		PAULCHARS = SUBSTR(BARCODE_VALUE,IND,1)
		IF ASC(PAULCHARS) <= 128
			PAULA_N = 'BARCODE.A_' + ALLTRIM(STR(ASC(PAULCHARS),4))
			paulFIELD_NAME=paulFIELD_NAME+ALLTRIM(&paulA_N.)
		ENDIF
		IND = IND + 1
	ENDDO
	PAULFIELD_NAME = PAULFIELD_NAME + '*'
	SELECT (SELECT_CODE39)
	RETURN PAULFIELD_NAME
ENDPROC
*------
PROCEDURE ITWEBACCESS
	LPARAMETER PLTYPE , PLACCESS , PLCC , PLBCC , PLSUBJECT , PLBODY
	DECLARE INTEGER ShellExecute IN shell32.dll INTEGER , STRING , STRING , STRING , STRING ,  ;
		INTEGER
	IF UPPER(PLTYPE) = 'EMAIL' AND  ;
			(AT('@',PLACCESS) > 0 .OR. AT('@',PLCC) > 0 .OR. AT('@',PLBCC) > 0)
		PLSUBACCESS = ''
		IF  .NOT. EMPTY(PLCC)
			PLSUBACCESS = '?CC=' + PLCC
		ENDIF
		IF  .NOT. EMPTY(PLBCC)
			IF  .NOT. EMPTY(PLSUBACCESS)
				plsubaccess=plsubaccess+"&BCC="+plbcc
			ELSE
				PLSUBACCESS = '?BCC=' + PLBCC
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PLSUBJECT)
			IF  .NOT. EMPTY(PLSUBACCESS)
				plsubaccess=plsubaccess+"&Subject= "+plsubject
			ELSE
				PLSUBACCESS = '?Subject= ' + PLSUBJECT
			ENDIF
		ENDIF
		IF  .NOT. EMPTY(PLBODY)
			IF  .NOT. EMPTY(PLSUBACCESS)
				plsubaccess=plsubaccess+"&Body= "+plbody
			ELSE
				PLSUBACCESS = '?Body= ' + PLBODY
			ENDIF
		ENDIF
		PLACCESS = 'mailto:' + PLACCESS + PLSUBACCESS
		SHELLEXECUTE(0,'open',PLACCESS,'','',1)
		RETURN
	ENDIF
	IF UPPER(PLTYPE) = 'HTTP' AND AT('.',PLACCESS) > 0
		IF AT('http://',LOWER(PLACCESS)) = 0
			PLACCESS = 'http://' + PLACCESS
		ENDIF
		SHELLEXECUTE(0,'open',PLACCESS,'','',1)
		RETURN
	ENDIF
	IF UPPER(PLTYPE) = 'ALL' AND  .NOT. EMPTY(PLACCESS)
		SHELLEXECUTE(0,'open',PLACCESS,'','',1)
		RETURN
	ENDIF
ENDPROC
*------
PROCEDURE itcalendar
	LPARAMETER VPLTHISDAY
	ITDATEVALUE = DATE()
	IF VARTYPE(VPLTHISDAY) = 'D' .OR. VARTYPE(VPLTHISDAY) = 'T'
		APPEND_YN = .F.
		IF EMPTY(VPLTHISDAY)
			IF VARTYPE(VPLTHISDAY) = 'T'
				ITDATEVALUE = DATETIME()
			ELSE
				ITDATEVALUE = DATE()
			ENDIF
		ELSE
			ITDATEVALUE = VPLTHISDAY
		ENDIF
		OAPP.DOFORM('calendar')
		IF APPEND_YN
			RETURN ITDATEVALUE
		ELSE
			RETURN VPLTHISDAY
		ENDIF
	ELSE
		RETURN DATE()
	ENDIF
ENDPROC
*------
PROCEDURE itRETURN
	LPARAMETER PLEXISTDBF , PLDBF1 , PLSEEK1 , PLKEY1 , PLID1 , PLRKEY1 , PLINIT , PLDELIMITER ,  ;
		PLTYPE , PLCONDITION
	LOCAL PLSEEKWK , PLSETEXACT , PLCOUNTER , PLVALUE
	ON ERROR return
	PLSEEKWK = SELECT()
	PLSETEXACT = SET('exact')
	PLCOUNTER = 0
	PLVALUE = PLINIT
	SET EXACT ON
	IF PLEXISTDBF = 'Y'
		PLALIAS1 = PLDBF1
		select &plalias1.
	ELSE
		PLALIAS1 = 'plalias1'
		use &pldbf1. alias &plalias1. order &plseek1. AGAIN IN 0
	ENDIF
	IF EMPTY(PLCONDITION)
		PLCONDITION = '.T.'
	ENDIF
	SELECT &plalias1.
	set order to &plseek1.
	GO TOP
	SEEK PLID1
	IF FOUND()
		PLCOUNTER = 1
		DO WHILE MACROS  ???FUN[CA] ('.NOT. EOF() .AND. plid1=&plkey1.')
			if plid1=&plkey1.  .and. &plcondition.
				IF  .NOT. EMPTY(PLDELIMITER) .OR.  .NOT. EMPTY(PLTYPE)
					IF PLCOUNTER > 1
						IF  .NOT. EMPTY(PLTYPE)
							IF PLTYPE = 'SKIPEMPTY'
								if empty(&plrkey1.)
								ELSE
									PLVALUE = PLVALUE + PLDELIMITER
								ENDIF
							ELSE
								PLVALUE = PLVALUE + PLDELIMITER
							ENDIF
						ELSE
							PLVALUE = PLVALUE + PLDELIMITER
						ENDIF
					ENDIF
				ENDIF
				plvalue=plvalue+&plrkey1.
			ENDIF
			SKIP
			PLCOUNTER = PLCOUNTER + 1
		ENDDO
	ELSE
		PLVALUE = PLINIT
	ENDIF
	IF PLEXISTDBF = 'Y'
		SELECT &plalias1.
	ELSE
		USE IN &plalias1.
	ENDIF
	IF  .NOT. EMPTY(PLSEEKWK)
		SELECT (PLSEEKWK)
	ENDIF
	SET EXACT  &plsetexact.
	RETURN PLVALUE
ENDPROC
*------
PROCEDURE ITADDDESCLINE
	LPARAMETER PLMEMO , PLINENO , PLHEADER
	LOCAL VPAUL , VCOUNTER , VPLREPL , VPLVAR , VPAULOK
	IF EMPTY(PLHEADER)
		PLHEADER = ''
	ELSE
		IF VARTYPE(PLHEADER) = 'N'
			PLHEADER = ALLTRIM(STR(PLHEADER))
		ELSE
			PLHEADER = ALLTRIM(PLHEADER)
		ENDIF
	ENDIF
	VPAUL = PLMEMO
	VPLSAMPLE = '[<LINE' + PLHEADER + RIGHT('00' + ALLTRIM(STR(PLINENO,2)),2) + '>]'
	VCOUNTER = AT(VPLSAMPLE,VPAUL)
	VPLVAR = ''
	VLOOPNO = 1
	IF VCOUNTER > 0
		VPLVAR =  ;
			SUBSTR(VPAUL,AT(VPLSAMPLE,VPAUL,VLOOPNO) + 10 + LEN(PLHEADER),AT(VPLSAMPLE,VPAUL,VLOOPNO + 1) - AT(VPLSAMPLE,VPAUL,VLOOPNO) - 10 - LEN(PLHEADER))
		VLOOPNO = VLOOPNO + 1
	ENDIF
	RETURN VPLVAR
ENDPROC
*------
PROCEDURE itcookie
	LPARAMETER PLKEY , PLFIELD , PLSEQ , PLTYPE , PLRETURNFIELD , PLFIELDVAL , PLDBF , PLLANG
	LOCAL PLSELECTITMSG , PLITMSG , PLITLANG
	IF  .NOT. FILE('itcookie.dbf')
		RETURN
	ENDIF
	SET TALK OFF
	PLITMSG = ''
	PLSELECTITMSG = SELECT()
	SELECT 0
	PLITLANG = DEF_LANG
	IF  .NOT. EMPTY(PLLANG)
		PLITLANG = PLLANG
	ENDIF
	IF  .NOT. USED('itcookie')
		IF FILE('itcookie.dbf')
			USE IN 0 itcookie AGAIN ORDER id
		ELSE
			USE IN 0 (GCOLDDIR + 'include\itcookie') AGAIN ALIAS ITCOOKIE ORDER id
		ENDIF
	ELSE
		SELECT ITCOOKIE
		SET ORDER TO id
	ENDIF
	SELECT ITCOOKIE
	GO TOP
	SEEK UPPER(SUBSTR(UPPER(PLKEY + SPACE(10)),1,10) + SUBSTR(PLFIELD + SPACE(20),1,20) +  ;
		SUBSTR(PLSEQ + SPACE(3),1,3))
	IF PLTYPE = 'RETURN' AND  .NOT. EMPTY(PLRETURNFIELD)
		plitmsg=&plreturnfield.
		SELECT (PLSELECTITMSG)
		RETURN PLITMSG
	ENDIF
	IF PLTYPE = 'GOTO' AND FOUND('itcookie')
		PLBEGINREC = ITCOOKIE.RECNO
		SELECT (PLDBF)
		IF PLBEGINREC <= RECCOUNT() AND PLBEGINREC <> 0
			GO PLBEGINREC
			IF DELETED(PLDBF)
				GO TOP
			ENDIF
		ENDIF
	ENDIF
	IF PLTYPE = 'SAVE'
		SELECT ITCOOKIE
		IF FOUND('itcookie')
			IF  .NOT. EMPTY(PLRETURNFIELD)
				replace &plreturnfield. with plfieldval
				REPLACE ITCOOKIE.DATETIME WITH DATETIME()
			ENDIF
		ELSE
			SELECT ITCOOKIE
			IF ALLTRIM(UPPER(ALIAS())) = 'ITCOOKIE'
				APPEND BLANK
			ENDIF
			REPLACE ITCOOKIE.DATETIME WITH DATETIME()
			IF  .NOT. EMPTY(PLRETURNFIELD)
				replace &plreturnfield. with plfieldval
			ENDIF
			IF  .NOT. EMPTY(PLFIELD)
				REPLACE FIELD WITH UPPER(PLFIELD)
			ENDIF
			IF  .NOT. EMPTY(PLSEQ)
				REPLACE SEQUENCE WITH UPPER(PLSEQ)
			ENDIF
			IF  .NOT. EMPTY(PLKEY)
				REPLACE SCREEN_ID WITH UPPER(PLKEY)
			ENDIF
			IF  .NOT. EMPTY(PLITLANG)
				REPLACE LANGUAGE WITH PLITLANG
			ENDIF
		ENDIF
	ENDIF
	SELECT (PLSELECTITMSG)
	RETURN ' '
ENDPROC
*------
PROCEDURE ITGENDOCNO
	LPARAMETER PLDBF , PLKEY , PLKEYPREFIX , PLKEYSURFIX , PLLENGTH , PLRUNNO , PLMESSAGE
	IF PLLENGTH = 0
		PLLENGTH = 4
	ENDIF
	IF PLRUNNO = 0
		PLRUNNO = 1
	ENDIF
	PLDOCNO = ''
	SET_DELETE = SET('delete')
	SET_EXACT = SET('exact')
	SELECT_ALIAS = ALIAS()
	SET DELETED OFF
	SET EXACT ON
	IF USED('paulGENKEYDBF')
		USE IN PAULGENKEYDBF
	ENDIF
	use (pldbf) alias paulGENKEYDBF order &plkey. in 0 again
	SELECT PAULGENKEYDBF
	GO TOP
	PLDOCNO =  ;
		PLKEYPREFIX + RIGHT('000000000' + ALLTRIM(STR(PLRUNNO,10)),PLLENGTH) + PLKEYSURFIX
	DO WHILE  .NOT. EOF()
		PLDOCNO =  ;
			PLKEYPREFIX + RIGHT('000000000' + ALLTRIM(STR(PLRUNNO,10)),PLLENGTH) + PLKEYSURFIX
		SEEK PLDOCNO
		PLRUNNO = PLRUNNO + 1
	ENDDO
	IF USED('paulGENKEYDBF')
		USE IN PAULGENKEYDBF
	ENDIF
	set delete &set_delete.
	set exact  &set_exact.
	IF  .NOT. EMPTY(SELECT_ALIAS)
		SELECT (SELECT_ALIAS)
	ENDIF
	RETURN PLDOCNO
ENDPROC
*------
PROCEDURE error_process
	PARAMETER LHANDLER , LMESSAGE , LPOSITION , LLINE , LPROCODE
	ERROR_YN = .T.
	DO CASE
		CASE LHANDLER = 109 .OR. LHANDLER = 108
			IF CURSORGETPROP('BUFFERING') > 1
				= TABLEREVERT()
			ENDIF
			IF DEF_LANG = 'CHS'
				= MESSAGEBOX('!' + CHR(13) + CHR(13) + '!',48,'')
			ELSE
				= MESSAGEBOX('Other user is editing this record !' + CHR(13) + CHR(13) +  ;
					'This process will be cancelled!',48,'ERROR MESSAGE')
			ENDIF
		CASE LHANDLER = 1884
			IF CURSORGETPROP('BUFFERING') > 1
				= TABLEREVERT()
			ENDIF
			IF DEF_LANG = 'CHS'
				= MESSAGEBOX('!' + CHR(13) + CHR(13) + '!',48,'')
			ELSE
				= MESSAGEBOX('This primary key already exists !' + CHR(13) + CHR(13) +  ;
					'This process will be cancelled!',48,'ERROR MESSAGE')
			ENDIF
		CASE LHANDLER = 1585
			IF CURSORGETPROP('BUFFERING') > 1
				= TABLEREVERT()
			ENDIF
			IF DEF_LANG = 'CHS'
				= MESSAGEBOX('!' + CHR(13) + CHR(13) + '!',48,'')
			ELSE
				= MESSAGEBOX('Other user is editing this record !' + CHR(13) + CHR(13) +  ;
					'This process will be cancelled!',48,'ERROR MESSAGE')
			ENDIF
		CASE LHANDLER = 1582 .OR. LHANDLER = 1502 .OR. LHANDLER = 1539
			IF CURSORGETPROP('BUFFERING') > 1
				= TABLEREVERT()
			ENDIF
		CASE LHANDLER = 1104
			IF CURSORGETPROP('BUFFERING') > 1
				= TABLEREVERT()
			ENDIF
			IF DEF_LANG = 'CHS'
				= MESSAGEBOX('!',16,'')
			ELSE
				= MESSAGEBOX('Data reading error due to networking problem or harddisk reading failure !' +  ;
					CHR(13) +  ;
					CHR(13) +  ;
					'System will be shutdown!',48,'ERROR MESSAGE')
			ENDIF
			= ONSHUTDOWN()
		CASE LHANDLER = 2005 .OR. LHANDLER = 1705
			IF DEF_LANG = 'CHS'
				= MESSAGEBOX('2005/1705: ' + LTRIM(STR(LHANDLER,5)) + CHR(13) + ': ' + LMESSAGE +  ;
					CHR(13) +  ;
					'' +  ;
					LPROCODE +  ;
					CHR(13) +  ;
					CHR(13) +  ;
					': ' +  ;
					LPOSITION +  ;
					'(' +  ;
					LTRIM(STR(LLINE,4)) +  ;
					')' +  ;
					CHR(13) +  ;
					'erritm:',48,'')
			ELSE
				= MESSAGEBOX('Error code 2005/1705: ' + LTRIM(STR(LHANDLER,5)) + CHR(13) + 'Reason: ' + LMESSAGE +  ;
					CHR(13) +  ;
					'Error code:' +  ;
					LPROCODE +  ;
					CHR(13) +  ;
					CHR(13) +  ;
					'Line number :' +  ;
					LPOSITION +  ;
					'(' +  ;
					LTRIM(STR(LLINE,4)) +  ;
					')' +  ;
					CHR(13) +  ;
					'erritm:',48,'ERROR MESSAGE')
			ENDIF
		OTHERWISE
			IF DEF_LANG = 'CHS'
				= MESSAGEBOX(': ' + LTRIM(STR(LHANDLER,5)) + CHR(13) + ': ' + LMESSAGE + CHR(13) +  ;
					'' +  ;
					LPROCODE +  ;
					CHR(13) +  ;
					CHR(13) +  ;
					': ' +  ;
					LPOSITION +  ;
					'(' +  ;
					LTRIM(STR(LLINE,4)) +  ;
					')' +  ;
					CHR(13) +  ;
					'erritm:',48,'')
			ELSE
				= MESSAGEBOX('Error code: ' + LTRIM(STR(LHANDLER,5)) + CHR(13) + 'Reason: ' + LMESSAGE + CHR(13) +  ;
					'Error code:' +  ;
					LPROCODE +  ;
					CHR(13) +  ;
					CHR(13) +  ;
					'Line number :' +  ;
					LPOSITION +  ;
					'(' +  ;
					LTRIM(STR(LLINE,4)) +  ;
					')' +  ;
					CHR(13) +  ;
					'erritm:',48,'ERROR MESSAGE')
			ENDIF
	ENDCASE
	_ISERROR = .T.
	RETURN
ENDPROC
*------
PROCEDURE cn_amt
	PARAMETER LNUM , LDEF_LANG
	IF EMPTY(LDEF_LANG)
		LDEF_LANG = 'CHS'
	ENDIF
	IF DEF_LANG = 'CHI' .OR. DEF_LANG = 'CHS'
		LDEF_LANG = DEF_LANG
	ENDIF
	IF LDEF_LANG = 'CHS'
		LOCAL LBIGNUM , LDW , INILEN , I , J , K
		DIMENSION LBIGNUM( 12 ) , LDW( 11 )
		LBIGNUM( 1 ) = ''
		LBIGNUM( 2 ) = ''
		LBIGNUM( 3 ) = ''
		LBIGNUM( 4 ) = ''
		LBIGNUM( 5 ) = ''
		LBIGNUM( 6 ) = ''
		LBIGNUM( 7 ) = ''
		LBIGNUM( 8 ) = ''
		LBIGNUM( 9 ) = ''
		LBIGNUM( 10 ) = ''
		LBIGNUM( 11 ) = ''
		LDW( 1 ) = ''
		LDW( 2 ) = ''
		LDW( 3 ) = ''
		LDW( 4 ) = ''
		LDW( 5 ) = ''
		LDW( 6 ) = ''
		LDW( 7 ) = ''
		LDW( 8 ) = ''
		LDW( 9 ) = ''
		LDW( 10 ) = ''
		LDW( 11 ) = ''
		IF LNUM = 0
			RETURN ''
		ENDIF
		LNUM = ITROUND(LNUM,2)
		LOUTSTR = ''
		INTLEN = ATC('.',ALLTRIM(STR(LNUM,20,2))) - 1
		FOR I = 1 TO INTLEN
			K = SUBSTR(ALLTRIM(STR(LNUM,20,2)),I,1)
			IF K = '0'
				J = 11
			ELSE
				J = VAL(K)
			ENDIF
			IF I = INTLEN
				IF K = '0'
					IF RIGHT(LOUTSTR,2) = ''
						LOUTSTR = SUBSTR(LOUTSTR,1,LEN(LOUTSTR) - 2)
					ENDIF
					IF INT(LNUM) = LNUM
						LOUTSTR = LOUTSTR + ''
					ENDIF
				ELSE
					IF INT(LNUM) = LNUM
						LOUTSTR = LOUTSTR + LBIGNUM(J) + ''
					ELSE
						LOUTSTR = LOUTSTR + LBIGNUM(J)
					ENDIF
				ENDIF
			ELSE
				IF K <> '0'
					LOUTSTR = LOUTSTR + LBIGNUM(J) + LDW(INTLEN - I)
				ELSE
					IF RIGHT(LOUTSTR,2) <> ''
						LOUTSTR = LOUTSTR + ''
					ENDIF
					IF INTLEN - I = 8
						LOUTSTR = SUBSTR(LOUTSTR,1,LEN(LOUTSTR) - 2) + ''
					ENDIF
					IF INTLEN - I = 4
						IF RIGHT(LOUTSTR,4) <> ''
							LOUTSTR = SUBSTR(LOUTSTR,1,LEN(LOUTSTR) - 2) + ''
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDFOR
		IF INT(LNUM) <> LNUM
			LOUTSTR = LOUTSTR + ''
			FOR I = 1 TO 2
				K = SUBSTR(ALLTRIM(STR(LNUM,20,4)),INTLEN + 1 + I,1)
				IF K = '0'
					J = 11
				ELSE
					J = VAL(K)
				ENDIF
				IF I = 1
					IF K <> '0'
						LOUTSTR = LOUTSTR + LBIGNUM(J) + ''
					ELSE
						LOUTSTR = LOUTSTR + LBIGNUM(J)
					ENDIF
				ELSE
					IF K <> '0'
						LOUTSTR = LOUTSTR + LBIGNUM(J) + ''
					ENDIF
				ENDIF
			ENDFOR
		ENDIF
		IF LEFT(LOUTSTR,2) = ''
			LOUTSTR = SUBSTR(LOUTSTR,3)
		ENDIF
		RETURN LOUTSTR
	ENDIF
	IF LDEF_LANG = 'CHI'
		LOCAL LBIGNUM , LDW , INILEN , I , J , K
		DIMENSION LBIGNUM( 12 ) , LDW( 11 )
		LBIGNUM( 1 ) = ''
		LBIGNUM( 2 ) = 'L'
		LBIGNUM( 3 ) = 'T'
		LBIGNUM( 4 ) = 'v'
		LBIGNUM( 5 ) = ''
		LBIGNUM( 6 ) = ''
		LBIGNUM( 7 ) = 'm'
		LBIGNUM( 8 ) = ''
		LBIGNUM( 9 ) = 'h'
		LBIGNUM( 10 ) = 'B'
		LBIGNUM( 11 ) = 's'
		LDW( 1 ) = 'B'
		LDW( 2 ) = ''
		LDW( 3 ) = 'a'
		LDW( 4 ) = 'U'
		LDW( 5 ) = 'B'
		LDW( 6 ) = ''
		LDW( 7 ) = 'a'
		LDW( 8 ) = ''
		LDW( 9 ) = 'B'
		LDW( 10 ) = ''
		LDW( 11 ) = 'a'
		IF LNUM = 0
			RETURN 's'
		ENDIF
		LNUM = ITROUND(LNUM,2)
		LOUTSTR = ''
		INTLEN = ATC('.',ALLTRIM(STR(LNUM,20,2))) - 1
		FOR I = 1 TO INTLEN
			K = SUBSTR(ALLTRIM(STR(LNUM,20,2)),I,1)
			IF K = '0'
				J = 11
			ELSE
				J = VAL(K)
			ENDIF
			IF I = INTLEN
				IF K = '0'
					IF RIGHT(LOUTSTR,2) = 's'
						LOUTSTR = SUBSTR(LOUTSTR,1,LEN(LOUTSTR) - 2)
					ENDIF
					IF INT(LNUM) = LNUM
						LOUTSTR = LOUTSTR + ''
					ENDIF
				ELSE
					IF INT(LNUM) = LNUM
						LOUTSTR = LOUTSTR + LBIGNUM(J) + ''
					ELSE
						LOUTSTR = LOUTSTR + LBIGNUM(J)
					ENDIF
				ENDIF
			ELSE
				IF K <> '0'
					LOUTSTR = LOUTSTR + LBIGNUM(J) + LDW(INTLEN - I)
				ELSE
					IF RIGHT(LOUTSTR,2) <> 's'
						LOUTSTR = LOUTSTR + 's'
					ENDIF
					IF INTLEN - I = 8
						LOUTSTR = SUBSTR(LOUTSTR,1,LEN(LOUTSTR) - 2) + ''
					ENDIF
					IF INTLEN - I = 4
						IF RIGHT(LOUTSTR,4) <> 's'
							LOUTSTR = SUBSTR(LOUTSTR,1,LEN(LOUTSTR) - 2) + 'U'
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDFOR
		IF INT(LNUM) <> LNUM
			LOUTSTR = LOUTSTR + ''
			FOR I = 1 TO 2
				K = SUBSTR(ALLTRIM(STR(LNUM,20,4)),INTLEN + 1 + I,1)
				IF K = '0'
					J = 11
				ELSE
					J = VAL(K)
				ENDIF
				IF I = 1
					IF K <> '0'
						LOUTSTR = LOUTSTR + LBIGNUM(J) + ''
					ELSE
						LOUTSTR = LOUTSTR + LBIGNUM(J)
					ENDIF
				ELSE
					IF K <> '0'
						LOUTSTR = LOUTSTR + LBIGNUM(J) + ''
					ENDIF
				ENDIF
			ENDFOR
		ENDIF
		IF LEFT(LOUTSTR,2) = ''
			LOUTSTR = SUBSTR(LOUTSTR,3)
		ENDIF
		RETURN LOUTSTR
	ENDIF
ENDPROC
*------
PROCEDURE ITRETAILPRICE
	LPARAMETER PLALIAS , PLTYPE , PLDATE , PLUNIT_PRICE
	VDISCOUNT = 0
	VRT_PRICE = 0
	IF PLTYPE = '1'
		VARFROM_DATE = ALLTRIM(PLALIAS) + '.FROM_DATE'
		VARTO_DATE = ALLTRIM(PLALIAS) + '.TO_DATE'
		VARRT_PRICE = ALLTRIM(PLALIAS) + '.RT_PRICE'
		VARDISCOUNT = ALLTRIM(PLALIAS) + '.DISCOUNT'
		IF pldate>=&VARFROM_DATE. .AND. pldate<=&VARTO_DATE. .AND. &VARRT_PRICE.<>0
			VDISCOUNT=&VARDISCOUNT.
			VRT_PRICE=&VARRT_PRICE.
		ENDIF
		VARFROM_DATE = ALLTRIM(PLALIAS) + '.FROM_DATE2'
		VARTO_DATE = ALLTRIM(PLALIAS) + '.TO_DATE2'
		VARRT_PRICE = ALLTRIM(PLALIAS) + '.RT_PRICE2'
		VARDISCOUNT = ALLTRIM(PLALIAS) + '.DISCOUNT2'
		IF pldate>=&VARFROM_DATE. .AND. pldate<=&VARTO_DATE. .AND. &VARRT_PRICE.<>0
			VDISCOUNT=&VARDISCOUNT.
			VRT_PRICE=&VARRT_PRICE.
		ENDIF
		VARFROM_DATE = ALLTRIM(PLALIAS) + '.FROM_DATE3'
		VARTO_DATE = ALLTRIM(PLALIAS) + '.TO_DATE3'
		VARRT_PRICE = ALLTRIM(PLALIAS) + '.RT_PRICE3'
		VARDISCOUNT = ALLTRIM(PLALIAS) + '.DISCOUNT3'
		IF pldate>=&VARFROM_DATE. .AND. pldate<=&VARTO_DATE. .AND. &VARRT_PRICE.<>0
			VDISCOUNT=&VARDISCOUNT.
			VRT_PRICE=&VARRT_PRICE.
		ENDIF
	ENDIF
	IF PLTYPE = '2'
		VARFROM_DATE = ALLTRIM(PLALIAS) + '.DATE_FM'
		VARTO_DATE = ALLTRIM(PLALIAS) + '.DATE_TO'
		VARRT_PRICE = ALLTRIM(PLALIAS) + '.RT_PRICE'
		VARDISCOUNT = ALLTRIM(PLALIAS) + '.DISCOUNT'
		IF pldate>=&VARFROM_DATE. .AND. pldate<=&VARTO_DATE. .AND. &VARRT_PRICE.<>0
			VDISCOUNT=&VARDISCOUNT.
			VRT_PRICE=&VARRT_PRICE.
		ENDIF
		VARFROM_DATE = ALLTRIM(PLALIAS) + '.DATE_FM2'
		VARTO_DATE = ALLTRIM(PLALIAS) + '.DATE_TO2'
		VARRT_PRICE = ALLTRIM(PLALIAS) + '.RT_PRICE2'
		VARDISCOUNT = ALLTRIM(PLALIAS) + '.DISCOUNT2'
		IF pldate>=&VARFROM_DATE. .AND. pldate<=&VARTO_DATE. .AND. &VARRT_PRICE.<>0
			VDISCOUNT=&VARDISCOUNT.
			VRT_PRICE=&VARRT_PRICE.
		ENDIF
		VARFROM_DATE = ALLTRIM(PLALIAS) + '.DATE_FM3'
		VARTO_DATE = ALLTRIM(PLALIAS) + '.DATE_TO3'
		VARRT_PRICE = ALLTRIM(PLALIAS) + '.RT_PRICE3'
		VARDISCOUNT = ALLTRIM(PLALIAS) + '.DISCOUNT3'
		IF pldate>=&VARFROM_DATE. .AND. pldate<=&VARTO_DATE. .AND. &VARRT_PRICE.<>0
			VDISCOUNT=&VARDISCOUNT.
			VRT_PRICE=&VARRT_PRICE.
		ENDIF
	ENDIF
	IF VRT_PRICE = 0
		VRT_PRICE = PLUNIT_PRICE
	ENDIF
	RETURN VRT_PRICE
ENDPROC
*------
PROCEDURE ITDBFACCESS
	LPARAMETER ITGRPTYPE , ITGRPVAR , ITGRPACCESS
	IF TRADE_MARK .OR. SUBSTR(SECURITY_ID,1,5) == 'SUPER' .OR.  ;
			SUBSTR(SECURITY_ID,1,3) == 'BOS' .OR. SUBSTR(SECURITY_ID,1,5) = 'ADMIN'
		RETURN .T.
	ELSE
		IF ITGRPTYPE = 'SUPERVISOR'
			RETURN .T.
		ENDIF
		IF itgrptype="USER" .and. &itgrpvar.=USERID
			RETURN .T.
		ENDIF
		IF itgrptype="DEPARTMENT" .and. (&itgrpvar.=USERDEPART .OR. T1=USERDEPART .OR. T2=USERDEPART .OR. T3=USERDEPART .OR. T4=USERDEPART .OR. T5=USERDEPART .OR. T6=USERDEPART)
			IF VARTYPE(CREATOR) = 'C'
				IF CREATOR = USERID
					RETURN .T.
				ENDIF
			ENDIF
			RETURN .T.
		ENDIF
		IF ITGRPTYPE = 'SECGROUP'
			itgrpvar=&itgrpvar.
			IF RTRIM(SECURITY_ID) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID2) AND RTRIM(SECURITY_ID2) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID3) AND RTRIM(SECURITY_ID3) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID4) AND RTRIM(SECURITY_ID4) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID5) AND RTRIM(SECURITY_ID5) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID6) AND RTRIM(SECURITY_ID6) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID7) AND RTRIM(SECURITY_ID7) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID8) AND RTRIM(SECURITY_ID8) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID9) AND RTRIM(SECURITY_ID9) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF  .NOT. EMPTY(SECURITY_ID10) AND RTRIM(SECURITY_ID10) = ITGRPVAR
				RETURN .T.
			ENDIF
			IF VARTYPE(CREATOR) = 'C'
				IF CREATOR = USERID
					RETURN .T.
				ENDIF
			ENDIF
			RETURN .F.
		ENDIF
		IF ITGRPTYPE = 'CUSTOMER'
			LOCAL VPLSELECTWORK , VPLRETURN
			VPLSELECTWORK = SELECT()
			VPLRETURN = .T.
			itgrpvar=&itgrpvar.
			IF  .NOT. USED('SEC_CUSTQRY')
				USE IN 0 SEC_CUST AGAIN ALIAS SEC_CUSTQRY
			ENDIF
			SELECT SEC_CUSTQRY
			SET ORDER TO SEC_CUST
			GO TOP
			SEEK SECURITY_ID + ITGRPVAR
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID2 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID3 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID4 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID5 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID6 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID7 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID8 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID9 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				GO TOP
				SEEK SECURITY_ID10 + ITGRPVAR
			ENDIF
			IF  .NOT. FOUND()
				VPLRETURN = .F.
			ENDIF
			IF  .NOT. EMPTY(ITGRPACCESS)
				vplreturn=&itgrpaccess.
			ENDIF
			SELECT (VPLSELECTWORK)
			IF VARTYPE(CREATOR) = 'C'
				IF CREATOR = USERID
					VPLRETURN = .T.
				ENDIF
			ENDIF
			RETURN VPLRETURN
		ENDIF
		IF ITGRPTYPE = 'GROUP'
			LOCAL VPLSELECTWORK , VPLRETURN
			VPLSELECTWORK = SELECT()
			VPLRETURN = .T.
			itgrpvar=&itgrpvar.
			IF  .NOT. USED('SEC_DEPTQRY')
				USE IN 0 SEC_DEPT AGAIN ALIAS SEC_DEPTQRY
			ENDIF
			SELECT SEC_DEPTQRY
			SET ORDER TO SEC_DEPT
			GO TOP
			SEEK SUBSTR(SECURITY_ID + ITGRPVAR,1,13)
			IF  .NOT. FOUND()
				VPLRETURN = .F.
			ENDIF
			IF  .NOT. EMPTY(ITGRPACCESS)
				vplreturn=&itgrpaccess.
			ENDIF
			SELECT (VPLSELECTWORK)
			IF VARTYPE(CREATOR) = 'C'
				IF CREATOR = USERID
					VPLRETURN = .T.
				ENDIF
			ENDIF
			RETURN VPLRETURN
		ENDIF
		IF ITGRPTYPE = 'CATEGORY'
			LOCAL VPLSELECTWORK , VPLRETURN
			VPLSELECTWORK = SELECT()
			VPLRETURN = .T.
			itgrpvar=&itgrpvar.
			IF  .NOT. USED('SEC_PRODQRY')
				USE IN 0 SEC_PROD AGAIN ALIAS SEC_PRODQRY
			ENDIF
			SELECT SEC_PRODQRY
			SET ORDER TO SEC_CAT
			GO TOP
			SEEK SECURITY_ID + '          ' + ITGRPVAR
			IF  .NOT. FOUND()
				VPLRETURN = .F.
			ENDIF
			IF  .NOT. EMPTY(ITGRPACCESS)
				vplreturn=&itgrpaccess.
			ENDIF
			SELECT (VPLSELECTWORK)
			IF VARTYPE(CREATOR) = 'C'
				IF CREATOR = USERID
					VPLRETURN = .T.
				ENDIF
			ENDIF
			RETURN VPLRETURN
		ENDIF
		RETURN .F.
	ENDIF
ENDPROC
*------
PROCEDURE repotitle
	LPARAMETER PLN
	LOCAL PLN
	IF EMPTY(PLN)
		IF DEF_LANG = 'ENG'
			RETURN SYS_REPORTNAME
		ENDIF
		IF EMPTY(SYS_CHSREPORTNAME) AND EMPTY(SYS_CHIREPORTNAME)
			RETURN SYS_REPORTNAME
		ENDIF
		IF DEF_LANG = 'CHS'
			IF EMPTY(SYS_CHSREPORTNAME)
				RETURN SYS_CHIREPORTNAME
			ELSE
				RETURN SYS_CHSREPORTNAME
			ENDIF
		ENDIF
		IF DEF_LANG = 'CHI'
			IF EMPTY(SYS_CHIREPORTNAME)
				RETURN SYS_CHSREPORTNAME
			ELSE
				RETURN SYS_CHIREPORTNAME
			ENDIF
		ENDIF
	ENDIF
	IF PLN = 1
		RETURN SYS_REPORTNAME
	ENDIF
	IF PLN = 2
		IF EMPTY(SYS_CHSREPORTNAME) AND EMPTY(SYS_CHIREPORTNAME)
			RETURN SYS_REPORTNAME
		ENDIF
		RETURN SYS_CHSREPORTNAME
	ENDIF
	IF PLN = 3
		IF EMPTY(SYS_CHSREPORTNAME) AND EMPTY(SYS_CHIREPORTNAME)
			RETURN SYS_REPORTNAME
		ENDIF
		RETURN SYS_CHIREPORTNAME
	ENDIF
ENDPROC
*------
PROCEDURE hz2py
	PARAMETER FROMSTR , NDXX
	FROMSTR = IIF( .NOT. TYPE('fromstr') = 'C','',FROMSTR)
	NDXX = IIF(TYPE('ndxx') = 'N' .AND. NDXX = 2,2,1)
	POSCHAR = 1
	RETSTR = ''
	HZK = ''
	PYK = 'abcdefghjklmnopqrstwxyz'
	DO WHILE POSCHAR <= LEN(FROMSTR)
		IF ASC(SUBSTR(FROMSTR,POSCHAR,1)) < 176
			RETSTR =  ;
				RETSTR +  ;
				IIF(ASC(SUBSTR(FROMSTR,POSCHAR,1)) >= 32 .AND. ASC(SUBSTR(FROMSTR,POSCHAR,1)) <= 127,SUBSTR(FROMSTR,POSCHAR,1),' ')
			POSCHAR = POSCHAR + 1
		ELSE
			TEMP1 = SUBSTR(FROMSTR,POSCHAR,2)
			POSCHAR = POSCHAR + 2
			POSCHAR2 = 1
			DO WHILE POSCHAR2 <= 45 AND TEMP1 >= SUBSTR(HZK,POSCHAR2,2)
				POSCHAR2 = POSCHAR2 + 2
			ENDDO
			RETSTR = RETSTR + SUBSTR(PYK,(POSCHAR2 - 1) / 2,1)
		ENDIF
	ENDDO
	RETSTR = IIF(NDXX = 1,UPPER(RETSTR),RETSTR)
	RETURN RETSTR
ENDPROC
*------
PROCEDURE ITCOPYTEMP
	LPARAMETER PLNEWINCL , PLTEMPFILE
	LOCAL VPLSETSAFETY
	VPLSETSAFETY = SET('safety')
	SET SAFETY OFF
	ON ERROR return
	PLLOCALDIR = ALLTRIM(SET('directory')) + '\include'
	IF LOWER(PLNEWINCL) <> LOWER(PLLOCALDIR)
		IF AT('INCLUDE',UPPER(PLNEWINCL)) > 0 .OR. AT('NEWINCL',UPPER(PLNEWINCL)) > 0 .OR.  ;
				AT('TEMPDBF',UPPER(PLNEWINCL)) > 0
			PLNEWINCL = PLNEWINCL + PLTEMPFILE
			IF FILE(PLNEWINCL) AND DIRECTORY(PLLOCALDIR)
				copy file &plnewincl. to  &pllocaldir.
			ENDIF
		ENDIF
		set safety &vplsetsafety.
	ENDIF
ENDPROC
*------
PROCEDURE ITLANGTRAN
	LPARAMETER VPLFIELDNAME , VPLSTRAN
	IF AT('=',VPLFIELDNAME) = 0
		RETURN VPLFIELDNAME
	ENDIF
	VPLFIELDNAME = ALLTRIM(VPLFIELDNAME)
	IF AT('=',VPLFIELDNAME) > 0
		VPLFIELDNAME = ALLTRIM(SUBSTR(ALLTRIM(VPLFIELDNAME),2,200))
		IF EMPTY(VPLSTRAN)
			return &vplfieldname.
		ELSE
			return alltrim(strtran(&vplfieldname.,vplstran,""))
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE encryptpsd
	LPARAMETER LPASS
	LPASS = ALLTRIM(LPASS)
	IF EMPTY(LPASS)
		RETURN
	ENDIF
	IF SUBSTR(LPASS,1,2) = '<<'
		LPASS = SUBSTR(LPASS,3,20)
	ENDIF
	IF SUBSTR(LPASS,1,2) = '<<'
		LPASS = SUBSTR(LPASS,3,20)
	ENDIF
	LPASS = ALLTRIM(LPASS)
	LOCAL LPASSLEN , LRESULT , LNUM , LTMP
	LPASSLEN = LEN(LPASS)
	LRESULT = ''
	FOR LNUM = 1 TO LPASSLEN
		LTMP = ASC(SUBSTR(LPASS,LNUM,1))
		LRESULT = LRESULT + CHR(LTMP + LNUM)
	ENDFOR
	LRESULT = '<<' + LRESULT
	RETURN LRESULT
ENDPROC
*------
PROCEDURE unencryptpsd
	LPARAMETER LPASS
	LPASS = ALLTRIM(LPASS)
	IF EMPTY(LPASS)
		RETURN ''
	ENDIF
	IF SUBSTR(LPASS,1,2) <> '<<'
		RETURN LPASS
	ENDIF
	IF SUBSTR(LPASS,1,2) = '<<'
		LPASS = SUBSTR(LPASS,3,20)
	ENDIF
	IF SUBSTR(LPASS,1,2) = '<<'
		LPASS = SUBSTR(LPASS,3,20)
	ENDIF
	LOCAL LPASSLEN , LNUM , LRESULT , LTMP
	LRESULT = ''
	LPASSLEN = LEN(LPASS)
	FOR LNUM = 1 TO LPASSLEN
		LTMP = ASC(SUBSTR(LPASS,LNUM,1))
		LRESULT = LRESULT + CHR(LTMP - LNUM)
	ENDFOR
	RETURN LRESULT
ENDPROC
*------
PROCEDURE ITGARSIZECOLOR
	LPARAMETER VPLGAR , VPLLENG , VPLDELIMITER , VPLDBF , VPLSEEK , VPLRETURN , VPLNTH
	PLDBFSELECT = SELECT()
	IF EMPTY(VPLGAR)
		RETURN ''
	ENDIF
	IF EMPTY(VPLDELIMITER)
		VPLDELIMITER = ','
	ENDIF
	PLCOUNTER = 0
	PLRETURN = ''
	IF USED('ITGARTABLE')
		USE IN ITGARTABLE
	ENDIF
	IF  .NOT. EMPTY(VPLDBF)
		USE IN 0 (VPLDBF) AGAIN ALIAS ITGARTABLE ORDER (VPLSEEK)
	ENDIF
	DO WHILE PLCOUNTER <= 15
		PLGAR = ALLTRIM(SUBSTR(VPLGAR,1 + VPLLENG * PLCOUNTER,VPLLENG))
		IF  .NOT. EMPTY(VPLDBF) AND  .NOT. EMPTY(VPLRETURN) AND  .NOT. EMPTY(PLGAR)
			SELECT ITGARTABLE
			GO TOP
			SEEK PLGAR
			IF FOUND()
				PLGAR=&VPLRETURN.
			ENDIF
		ENDIF
		PLRETURN =  ;
			PLRETURN + IIF( .NOT. EMPTY(PLGAR) .AND.  .NOT. EMPTY(PLRETURN),VPLDELIMITER,'') +  ;
			PLGAR
		PLCOUNTER = PLCOUNTER + 1
		IF  .NOT. EMPTY(VPLNTH)
			IF PLCOUNTER = VPLNTH
				PLRETURN = PLGAR
				EXIT
			ENDIF
		ENDIF
	ENDDO
	IF USED('ITGARTABLE')
		USE IN ITGARTABLE
	ENDIF
	SELECT (PLDBFSELECT)
	RETURN PLRETURN
ENDPROC
*------
PROCEDURE ITADDMENUS
	LPARAMETER VPLVAR
	LOCAL LNBAR , LCFRMNAME
	VPLVAR = CHRTRAN(VPLVAR,CHR(13),'')
	VPLVAR = CHRTRAN(VPLVAR,CHR(10),'')
	VPLVAR = ALLTRIM(VPLVAR)
	LCFRMNAME = ITGETFRMNAME(VPLVAR)
	IF  .NOT. EMPTY(LCFRMNAME)
		IF TYPE('oApp') == 'O'
			IF CNTBAR('Window') = 0 .OR. GETBAR('Window',CNTBAR('Window')) < 0
				LNBAR = CNTBAR('Window') + 1
			ELSE
				LNBAR = GETBAR('Window',CNTBAR('Window')) + 1
			ENDIF
			DEFINE BAR LNBAR OF WINDOW PROMPT ALLTRIM(VPLVAR) AFTER  _MLAST
			On SELECTION BAR lnbar OF Window ACTIVATE Window &lcFrmName
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE ITgetFrmName
	LPARAMETER TCCAPTION
	LOCAL LCFRMNAME
	LCFRMNAME = ''
	LOCAL LNCNT , LNTOTAL , LCCAPTION
	LNTOTAL = _SCREEN.FORMCOUNT
	FOR LNCNT = 1 TO LNTOTAL
		LCCAPTION = _SCREEN.FORMS(LNCNT).CAPTION
		LCFRMNAME = _SCREEN.FORMS(LNCNT).NAME
		IF ATC(TCCAPTION,LCCAPTION) > 0 AND UPPER(ALLTRIM(LCFRMNAME)) <> 'FRMREPORTS' AND  ;
				UPPER(ALLTRIM(LCFRMNAME)) <> 'FRMMODIFY'
			LCFRMNAME = _SCREEN.FORMS(LNCNT).NAME
			EXIT
		ENDIF
	ENDFOR
	RETURN LCFRMNAME
ENDPROC
*------
PROCEDURE ITGCOLOR
	LPARAMETER VPLGAR , VPLRETURN
	PLDBFSELECT = SELECT()
	PLOPENDBF = .F.
	IF EMPTY(VPLGAR)
		RETURN ''
	ENDIF
	IF USED('COLORRR')
		PLOPENDBF = .T.
	ELSE
		USE IN 0 COLOR AGAIN ALIAS COLORRR ORDER CODE
	ENDIF
	PLRETURN = ''
	SELECT COLORRR
	GO TOP
	SEEK VPLGAR
	IF FOUND()
		PLRETURN=&VPLRETURN.
	ENDIF
	IF  .NOT. PLOPENDBF
		USE IN COLORRR
	ENDIF
	SELECT (PLDBFSELECT)
	RETURN PLRETURN
ENDPROC
*------
PROCEDURE ITGSIZE
	LPARAMETER VPLGAR , VPLRETURN
	PLDBFSELECT = SELECT()
	PLOPENDBF = .F.
	IF EMPTY(VPLGAR)
		RETURN ''
	ENDIF
	IF USED('SIZERR')
		PLOPENDBF = .T.
	ELSE
		USE IN 0 SIZE AGAIN ALIAS SIZERR ORDER CODE
	ENDIF
	PLRETURN = ''
	SELECT SIZERR
	GO TOP
	SEEK VPLGAR
	IF FOUND()
		PLRETURN=&VPLRETURN.
	ENDIF
	IF  .NOT. PLOPENDBF
		USE IN SIZERR
	ENDIF
	SELECT (PLDBFSELECT)
	RETURN PLRETURN
ENDPROC
*------
PROCEDURE iTR
	LPARAMETER TKVALUE
	LOCAL GNLEN , PLTTLSTRING , PLDESCIMAL , GENDECIMAL
	IF TYPE('tkvalue') <> 'N'
		TKVALUE = 0
	ENDIF
	PLDESCIMAL = SET('DECIMAL')
	SET DECIMALS TO 11
	PLTTLSTRING = ALLTRIM(TRANSFORM(TKVALUE,'999999999999.99999999999'))
	GNLEN = LEN(PLTTLSTRING)
	DO WHILE SUBSTR(PLTTLSTRING,GNLEN,1) <> '.' .OR. GNLEN = 1
		IF VAL(SUBSTR(PLTTLSTRING,GNLEN,1)) <> 0
			EXIT
		ENDIF
		GNLEN = GNLEN - 1
	ENDDO
	PLTTLSTRING = SUBSTR(PLTTLSTRING,1,GNLEN)
	GENDECIMAL = 0
	IF AT('.',PLTTLSTRING,1) <> 0 AND  ;
			((LEN(PLTTLSTRING) - AT('.',PLTTLSTRING,1)) > GENDECIMAL)
		GENDECIMAL = LEN(PLTTLSTRING) - AT('.',PLTTLSTRING,1)
	ENDIF
	SET DECIMALS TO PLDESCIMAL
	RETURN ROUND(TKVALUE,GENDECIMAL)
ENDPROC
*------
PROCEDURE ITGETPHOTOPATH
	LPARAMETER PLFILENAME , PLDEFAULT , PLNOPHOTO
	LOCAL PLFULLPATH
	IF EMPTY(PLDEFAULT)
		PLDEFAULT = ''
	ENDIF
	IF EMPTY(PLNOPHOTO)
		PLNOPHOTO = ''
	ENDIF
	IF EMPTY(PLFILENAME)
		IF  .NOT. EMPTY(PLNOPHOTO)
			PLFULLPATH = ALLTRIM(SET_PATH) + PLNOPHOTO
			RETURN PLFULLPATH
		ENDIF
		RETURN ''
	ENDIF
	PLFILENAME = ALLTRIM(PLFILENAME)
	IF  .NOT. EMPTY(PLDEFAULT) AND AT('\',PLFILENAME) = 0
		PLFULLPATH = ALLTRIM(SET_PATH) + PLDEFAULT + '\' + PLFILENAME
		IF AT(' ',PLFULLPATH) > 0
		ENDIF
		IF  .NOT. FILE(PLFULLPATH) AND AT('\',PLFILENAME) = 0
			PLFULLPATH = ALLTRIM(SET_PATH) + 'bitmaps\' + PLFILENAME
			IF AT(' ',PLFULLPATH) > 0
			ENDIF
		ENDIF
	ELSE
		PLFULLPATH =  ;
			IIF(AT('\',PLFILENAME) > 0,PLFILENAME,ALLTRIM(SET_PHOTOS) + PLFILENAME)
		IF AT(' ',PLFULLPATH) > 0
		ENDIF
		IF  .NOT. FILE(PLFULLPATH) AND AT('\',PLFILENAME) = 0
			PLFULLPATH = ALLTRIM(SET_PATH) + 'bitmaps\' + PLFILENAME
			IF AT(' ',PLFULLPATH) > 0
			ENDIF
		ENDIF
	ENDIF
	IF  .NOT. FILE(PLFULLPATH)
		PLFILENAME = ALLTRIM(PLNOPHOTO)
		IF  .NOT. EMPTY(PLDEFAULT) AND AT('\',PLFILENAME) = 0
			PLFULLPATH = ALLTRIM(SET_PATH) + PLDEFAULT + '\' + PLFILENAME
			IF AT(' ',PLFULLPATH) > 0
			ENDIF
			IF  .NOT. FILE(PLFULLPATH) AND AT('\',PLFILENAME) = 0
				PLFULLPATH = ALLTRIM(SET_PATH) + 'bitmaps\' + PLFILENAME
				IF AT(' ',PLFULLPATH) > 0
				ENDIF
			ENDIF
		ELSE
			PLFULLPATH =  ;
				IIF(AT('\',PLFILENAME) > 0,PLFILENAME,ALLTRIM(SET_PHOTOS) + PLFILENAME)
			IF AT(' ',PLFULLPATH) > 0
			ENDIF
			IF  .NOT. FILE(PLFULLPATH) AND AT('\',PLFILENAME) = 0
				PLFULLPATH = ALLTRIM(SET_PATH) + 'bitmaps\' + PLFILENAME
				IF AT(' ',PLFULLPATH) > 0
				ENDIF
			ENDIF
		ENDIF
	ENDIF
	IF  .NOT. FILE(PLFULLPATH)
		PLFULLPATH = ''
	ENDIF
	RETURN PLFULLPATH
ENDPROC
*------
PROCEDURE paulINDATAREPLACE
	LPARAMETER PAULINDEX , PAULKEY , PAULOLDDBF , PAULNEWDBF , PLEX1 , PLEX2 , PLEX3 , PLEX4 ,  ;
		PLEX5
	SET EXACT ON
	IF USED('paulOLD')
		USE IN PAULOLD
	ENDIF
	IF USED('paulNEW')
		USE IN PAULNEW
	ENDIF
	PAULKEY_VALUE = ''
	PAULINCONDITION = ''
	CONTINUE_YN = 0
	PAULDELETED = .F.
	SET DELETED OFF
	IF  .NOT. EMPTY(PLEX1) AND  ;
			(AT('<',PLEX1) > 0 .OR. AT('>',PLEX1) > 0 .OR. AT('=',PLEX1) > 0)
		PAULINCONDITION = PLEX1
		PLEX1 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX2) AND  ;
			(AT('<',PLEX2) > 0 .OR. AT('>',PLEX2) > 0 .OR. AT('=',PLEX2) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX2
		PLEX2 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX3) AND  ;
			(AT('<',PLEX3) > 0 .OR. AT('>',PLEX3) > 0 .OR. AT('=',PLEX3) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX3
		PLEX3 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX4) AND  ;
			(AT('<',PLEX4) > 0 .OR. AT('>',PLEX4) > 0 .OR. AT('=',PLEX4) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX4
		PLEX4 = ''
	ENDIF
	IF  .NOT. EMPTY(PLEX5) AND  ;
			(AT('<',PLEX5) > 0 .OR. AT('>',PLEX5) > 0 .OR. AT('=',PLEX5) > 0)
		PAULINCONDITION =  ;
			PAULINCONDITION + IIF( .NOT. EMPTY(PAULINCONDITION),' .and. ','') + PLEX5
		PLEX5 = ''
	ENDIF
	use &paulOLDDBF. order &paulindex. in 0 alias paulOLD again
	= CURSORSETPROP('Buffering',3,'PAULOLD')
	PAUL_JPSO = PAULNEWDBF
	IF  .NOT. FILE(PAUL_JPSO)
		WAIT WINDOW TIMEOUT 5 PAUL_JPSO + ' NOT FOUND !'
		USE IN PAULOLD
		SET EXACT OFF
		SET DELETED ON
		RETURN
	ENDIF
	use &paul_jpso. alias paulNew in 0
	SELECT PAULNEW
	IF  .NOT. EMPTY(PAULINCONDITION)
		GO TOP
		set filter to &paulincondition.
	ENDIF
	GO TOP
	IF EOF()
		USE IN PAULNEW
		USE IN PAULOLD
		WAIT WINDOW NOWAIT 'Update completed !'
		LRPRINT = 999
		SET EXACT OFF
		SET DELETED ON
		RETURN
	ENDIF
	LOCAL PAULFIELD , PAULFIELD_VALUE , PAULOLD , PAULNEW
	SELECT PAULNEW
	paulKEY_VALUE=&paulKEY.
	PAULDELETED = DELETED()
	DO WHILE  .NOT. EOF('paulNew')
		SELECT PAULOLD
		GO TOP
		SEEK PAULKEY_VALUE
		IF FOUND('PAULOLD')
			CONTINUE_YN = 1
			IF PAULDELETED
				DELETE
			ELSE
				IF DELETED('PAULOLD')
					RECALL
				ENDIF
			ENDIF
		ELSE
			CONTINUE_YN = 0
			SELECT PAULOLD
			APPEND BLANK
			IF PAULDELETED
				DELETE
			ENDIF
		ENDIF
		FOR GNCOUNT = 1 TO FCOUNT()
			PAULFIELD = FIELD(GNCOUNT)
			IF TYPE(FIELD(GNCOUNT)) = 'C'
				paulFIELD_VALUE=FIELD(gnCount)+&paulFIELD.
			ELSE
				PAULFIELD_VALUE = FIELD(GNCOUNT)
			ENDIF
			FPAULOLD = 'paulOLD.' + ALLTRIM(PAULFIELD)
			FPAULNEW = 'paulNEW.' + LEFT(ALLTRIM(PAULFIELD),10)
			IF UPPER(ALLTRIM(PAULFIELD)) = 'COMPANY_NAME2'
				FPAULOLD = 'paulOLD.COMPANY_NAME2'
				FPAULNEW = 'paulNEW.COMPANY_N2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2'
				FPAULOLD = 'paulOLD.UNIT_PRICE2'
				FPAULNEW = 'paulNEW.UNIT_PRIC2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3'
				FPAULOLD = 'paulOLD.UNIT_PRICE3'
				FPAULNEW = 'paulNEW.UNIT_PRIC3'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE8'
				FPAULOLD = 'paulOLD.UNIT_PRICE8'
				FPAULNEW = 'paulNEW.UNIT_PRIC4'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2'
				FPAULOLD = 'paulOLD.PRICE_UNIT2'
				FPAULNEW = 'paulNEW.PRICE_UNI2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
				FPAULOLD = 'paulOLD.PRICE_UNIT3'
				FPAULNEW = 'paulNEW.PRICE_UNI3'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM2'
				FPAULOLD = 'paulOLD.PRICE_TERM2'
				FPAULNEW = 'paulNEW.PRICE_TER2'
			ENDIF
			IF UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_TERM3'
				FPAULOLD = 'paulOLD.PRICE_TERM3'
				FPAULNEW = 'paulNEW.PRICE_TER3'
			ENDIF
			PAULSELECT = .T.
			IF PAULOLDDBF = 'INVMAST' .OR. PAULOLDDBF = 'SDNMAST'
				IF PAULFIELD = 'AR' .OR. PAULFIELD = 'AP' .OR. PAULFIELD = 'A_R_CODE' .OR.  ;
						PAULFIELD = 'A_P_CODE'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF TYPE(FPAULNEW) = 'U' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'ADATETIME'
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX1) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX1))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX2) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX2))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX3) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX3))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX4) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX4))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX5) AND UPPER(ALLTRIM(PAULFIELD)) = UPPER(ALLTRIM(PLEX5))
				PAULSELECT = .F.
			ENDIF
			IF  .NOT. EMPTY(PLEX1) AND UPPER(ALLTRIM(PLEX1)) = 'STOCK'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'OPEN_STOCK' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'STOCK_IN' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'STOCK_OUT' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'INQTY' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'OUTQTY' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'LASTQTY'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX2) AND UPPER(ALLTRIM(PLEX2)) = 'COST'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'STD_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'AVG_COST' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'ACT_COST' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'AVGM_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'MKT_COST'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX3) AND UPPER(ALLTRIM(PLEX3)) = 'BUYING'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_COST3' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'COST_UNIT3'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF  .NOT. EMPTY(PLEX4) AND UPPER(ALLTRIM(PLEX4)) = 'SELLING'
				IF UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE2' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'UNIT_PRICE3' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT' .OR. UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT2' .OR.  ;
						UPPER(ALLTRIM(PAULFIELD)) = 'PRICE_UNIT3'
					PAULSELECT = .F.
				ENDIF
			ENDIF
			if vartype(&paulFIELD.)="N"
				if left(transform(&paulFIELD.),2)="**"
					PAULSELECT = .F.
				ENDIF
			ENDIF
			IF CONTINUE_YN = 1 AND PAULSELECT
				REPLACE &FpaulOLD. WITH &FpaulNEW.
			ENDIF
			IF CONTINUE_YN = 0 AND PAULSELECT
				REPLACE &FpaulOLD. WITH &FpaulNEW.
			ENDIF
			WAIT WINDOW NOWAIT PAULFIELD_VALUE
		ENDFOR
		IF PAULSELECT
			FPAULOLD = 'paulOLD.ADATETIME'
			FPAULNEW = 'paulNEW.ADATETIME'
			REPLACE &FpaulOLD. WITH &FpaulNEW.
		ENDIF
		SELECT PAULNEW
		SKIP
		PAULDELETED = DELETED()
		paulKEY_VALUE=&paulKEY.
	ENDDO
	SELECT PAULOLD
	= TABLEUPDATE(.T.)
	USE IN PAULNEW
	USE IN PAULOLD
	SET EXACT OFF
	SET DELETED ON
	RETURN
ENDPROC
*------
PROCEDURE ITCREATECURSOR
	LPARAMETER VTYPE , VTABLENAME , VCURSORNAME , VADD1 , VSTR1 , VADD2 , VSTR2 , VADD3 , VSTR3 ,  ;
		VADD4 , VSTR4 , VADD5 , VSTR5 , VADD6 , VSTR6 , VADD7 , VSTR7 ,  ;
		VADD8 , VSTR8 , VADD9 , VSTR9
	LOCAL VPLWORKINGARE
	IF EMPTY(VCURSORNAME) .OR. EMPTY(VTABLENAME)
		WAIT WINDOW  ;
			'Pls specify your cursor name or table name from which you want to copy !'
		RETURN
	ENDIF
	VPLWORKINGARE = SELECT()
	IF USED('source_cursorname')
		USE IN SOURCE_CURSORNAME
	ENDIF
	IF USED(VCURSORNAME)
		use in &vcursorname.
	ENDIF
	use &vtablename. alias source_cursorname in 0 again
	SELECT SOURCE_CURSORNAME
	VPLFIELDCOUNT = AFIELDS(VPLGAMYARRAY)
	FOR GNCOUNT = 1 TO VPLFIELDCOUNT
		VPLGAMYARRAY( GNCOUNT , 7 ) = ''
		VPLGAMYARRAY( GNCOUNT , 8 ) = ''
		VPLGAMYARRAY( GNCOUNT , 10 ) = ''
		VPLGAMYARRAY( GNCOUNT , 11 ) = ''
		VPLGAMYARRAY( GNCOUNT , 13 ) = ''
		VPLGAMYARRAY( GNCOUNT , 14 ) = ''
		VPLGAMYARRAY( GNCOUNT , 15 ) = ''
	ENDFOR
	SELECT 0
	VPLEXTEND = 0
	IF  .NOT. EMPTY(VADD1)
		VPLEXTEND = VPLEXTEND + 1
	ENDIF
	IF  .NOT. EMPTY(VADD2)
		VPLEXTEND = VPLEXTEND + 1
	ENDIF
	IF  .NOT. EMPTY(VADD3)
		VPLEXTEND = VPLEXTEND + 1
	ENDIF
	IF  .NOT. EMPTY(VADD4)
		VPLEXTEND = VPLEXTEND + 1
	ENDIF
	IF  .NOT. EMPTY(VADD5)
		VPLEXTEND = VPLEXTEND + 1
	ENDIF
	IF VPLEXTEND = 0
		CREATE CURSOR (VCURSORNAME) FROM ARRAY VPLGAMYARRAY
	ELSE
		DIMENSION VPLGAMYARRAYNEW( VPLFIELDCOUNT + VPLEXTEND , 11 )
		FOR GNCOUNT = 1 TO VPLFIELDCOUNT
			VPLGAMYARRAYNEW( GNCOUNT , 1 ) = VPLGAMYARRAY(GNCOUNT,1)
			VPLGAMYARRAYNEW( GNCOUNT , 2 ) = VPLGAMYARRAY(GNCOUNT,2)
			VPLGAMYARRAYNEW( GNCOUNT , 3 ) = VPLGAMYARRAY(GNCOUNT,3)
			VPLGAMYARRAYNEW( GNCOUNT , 4 ) = VPLGAMYARRAY(GNCOUNT,4)
			VPLGAMYARRAYNEW( GNCOUNT , 5 ) = VPLGAMYARRAY(GNCOUNT,5)
			VPLGAMYARRAYNEW( GNCOUNT , 6 ) = VPLGAMYARRAY(GNCOUNT,6)
			VPLGAMYARRAYNEW( GNCOUNT , 7 ) = VPLGAMYARRAY(GNCOUNT,7)
			VPLGAMYARRAYNEW( GNCOUNT , 8 ) = VPLGAMYARRAY(GNCOUNT,8)
			VPLGAMYARRAYNEW( GNCOUNT , 9 ) = VPLGAMYARRAY(GNCOUNT,9)
			VPLGAMYARRAYNEW( GNCOUNT , 10 ) = VPLGAMYARRAY(GNCOUNT,10)
			VPLGAMYARRAYNEW( GNCOUNT , 11 ) = VPLGAMYARRAY(GNCOUNT,11)
			VPLGAMYARRAYNEW( GNCOUNT , 11 ) = VPLGAMYARRAY(GNCOUNT,13)
			VPLGAMYARRAYNEW( GNCOUNT , 11 ) = VPLGAMYARRAY(GNCOUNT,14)
			VPLGAMYARRAYNEW( GNCOUNT , 11 ) = VPLGAMYARRAY(GNCOUNT,15)
		ENDFOR
		IF  .NOT. EMPTY(VADD1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 1 ) = VADD1
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 2 ) = ITRETURNCHARTYPE(VSTR1,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 3 ) = ITRETURNCHARTYPE(VSTR1,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 4 ) = ITRETURNCHARTYPE(VSTR1,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 1 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 1 ) = VADD2
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 2 ) = ITRETURNCHARTYPE(VSTR2,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 3 ) = ITRETURNCHARTYPE(VSTR2,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 4 ) = ITRETURNCHARTYPE(VSTR2,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 2 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 1 ) = VADD3
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 2 ) = ITRETURNCHARTYPE(VSTR3,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 3 ) = ITRETURNCHARTYPE(VSTR3,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 4 ) = ITRETURNCHARTYPE(VSTR3,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 3 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD4)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 1 ) = VADD4
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 2 ) = ITRETURNCHARTYPE(VSTR4,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 3 ) = ITRETURNCHARTYPE(VSTR4,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 4 ) = ITRETURNCHARTYPE(VSTR4,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 4 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD5)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 1 ) = VADD5
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 2 ) = ITRETURNCHARTYPE(VSTR5,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 3 ) = ITRETURNCHARTYPE(VSTR5,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 4 ) = ITRETURNCHARTYPE(VSTR5,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 5 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD6)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 1 ) = VADD6
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 2 ) = ITRETURNCHARTYPE(VSTR6,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 3 ) = ITRETURNCHARTYPE(VSTR6,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 4 ) = ITRETURNCHARTYPE(VSTR6,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 6 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD7)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 1 ) = VADD7
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 2 ) = ITRETURNCHARTYPE(VSTR7,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 3 ) = ITRETURNCHARTYPE(VSTR7,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 4 ) = ITRETURNCHARTYPE(VSTR7,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 7 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD8)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 1 ) = VADD8
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 2 ) = ITRETURNCHARTYPE(VSTR8,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 3 ) = ITRETURNCHARTYPE(VSTR8,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 4 ) = ITRETURNCHARTYPE(VSTR8,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 8 , 11 ) = ''
		ENDIF
		IF  .NOT. EMPTY(VADD9)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 1 ) = VADD9
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 2 ) = ITRETURNCHARTYPE(VSTR9,1)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 3 ) = ITRETURNCHARTYPE(VSTR9,2)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 4 ) = ITRETURNCHARTYPE(VSTR9,3)
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 5 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 6 ) = .F.
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 7 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 8 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 9 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 10 ) = ''
			VPLGAMYARRAYNEW( VPLFIELDCOUNT + 9 , 11 ) = ''
		ENDIF
		CREATE CURSOR (VCURSORNAME) FROM ARRAY VPLGAMYARRAYNEW
	ENDIF
	IF USED('source_cursorname')
		USE IN SOURCE_CURSORNAME
	ENDIF
ENDPROC
*------
PROCEDURE ITRETURNCHARTYPE
	LPARAMETER VPLSTRING , VPLTYPE
	IF VPLTYPE = 1
		RETURN UPPER(SUBSTR(VPLSTRING,1,1))
	ENDIF
	IF VPLTYPE = 2
		IF AT('.',VPLSTRING) = 0
			RETURN SUBSTR(VPLSTRING,AT('(',VPLSTRING) + 1,AT(')',VPLSTRING) - AT('(',VPLSTRING) - 1)
		ELSE
			VPLSTRINGNEW =  ;
				SUBSTR(VPLSTRING,AT('(',VPLSTRING) + 1,AT(')',VPLSTRING) - AT('(',VPLSTRING) - 1)
			RETURN SUBSTR(VPLSTRINGNEW,1,AT('.',VPLSTRINGNEW) - 1)
		ENDIF
	ENDIF
	IF VPLTYPE = 3
		IF AT('.',VPLSTRING) = 0
			RETURN 0
		ELSE
			VPLSTRINGNEW =  ;
				SUBSTR(VPLSTRING,AT('(',VPLSTRING) + 1,AT(')',VPLSTRING) - AT('(',VPLSTRING) - 1)
			RETURN SUBSTR(VPLSTRINGNEW,AT('.',VPLSTRINGNEW) + 1,4)
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE ITLOADDATA2
	LPARAMETER PAULVALUE , PAULINDEX , PAULKEY , PAULOLDDBF , PAULNEWDBF , PAULOLDOPEN ,  ;
		PAULNEWOPEN , PAULCONDITION , PAULSEEKRANGE
	SET EXACT OFF
	SET DELETED ON
	IF USED('paulOLD')
		USE IN PAULOLD
	ENDIF
	IF EMPTY(PAULCONDITION)
		PAULCONDITION = '  .T.'
	ENDIF
	paulcondition2=" &paulKEY.=paulVALUE "
	PAULOLD = 'paulOLD'
	IF  .NOT. EMPTY(PAULINDEX)
		use &paulOLDDBF. order &paulindex. in 0 alias (paulOLD) again
	ELSE
		use &paulOLDDBF.  in 0 alias (paulOLD) again
	ENDIF
	PAULNEW = PAULNEWDBF
	PAULKEY_VALUE = ''
	CONTINUE_YN = 0
	PAULDELETED = .F.
	FPAULOLDADATETIME = ALLTRIM(PAULOLD) + '.' + 'ADATETIME'
	FPAULNEWADATETIME = ALLTRIM(PAULNEW) + '.' + 'ADATETIME'
	SELECT (PAULOLD)
	GO TOP
	IF  .NOT. EMPTY(PAULINDEX)
		set order to &paulindex.
		GO TOP
		SEEK PAULVALUE
		IF  .NOT. FOUND()
			IF USED(PAULOLD)
				USE IN (PAULOLD)
			ENDIF
			LRPRINT = 999
			SET EXACT OFF
			SET DELETED ON
			RETURN
		ENDIF
		paulcondition2=" &paulKEY.=paulVALUE "
		paulcondition3=" alltrim(&paulKEY.)==paulVALUE "
	ELSE
		PAULCONDITION2 = '  .T. '
		PAULCONDITION3 = '  .T. '
	ENDIF
	LOCAL PAULFIELD , PAULFIELD_VALUE
	SELECT (PAULOLD)
	PAULKEY_VALUE = PAULVALUE
	PAULDELETED = DELETED()
	PAULNOREC = 0
	IF  .NOT. EMPTY(PAULSEEKRANGE)
		PAULCONDITION2 = ALLTRIM(PAULSEEKRANGE)
	ENDIF
	DO WHILE MACROS  ;
			???FUN[CA] ('inkey()<>27 .AND. .NOT. EOF(paulOLD) .AND. &paulcondition2. ')
		SELECT (PAULOLD)
		IF  &paulcondition3.  .AND. &paulcondition.
			PAULNOREC = PAULNOREC + 1
			CONTINUE_YN = 1
			SELECT (PAULNEW)
			APPEND BLANK
			SELECT (PAULOLD)
			FOR GNCOUNT = 1 TO FCOUNT()
				PAULFIELD = FIELD(GNCOUNT)
				IF TYPE(FIELD(GNCOUNT)) = 'C'
					paulFIELD_VALUE=FIELD(gnCount)+&paulFIELD.
				ELSE
					PAULFIELD_VALUE = FIELD(GNCOUNT)
				ENDIF
				FPAULOLD = ALLTRIM(PAULOLD) + '.' + ALLTRIM(PAULFIELD)
				FPAULNEW = ALLTRIM(PAULNEW) + '.' + ALLTRIM(PAULFIELD)
				PAULSELECT = .T.
				SELECT (PAULNEW)
				IF PAULSELECT
					REPLACE &FpaulNEW. WITH &FpaulOLD.
				ENDIF
				SELECT (PAULOLD)
			ENDFOR
			WAIT WINDOW NOWAIT '# OF RECORD LOADED: ' + ALLTRIM(STR(PAULNOREC,8))
		ENDIF
		SELECT (PAULOLD)
		SKIP
		PAULDELETED = DELETED()
		IF  .NOT. EMPTY(PAULKEY)
			paulKEY_VALUE=&paulKEY.
		ENDIF
	ENDDO
	IF USED('paulOLD')
		USE IN PAULOLD
	ENDIF
	IF USED(PAULOLD)
		USE IN (PAULOLD)
	ENDIF
	SET EXACT OFF
	SET DELETED ON
	RETURN
ENDPROC
*------
PROCEDURE ITUPDATEDATA2
	LPARAMETER PAULKEYVALUE , PAULINDEX , PAULKEY , PAULOLDDBF , PAULNEWDBF , PAULCONDITION
	SET EXACT ON
	SET DELETED OFF
	VPLWKDATAUPDATE2 = SELECT()
	IF USED(PAULOLDDBF)
		SELECT (PAULOLDDBF)
		IF CURSORGETPROP('Buffering') > 2
			= TABLEUPDATE(.T.)
		ENDIF
	ENDIF
	IF EMPTY(PAULCONDITION)
		PAULCONDITION = '.T.'
	ENDIF
	IF USED('paulOLD')
		USE IN PAULOLD
	ENDIF
	PAULOLD = 'paulOLD'
	use &paulOLDDBF. order &paulindex. in 0 alias (paulOLD) again
	= CURSORSETPROP('Buffering',5,(PAULOLD))
	PAULNEW = PAULNEWDBF
	PAULKEY_VALUE = ''
	CONTINUE_YN = 0
	PAULDELETED = .F.
	FPAULOLDADATETIME = ALLTRIM(PAULOLD) + '.' + 'ADATETIME'
	FPAULNEWADATETIME = ALLTRIM(PAULNEW) + '.' + 'ADATETIME'
	SELECT (PAULNEW)
	GO TOP
	IF EOF()
		IF USED(PAULOLD)
			USE IN (PAULOLD)
		ENDIF
		WAIT WINDOW NOWAIT 'Update completed !'
		LRPRINT = 999
		SET EXACT OFF
		SET DELETED ON
		SELECT (VPLWKDATAUPDATE2)
		RETURN .T.
	ENDIF
	LOCAL PAULFIELD , PAULFIELD_VALUE
	SELECT (PAULNEW)
	paulKEY_VALUE=&paulKEY.
	PAULDELETED = DELETED()
	PAULNOREC = 0
	PAULSELECT = .T.
	DO WHILE  .NOT. EOF(PAULNEW)
		if &paulcondition.
			SELECT (PAULNEW)
			PAULDELETED = DELETED()
			paulKEY_VALUE=&paulKEY.
			SELECT (PAULOLD)
			GO TOP
			SEEK PAULKEY_VALUE
			IF FOUND(PAULOLD)
				CONTINUE_YN = 1
				IF PAULDELETED
					DELETE
				ELSE
					IF DELETED('PAULOLD')
						RECALL
					ENDIF
				ENDIF
			ELSE
				IF  .NOT. PAULDELETED
					CONTINUE_YN = 0
					SELECT (PAULOLD)
					APPEND BLANK
				ELSE
					SELECT (PAULNEW)
					SKIP
					LOOP
				ENDIF
			ENDIF
			SELECT (PAULOLD)
			PAULNOREC = PAULNOREC + 1
			FOR GNCOUNT = 1 TO FCOUNT()
				PAULFIELD = FIELD(GNCOUNT)
				FPAULOLD = ALLTRIM(PAULOLD) + '.' + ALLTRIM(PAULFIELD)
				FPAULNEW = ALLTRIM(PAULNEW) + '.' + ALLTRIM(PAULFIELD)
				IF PAULSELECT
					REPLACE &FpaulOLD. WITH &FpaulNEW.
				ENDIF
			ENDFOR
			WAIT WINDOW NOWAIT '# OF RECORD UPDATED: ' + ALLTRIM(STR(PAULNOREC,8))
		ENDIF
		SELECT (PAULNEW)
		SKIP
		PAULDELETED = DELETED()
		paulKEY_VALUE=&paulKEY.
	ENDDO
	SELECT (PAULOLD)
	VPLUPDATEOK = TABLEUPDATE(.T.)
	IF  .NOT. VPLUPDATEOK
		= TABLEREVERT(.T.)
	ENDIF
	IF USED(PAULOLD)
		USE IN (PAULOLD)
	ENDIF
	SET EXACT OFF
	SET DELETED ON
	SELECT (VPLWKDATAUPDATE2)
	RETURN VPLUPDATEOK
ENDPROC
*------
PROCEDURE ItSign
	PARAMETER VSIGNTYPE , VSIGNFILE1 , VSIGNFILE2 , VSIGNFILE3 , VSIGNFILE4
	LOCAL RETUVALUE
	IF VARTYPE(VSIGNTYPE) <> 'C' .OR. EMPTY(VSIGNTYPE)
		VSIGNTYPE = '1'
	ENDIF
	IF VARTYPE(VSIGNFILE1) <> 'C'
		VSIGNFILE1 = ALLTRIM(EMPLOYEER.SIGNATURE)
	ENDIF
	IF VARTYPE(VSIGNFILE2) <> 'C'
		VSIGNFILE2 = ALLTRIM(MYSIGNATURE)
	ENDIF
	IF VARTYPE(VSIGNFILE3) <> 'C'
		VSIGNFILE3 = ALLTRIM(MULTICOR.SIGN)
	ENDIF
	IF VARTYPE(VSIGNFILE4) <> 'C'
		VSIGNFILE4 = ''
	ENDIF
	RETUVALUE = ''
	DO CASE
		CASE VSIGNTYPE = '1'
			IF '\' $ VSIGNFILE1
				RETUVALUE = IIF(FILE(VSIGNFILE1),ALLTRIM(VSIGNFILE1),'')
			ELSE
				RETUVALUE =  ;
					IIF(FILE(SET_PATH + 'bitmaps\' + VSIGNFILE1),SET_PATH + 'bitmaps\' + ALLTRIM(VSIGNFILE1),'')
			ENDIF
		CASE VSIGNTYPE = '2'
			IF '\' $ VSIGNFILE2
				RETUVALUE = IIF(FILE(VSIGNFILE2),ALLTRIM(VSIGNFILE2),'')
			ELSE
				RETUVALUE =  ;
					IIF(FILE(SET_PATH + 'bitmaps\' + VSIGNFILE2),SET_PATH + 'bitmaps\' + ALLTRIM(VSIGNFILE2),'')
			ENDIF
		CASE VSIGNTYPE = '3'
			IF '\' $ VSIGNFILE3
				RETUVALUE = IIF(FILE(VSIGNFILE3),ALLTRIM(VSIGNFILE3),'')
			ELSE
				RETUVALUE =  ;
					IIF(FILE(SET_PATH + 'bitmaps\' + VSIGNFILE3),SET_PATH + 'bitmaps\' + ALLTRIM(VSIGNFILE3),'')
			ENDIF
		CASE VSIGNTYPE = '4'
			IF '\' $ VSIGNFILE4
				RETUVALUE = IIF(FILE(VSIGNFILE4),ALLTRIM(VSIGNFILE4),'')
			ELSE
				RETUVALUE =  ;
					IIF(FILE(SET_PATH + 'bitmaps\' + VSIGNFILE4),SET_PATH + 'bitmaps\' + ALLTRIM(VSIGNFILE4),'')
			ENDIF
		OTHERWISE
	ENDCASE
	RETURN RETUVALUE
ENDPROC
*------
PROCEDURE itatlist
	LPARAMETER VPLVAR , VPLANDOR , VPLSELECT , VPLSTRING
	IF AT(',',VPLSTRING) > 0
		RETURN "AT('" +  ;
			STRTRAN(VPLSTRING,',',"'," + VPLVAR + ')' + VPLSELECT + ' ' + VPLANDOR + " AT('") + "'," + VPLVAR + ')' + VPLSELECT
	ELSE
		RETURN "AT('" + VPLSTRING + "'," + VPLVAR + ')' + VPLSELECT
	ENDIF
ENDPROC
*------
PROCEDURE paulDELTABLE
	LPARAMETER PAULDBF , PAULKEY , PAULSEEKVALUE , PAULSEEKEXP , PAULREP1 , PAULWITH1 ,  ;
		PAULREP2 , PAULWITH2 , PAULREP3 , PAULWITH3
	LOCAL SELECT_WK , SET_EXACT , SET_NEAR , SEEK_RECORD
	SELECT_WK = SELECT()
	IF USED('pauldeldbf')
		USE IN PAULDELDBF
	ENDIF
	USE IN 0 (PAULDBF) AGAIN ALIAS PAULDELDBF ORDER (PAULKEY)
	SET NEAR OFF
	SET EXACT ON
	SET DELETED OFF
	SELECT PAULDELDBF
	GO TOP
	SEEK PAULSEEKVALUE
	SEEK_RECORD = 0
	DO WHILE MACROS  ;
			???FUN[CA] ('.NOT. EOF("pauldeldbf")  .AND. paulSEEKVALUE=&paulSEEKEXP.')
		IF  FOUND("pauldeldbf") .AND. &paulSEEKEXP.=paulSEEKVALUE
			SEEK_RECORD = SEEK_RECORD + 1
			IF VARTYPE(ADATETIME) = 'T'
				REPLACE ADATETIME WITH DATETIME()
			ENDIF
			IF VARTYPE(DDATE) = 'C'
				REPLACE DDATE WITH PAULUSER_CREATE()
			ENDIF
			IF  .NOT. EMPTY(PAULREP1)
				REPLACE &paulREP1. WITH &paulWITH1.
				WAIT WINDOW &paulFIELDNAME1. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP2)
				REPLACE &paulREP2. WITH &paulWITH2.
				WAIT WINDOW &paulFIELDNAME2. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP3)
				REPLACE &paulREP3. WITH &paulWITH3.
				WAIT WINDOW &paulFIELDNAME3. NOWAIT
			ENDIF
			DELETE IN PAULDELDBF
			WAIT WINDOW NOWAIT  ;
				'# of record deleted : ' + ALLTRIM(STR(SEEK_RECORD,8)) + '   in ' + PAULDBF +  ;
				'  Key: ' + ALLTRIM(PAULSEEKVALUE)
		ENDIF
		SELECT PAULDELDBF
		SKIP
	ENDDO
	IF USED('pauldeldbf')
		USE IN PAULDELDBF
	ENDIF
	SET DELETED ON
	SELECT (SELECT_WK)
	RETURN .T.
ENDPROC
*------
PROCEDURE itgetrangevalue
	LPARAMETER VPLDBF , VPLALIAS , VPLCLOSEDBF , VPLSEEK , VPLINITVALUE , VPLINITFIRSTYN ,  ;
		VPLDOWHILE , VPLEQU , VPLKEY1 , VPLKEY2 , VPLKEY3 , VPLKEY4
	LOCAL VPLGETRANGEDBFWK
	VPLGETRANGEDBFWK = SELECT()
	SET_EXACT = SET('exact')
	SET_NEAR = SET('near')
	IF USED('itgetrangedbf')
		USE IN ITGETRANGEDBF
	ENDIF
	IF UPPER(VPLCLOSEDBF) = 'Y'
		IF USED(VPLALIAS)
			use in &vplalias.
		ENDIF
	ENDIF
	SELECT 0
	IF EMPTY(VPLALIAS)
		use &vpldbf. alias  itgetrangedbf order &vplseek. again
		VPLALIAS = 'itgetrangedbf'
	ELSE
		IF USED(VPLALIAS)
			SELECT (VPLALIAS)
		ELSE
			use &vpldbf. alias  &vplalias. order &vplseek. again
		ENDIF
	ENDIF
	SELECT (VPLALIAS)
	GO TOP
	SET EXACT OFF
	SET NEAR ON
	SEEK VPLINITVALUE
	IF FOUND()
		IF UPPER(VPLINITFIRSTYN) = 'Y'
			IF  .NOT. EMPTY(VPLKEY1)
				keyvalue1=&vplkey1.
			ENDIF
			IF  .NOT. EMPTY(VPLKEY2)
				keyvalue2=&vplkey2.
			ENDIF
		ENDIF
		DO WHILE MACROS  ???FUN[CA] ('!eof() .and. &vpldowhile.')
			if &vplequ.
				IF  .NOT. EMPTY(VPLKEY1)
					keyvalue1=&vplkey1.
				ENDIF
				IF  .NOT. EMPTY(VPLKEY2)
					keyvalue2=&vplkey2.
				ENDIF
				IF  .NOT. EMPTY(VPLKEY3)
					keyvalue2=&vplkey3.
				ENDIF
				IF  .NOT. EMPTY(VPLKEY4)
					keyvalue2=&vplkey4.
				ENDIF
			ENDIF
			SELECT (VPLALIAS)
			SKIP
		ENDDO
	ENDIF
	IF USED('itgetrangedbf')
		USE IN ITGETRANGEDBF
	ENDIF
	IF UPPER(VPLCLOSEDBF) = 'Y'
		IF USED(VPLALIAS)
			use in &vplalias.
		ENDIF
	ENDIF
	set exact &set_exact.
	set near &set_near.
	SELECT (VPLGETRANGEDBFWK)
ENDPROC
*------
PROCEDURE ITCREATEGRAPHIC
	LPARAMETER VPLCURR , VPLDBF , VPLSUM , VPLGROUP , VPLGROUPBY , VPLORDER , VPLCOL , VPLROW ,  ;
		VGPTYPE , VGPTITLE , VGPCOLNAME , VGPROWNAME
	IF FILE(VPLCURR + '.dbf')
		RETURN
	ENDIF
	IF EMPTY(VPLCURR) .OR. EMPTY(VPLDBF) .OR. EMPTY(VPLSUM) .OR. EMPTY(VPLGROUP) .OR.  ;
			EMPTY(VPLCOL) .OR. EMPTY(VPLROW)
		RETURN
	ENDIF
	VPLSELECTWK = SELECT()
	IF USED(VPLCURR)
		USE IN (VPLCURR)
	ENDIF
	VROWDATA = ''
	VCOLDATA = ''
	SELECT 0
	VSELECTST =  ;
		'select ' + VPLSUM + ',' + VPLGROUP + ' from ' + VPLDBF +  ;
		IIF( .NOT. EMPTY(VPLGROUPBY),' group by ' + VPLGROUPBY,' ') +  ;
		IIF( .NOT. EMPTY(VPLORDER),' order by ' + VPLORDER,' ') + ' into cursor ' + VPLCURR
	&vselectst.
	DO WHILE  .NOT. EOF()
		vrowdata=vrowdata+chr(9)+&vplrow.
		vcoldata=vcoldata+chr(9)+&vplcol.
		SKIP
	ENDDO
	CREATE CURSOR (VPLCURR) ( PIC G )
	IF LOWER(ALIAS()) = LOWER(VPLCURR)
		APPEND BLANK
		APPEND GENERAL PIC CLASS 'Msgraph.chart' DATA  ;
			VROWDATA + CHR(13) + CHR(10) + VCOLDATA + CHR(13) + CHR(10)
	ENDIF
	SELECT (VPLSELECTWK)
ENDPROC
*------
PROCEDURE itacctval
	LPARAMETER PLFM , PLTO , PLINVVAR , PLINV_ID , PLVAR , PLEXACT , PLPOST , PLCLOSEDBF ,  ;
		PLDATE1 , PLDATE2
	LOCAL PLSELECTWORK , PLVALUE1 , PLVALUE2 , PLVALUE3 , PLVALUE4 , PLVALUE5 , PLVALUE6
	PLVALUE1 = 0
	PLVALUE2 = 0
	PLVALUE3 = 0
	PLVALUE4 = 0
	PLVALUE5 = 0
	PLVALUE6 = 0
	PLTOTALVALUE = 0
	PLSELECTWORK = SELECT()
	IF EMPTY(PLVAR)
		PLVAR = 'round((debit-credit)*exchan,ac_decimal)'
	ENDIF
	IF EMPTY(PLPOST)
		PLPOST = 'N'
	ENDIF
	IF EMPTY(PLCLOSEDBF)
		PLCLOSEDBF = 'N'
	ENDIF
	IF EMPTY(PLEXACT)
		PLEXACT = 'N'
	ENDIF
	IF EMPTY(PLTO) .OR. PLTO == PLFM
		PLEXACT = 'Y'
		PLTO = PLFM
	ENDIF
	PLTO2 = PLINVVAR
	PLFM2 = PLINVVAR
	IF PLPOST = 'N'
		VCONDITION1 = PLINV_ID + '=' + "'" + PLINVVAR + "'"
		IF PLEXACT = 'N'
			VCONDITION2 =  ;
				'acct_id>=' + "'" + PLFM + "'" + ' and acct_id<=' + "'" + PLTO + "'" +  ;
				'  and !arabmast_getvalue.posted' + ' and arabmast_getvalue.ISBALANCE'
		ELSE
			VCONDITION2 =  ;
				'rtrim(acct_id)==' + "'" + RTRIM(PLFM) + "'" + '  and !arabmast_getvalue.posted' +  ;
				' and arabmast_getvalue.ISBALANCE'
		ENDIF
		IF  .NOT. EMPTY(PLDATE1) AND  .NOT. EMPTY(PLDATE2)
			VCONDITION2 =  ;
				VCONDITION2 +  ;
				'  and arabmast_getvalue.vouch_date>=pldate1 and arabmast_getvalue.vouch_date<=pldate2'
		ENDIF
		IF  .NOT. USED('arabdtl_getvalue')
			use  arabdtl alias arabdtl_getvalue in 0 again order &plinv_id.
		ENDIF
		IF  .NOT. USED('arabmast_getvalue')
			USE IN 0 arabmast AGAIN ALIAS ARABMAST_GETVALUE ORDER voucher_no
			SELECT ARABMAST_GETVALUE
			SET RELATION TO
			SELECT ARABDTL_GETVALUE
			SET RELATION TO VOUCHER_NO INTO ARABMAST_GETVALUE
		ENDIF
		SELECT ARABDTL_GETVALUE
		GO TOP
		SEEK PLINVVAR
		DO WHILE MACROS  ???FUN[CA] ('!eof() .and. &vcondition1.')
			if &vcondition2.
				plvalue1=plvalue1+&plvar.
			ENDIF
			SKIP
		ENDDO
	ENDIF
	IF PLPOST = 'N'
		VCONDITION1 = PLINV_ID + '=' + "'" + PLINVVAR + "'"
		IF PLEXACT = 'N'
			VCONDITION2 =  ;
				'acct_id>=' + "'" + PLFM + "'" + ' and acct_id<=' + "'" + PLTO + "'" +  ;
				'  and !apabmast_getvalue.posted' + ' and apabmast_getvalue.ISBALANCE'
		ELSE
			VCONDITION2 =  ;
				'rtrim(acct_id)==' + "'" + RTRIM(PLFM) + "'" + '  and !apabmast_getvalue.posted' +  ;
				' and apabmast_getvalue.ISBALANCE'
		ENDIF
		IF  .NOT. EMPTY(PLDATE1) AND  .NOT. EMPTY(PLDATE2)
			VCONDITION2 =  ;
				VCONDITION2 +  ;
				'  and apabmast_getvalue.vouch_date>=pldate1 and apabmast_getvalue.vouch_date<=pldate2'
		ENDIF
		IF  .NOT. USED('apabdtl_getvalue')
			use  apabdtl alias apabdtl_getvalue in 0 again order &plinv_id.
		ENDIF
		IF  .NOT. USED('apabmast_getvalue')
			USE IN 0 apabmast AGAIN ALIAS APABMAST_GETVALUE ORDER voucher_no
			SELECT APABMAST_GETVALUE
			SET RELATION TO
			SELECT APABDTL_GETVALUE
			SET RELATION TO VOUCHER_NO INTO APABMAST_GETVALUE
		ENDIF
		SELECT APABDTL_GETVALUE
		GO TOP
		SEEK PLINVVAR
		DO WHILE MACROS  ???FUN[CA] ('!eof() .and. &vcondition1.')
			if &vcondition2.
				plvalue2=plvalue2+&plvar.
			ENDIF
			SKIP
		ENDDO
	ENDIF
	VCONDITION1 = PLINV_ID + '=' + "'" + PLINVVAR + "'"
	IF PLEXACT = 'N'
		VCONDITION2 =  ;
			'acct_id>=' + "'" + PLFM + "'" + ' and acct_id<=' + "'" + PLTO + "'" +  ;
			'  and jvmast_getvalue.ISBALANCE'
	ELSE
		VCONDITION2 =  ;
			'rtrim(acct_id)==' + "'" + RTRIM(PLFM) + "'" + '  and  jvmast_getvalue.ISBALANCE'
	ENDIF
	IF PLPOST = 'Y'
		VCONDITION2 = VCONDITION2 + '  and  jvmast_getvalue.posted'
	ENDIF
	IF  .NOT. EMPTY(PLDATE1) AND  .NOT. EMPTY(PLDATE2)
		VCONDITION2 =  ;
			VCONDITION2 +  ;
			'  and jvmast_getvalue.vouch_date>=pldate1 and jvmast_getvalue.vouch_date<=pldate2'
	ENDIF
	IF  .NOT. USED('jvdtl_getvalue')
		use  jvdtl alias jvdtl_getvalue in 0 again order &plinv_id.
	ENDIF
	IF  .NOT. USED('jvmast_getvalue')
		USE IN 0 jvmast AGAIN ALIAS JVMAST_GETVALUE ORDER voucher_no
		SELECT JVMAST_GETVALUE
		SET RELATION TO
		SELECT JVDTL_GETVALUE
		SET RELATION TO VOUCHER_NO INTO JVMAST_GETVALUE
	ENDIF
	SELECT JVDTL_GETVALUE
	GO TOP
	SEEK PLINVVAR
	DO WHILE MACROS  ???FUN[CA] ('!eof() .and. &vcondition1.')
		if &vcondition2.
			plvalue3=plvalue3+&plvar.
		ENDIF
		SKIP
	ENDDO
	IF PLPOST = 'N'
		VCONDITION1 = PLINV_ID + '=' + "'" + PLINVVAR + "'"
		IF PLEXACT = 'N'
			VCONDITION2 =  ;
				'acct_id>=' + "'" + PLFM + "'" + ' and acct_id<=' + "'" + PLTO + "'" +  ;
				'  and !armast_getvalue.posted' + ' and armast_getvalue.ISBALANCE'
		ELSE
			VCONDITION2 =  ;
				'rtrim(acct_id)==' + "'" + RTRIM(PLFM) + "'" + '  and !armast_getvalue.posted' +  ;
				' and armast_getvalue.ISBALANCE'
		ENDIF
		IF  .NOT. EMPTY(PLDATE1) AND  .NOT. EMPTY(PLDATE2)
			VCONDITION2 =  ;
				VCONDITION2 +  ;
				'  and armast_getvalue.vouch_date>=pldate1 and armast_getvalue.vouch_date<=pldate2'
		ENDIF
		IF  .NOT. USED('ardtl_getvalue')
			use  ardtl alias ardtl_getvalue in 0 again order &plinv_id.
		ENDIF
		IF  .NOT. USED('armast_getvalue')
			USE IN 0 armast AGAIN ALIAS ARMAST_GETVALUE ORDER voucher_no
			SELECT ARMAST_GETVALUE
			SET RELATION TO
			SELECT ARDTL_GETVALUE
			SET RELATION TO VOUCHER_NO INTO ARMAST_GETVALUE
		ENDIF
		SELECT ARDTL_GETVALUE
		GO TOP
		SEEK PLINVVAR
		DO WHILE MACROS  ???FUN[CA] ('!eof() .and. &vcondition1.')
			if &vcondition2.
				plvalue4=plvalue4+&plvar.
			ENDIF
			SKIP
		ENDDO
	ENDIF
	IF PLPOST = 'N'
		VCONDITION1 = PLINV_ID + '=' + "'" + PLINVVAR + "'"
		IF PLEXACT = 'N'
			VCONDITION2 =  ;
				'acct_id>=' + "'" + PLFM + "'" + ' and acct_id<=' + "'" + PLTO + "'" +  ;
				'  and !apmast_getvalue.posted' + ' and apmast_getvalue.ISBALANCE'
		ELSE
			VCONDITION2 =  ;
				'rtrim(acct_id)==' + "'" + RTRIM(PLFM) + "'" + '  and !apmast_getvalue.posted' +  ;
				' and apmast_getvalue.ISBALANCE'
		ENDIF
		IF  .NOT. EMPTY(PLDATE1) AND  .NOT. EMPTY(PLDATE2)
			VCONDITION2 =  ;
				VCONDITION2 +  ;
				'  and apmast_getvalue.vouch_date>=pldate1 and apmast_getvalue.vouch_date<=pldate2'
		ENDIF
		IF  .NOT. USED('apdtl_getvalue')
			use  apdtl alias apdtl_getvalue in 0 again order &plinv_id.
		ENDIF
		IF  .NOT. USED('apmast_getvalue')
			USE IN 0 apmast AGAIN ALIAS APMAST_GETVALUE ORDER voucher_no
			SELECT APMAST_GETVALUE
			SET RELATION TO
			SELECT APDTL_GETVALUE
			SET RELATION TO VOUCHER_NO INTO APMAST_GETVALUE
		ENDIF
		SELECT APDTL_GETVALUE
		GO TOP
		SEEK PLINVVAR
		DO WHILE MACROS  ???FUN[CA] ('!eof() .and. &vcondition1.')
			if &vcondition2.
				plvalue5=plvalue5+&plvar.
			ENDIF
			SKIP
		ENDDO
	ENDIF
	VCONDITION1 = PLINV_ID + '=' + "'" + PLINVVAR + "'"
	IF PLEXACT = 'N'
		VCONDITION2 =  ;
			'acct_id>=' + "'" + PLFM + "'" + ' and acct_id<=' + "'" + PLTO + "'"
	ELSE
		VCONDITION2 = 'rtrim(acct_id)==' + "'" + RTRIM(PLFM) + "'"
	ENDIF
	IF  .NOT. EMPTY(PLDATE1) AND  .NOT. EMPTY(PLDATE2)
		VCONDITION2 =  ;
			VCONDITION2 +  ;
			'  and gldtlal_getvalue.vouch_date>=pldate1 and gldtlal_getvalue.vouch_date<=pldate2'
	ENDIF
	IF  .NOT. USED('gldtlal_getvalue')
		use  gldtlal alias gldtlal_getvalue in 0 again order &plinv_id.
	ENDIF
	SELECT GLDTLAL_GETVALUE
	GO TOP
	SEEK PLINVVAR
	DO WHILE MACROS  ???FUN[CA] ('!eof() .and. &vcondition1.')
		if &vcondition2.
			plvalue6=plvalue6+&plvar.
		ENDIF
		SKIP
	ENDDO
	IF PLCLOSEDBF = 'Y'
		= ITACCTVALUECLOSEDBF()
	ENDIF
	SELECT (PLSELECTWORK)
	PLTOTALVALUE = PLVALUE1 + PLVALUE2 + PLVALUE3 + PLVALUE4 + PLVALUE5 + PLVALUE6
	RETURN PLTOTALVALUE
ENDPROC
*------
PROCEDURE ITACCTVALUECLOSEDBF
	IF USED('arabdtl_getvalue')
		USE IN ARABDTL_GETVALUE
	ENDIF
	IF USED('arabmast_getvalue')
		USE IN ARABMAST_GETVALUE
	ENDIF
	IF USED('apabdtl_getvalue')
		USE IN APABDTL_GETVALUE
	ENDIF
	IF USED('apabmast_getvalue')
		USE IN APABMAST_GETVALUE
	ENDIF
	IF USED('ardtl_getvalue')
		USE IN ARDTL_GETVALUE
	ENDIF
	IF USED('armast_getvalue')
		USE IN ARMAST_GETVALUE
	ENDIF
	IF USED('apdtl_getvalue')
		USE IN APDTL_GETVALUE
	ENDIF
	IF USED('apmast_getvalue')
		USE IN APMAST_GETVALUE
	ENDIF
	IF USED('jvdtl_getvalue')
		USE IN JVDTL_GETVALUE
	ENDIF
	IF USED('jvmast_getvalue')
		USE IN JVMAST_GETVALUE
	ENDIF
	IF USED('gldtlal_getvalue')
		USE IN GLDTLAL_GETVALUE
	ENDIF
ENDPROC
*------
PROCEDURE sysMenuctrl
	IF WEXIST('frmmenuctrl')
		ACTIVATE WINDOW 'frmmenuctrl'
		IF  .NOT. ISNULL('menuctrl')
			MENUCTRL.KENCTRLTAB()
		ENDIF
	ELSE
		DO FORM menuctrl
	ENDIF
ENDPROC
*------
PROCEDURE kenMenuctrl
	IF WEXIST('frmmenuctrl')
		ACTIVATE WINDOW 'frmmenuctrl'
		IF  .NOT. ISNULL('menuctrl')
			MENUCTRL.KENCTRLTAB()
		ENDIF
	ELSE
		DO FORM menuctrl
	ENDIF
ENDPROC
*------
PROCEDURE ITACPERIOD
	LPARAMETER VLPERIOD , VLTYPE , VPLDATE , VPLGO
	LOCAL VLPERIOD
	IF VARTYPE(VLPERIOD) = 'N'
		IF VLPERIOD < 0 .OR. VLPERIOD > 26
			RETURN ''
		ENDIF
		VLPERIOD = ALLTRIM(STR(VLPERIOD))
	ENDIF
	IF VAL(VLPERIOD) < 0 .OR. VAL(VLPERIOD) > 26
		RETURN ''
	ENDIF
	IF EMPTY(VLTYPE)
		VLTYPE = 1
	ELSE
		IF VARTYPE(VLTYPE) <> 'N'
			VLTYPE = VAL(VLTYPE)
		ENDIF
	ENDIF
	VFROM = ''
	IF USED('acct_Defr')
		VFROM = 'acct_Defr.from'
	ELSE
		IF USED('acct_Defgetperiod')
			VFROM = 'acct_Defgetperiod.from'
		ELSE
			USE IN 0 acct_def AGAIN ALIAS ACCT_DEFGETPERIOD
			VFROM = 'acct_Defgetperiod.from'
		ENDIF
	ENDIF
	IF EMPTY(VFROM)
		RETURN
	ENDIF
	IF  .NOT. EMPTY(VPLDATE)
		IF  .NOT. EMPTY(VPLGO)
			VLPERIOD = 'gomonth(vpldate,' + VLPERIOD + '-1' + ')'
		ELSE
			VLPERIOD =  ;
				VFROM + ALLTRIM(STR(VAL(VLPERIOD) + IIF(VPLDATE - AC_OPENDATEFR >= 365,12,0)))
		ENDIF
	ELSE
		VLPERIOD = VFROM + ALLTRIM(VLPERIOD)
	ENDIF
	VPLRETURN = ''
	IF EMPTY(VLTYPE) .OR. VLTYPE = 1
		vplreturn= left(upper(cmonth(&vlperiod.)),3)+"/"+right(alltrim(str(year(&vlperiod.))),2)
	ENDIF
	IF EMPTY(VLTYPE) .OR. VLTYPE = 2
		vplreturn= upper(cmonth(&vlperiod.))+"/"+alltrim(str(year(&vlperiod.)))
	ENDIF
	IF EMPTY(VLTYPE) .OR. VLTYPE = 3
		vplreturn= upper(cmonth(&vlperiod.))
	ENDIF
	IF EMPTY(VLTYPE) .OR. VLTYPE = 4
		vplreturn= left(upper(cmonth(&vlperiod.)),3)
	ENDIF
	IF EMPTY(VLTYPE) .OR. VLTYPE = 5
		vplreturn=alltrim(str(year(&vlperiod.)))
	ENDIF
	IF USED('acct_Defgetperiod')
		USE IN ACCT_DEFGETPERIOD
	ENDIF
	RETURN VPLRETURN
ENDPROC
*------
PROCEDURE paulCHECK_NO2
	LPARAMETER PAULDBF , PAULID , PAULSEEK , PAULWARN , PAULWARN1 , PAULCURRNO , PAULCONDITION
	LOCAL SEEK_YN , SET_DELETED , SELECT_WK , SET_EXACT
	SELECT_WK = SELECT()
	SET_DELETED = SET('DELETED')
	SET_EXACT = SET('EXACT')
	IF USED('pauldbfDOCUPDATE')
		USE IN PAULDBFDOCUPDATE
	ENDIF
	PAULDBFDOCUPDATE = 'pauldbfDOCUPDATE'
	IF  .NOT. USED('pauldbfDOCUPDATE')
		use (pauldbf) alias pauldbfDOCUPDATE order &paulseek. in 0 AGAIN
	ENDIF
	SET DELETED OFF
	SET EXACT ON
	SEEK_YN = SEEK(PAULID,'pauldbfDOCUPDATE',PAULSEEK)
	IF  .NOT. EMPTY(PAULCURRNO)
		IF SEEK_YN AND PAULCURRNO = RECNO('pauldbfDOCUPDATE')
			SEEK_YN = .F.
		ENDIF
	ENDIF
	IF  .NOT. EMPTY(PAULCONDITION)
		IF SEEK_YN .AND. &paulcondition.
			SEEK_YN = .F.
		ENDIF
	ENDIF
	SET EXACT &SET_EXACT.
	IF  .NOT. EMPTY(PAULWARN)
		IF SEEK_YN
			IF DELETED('pauldbfDOCUPDATE')
				= PAULMESSAGE('This Document ID/Code already exists in Rubbish Bin !')
			ELSE
				= PAULMESSAGE(PAULWARN)
			ENDIF
		ENDIF
	ELSE
		IF SEEK_YN
			IF DELETED('pauldbfDOCUPDATE')
				SEEK_YN = .F.
				= PAULMESSAGE(PAULWARN1)
			ENDIF
		ELSE
			IF  .NOT. EMPTY(PAULWARN1)
				= PAULMESSAGE(PAULWARN1)
			ENDIF
		ENDIF
	ENDIF
	IF USED('pauldbfDOCUPDATE')
		USE IN PAULDBFDOCUPDATE
	ENDIF
	SET DELETED &SET_DELETED.
	SELECT (SELECT_WK)
	RETURN SEEK_YN
ENDPROC
*------
PROCEDURE ITDELETEDATA
	LPARAMETER PAULDBF , PAULSEEKEXP , PAULSEEKDBF , PAULSEEKID , PAULYES , PAULFIELDNAME1 ,  ;
		PAULFIELDNAME2 , PAULFIELDNAME3 , PAULREP1 , PAULWITH1 , PAULREP2 ,  ;
		PAULWITH2 , PAULREP3 , PAULWITH3
	LOCAL SELECT_WK , SET_EXACT , SET_NEAR , SEEK_RECORD
	IF EMPTY(PAULSEEKEXP)
		RETURN 'FAILED - EMPTY'
	ENDIF
	SELECT_WK = SELECT()
	IF USED('ITDELETEDATA')
		USE IN ITDELETEDATA
	ENDIF
	USE IN 0 (PAULDBF) AGAIN ALIAS ITDELETEDATA ORDER paulSEEKID
	SELECT ITDELETEDATA
	VSET_NEAR = SET('NEAR')
	VSET_EXACT = SET('EXACT')
	SET NEAR OFF
	SET EXACT ON
	SET DELETED ON
	GO TOP
	SEEK PAULSEEKEXP
	DO WHILE MACROS  ???FUN[CA] ('paulSEEKEXP=&paulYES. .AND. .NOT. EOF()')
		IF  paulSEEKEXP=&paulYES.
			IF  .NOT. EMPTY(PAULREP1)
				REPLACE &paulREP1. WITH &paulWITH1.
				WAIT WINDOW &paulFIELDNAME1. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP2)
				REPLACE &paulREP2. WITH &paulWITH2.
				WAIT WINDOW &paulFIELDNAME2. NOWAIT
			ENDIF
			IF  .NOT. EMPTY(PAULREP3)
				REPLACE &paulREP3. WITH &paulWITH3.
				WAIT WINDOW &paulFIELDNAME3. NOWAIT
			ENDIF
			IF VARTYPE(ADATETIME) = 'T'
				REPLACE ADATETIME WITH DATETIME()
			ENDIF
			IF VARTYPE(DDATE) = 'C'
				REPLACE DDATE WITH PAULUSER_CREATE()
			ENDIF
			DELETE IN ITDELETEDATA
		ENDIF
		SKIP
	ENDDO
	IF USED('ITDELETEDATA')
		USE IN ITDELETEDATA
	ENDIF
	SET NEAR  &VSET_NEAR.
	SET EXACT &VSET_EXACT.
	SELECT (SELECT_WK)
	RETURN 'OK'
ENDPROC
*------
PROCEDURE itNavigator
	LPARAMETER PAULDBF , PAULMODE , PAULID , PAULWARN1 , PAULWARN2 , PAULWARN3 , PAULWARN4
	LOCAL SEEK_YN , SET_DELETED , SELECT_WK
	IF  .NOT. EMPTY(PAULMODE)
		IF PAULMODE <> 'R'
			= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN3),PAULWARN3,'This function is inaccessible ! You are in ADD/EDIT mode !'))
			APPEND_YN = .F.
			RETURN .F.
		ENDIF
	ENDIF
	IF  .NOT. USED(PAULDBF)
		= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN4),PAULWARN4,'This function is inaccessible !  The table name is not found ! ' + PAULDBF))
		APPEND_YN = .F.
		RETURN .F.
	ENDIF
	PAULID = UPPER(ALLTRIM(PAULID))
	IF PAULID = 'LAST'
		SELECT (PAULDBF)
		GO BOTTOM
		IF EOF() .OR. BOF()
			= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN1),PAULWARN1,'End of record !'))
			APPEND_YN = .F.
			RETURN .F.
		ENDIF
		APPEND_YN = .T.
		RETURN .T.
	ENDIF
	IF PAULID = 'FIRST'
		SELECT (PAULDBF)
		GO TOP
		IF EOF() .OR. BOF()
			= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN2),PAULWARN2,'Top of record !'))
			APPEND_YN = .F.
			RETURN .F.
		ENDIF
		APPEND_YN = .T.
		RETURN .T.
	ENDIF
	IF PAULID = 'NEXT'
		SELECT (PAULDBF)
		IF EOF()
			= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN1),PAULWARN1,'End of record !'))
			APPEND_YN = .F.
			RETURN .F.
		ENDIF
		IF  .NOT. EOF()
			RECORD_NUM = RECNO()
		ELSE
			RECORD_NUM = 0
		ENDIF
		IF  .NOT. EOF() AND  .NOT. BOF()
			SKIP 1
		ENDIF
		IF EOF()
			IF RECORD_NUM <> 0
				GO RECORD_NUM
				= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN1),PAULWARN1,'End of record !'))
				APPEND_YN = .F.
				RETURN .F.
			ENDIF
		ENDIF
		APPEND_YN = .T.
		RETURN .T.
	ENDIF
	IF PAULID = 'PRIOR'
		SELECT (PAULDBF)
		IF BOF()
			= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN2),PAULWARN2,'Top of record !'))
			APPEND_YN = .F.
			RETURN .F.
		ENDIF
		IF  .NOT. BOF()
			RECORD_NUM = RECNO()
		ELSE
			RECORD_NUM = 0
		ENDIF
		IF  .NOT. BOF() AND  .NOT. EOF()
			SKIP -1
		ENDIF
		IF BOF()
			IF RECORD_NUM <> 0
				GO RECORD_NUM
				= PAULMESSAGE(IIF( .NOT. EMPTY(PAULWARN2),PAULWARN2,'Top of record !'))
				APPEND_YN = .F.
				RETURN .F.
			ENDIF
		ENDIF
		APPEND_YN = .T.
		RETURN .T.
	ENDIF
	= PAULMESSAGE('Invalid function call !')
	APPEND_YN = .F.
	RETURN .F.
ENDPROC
*------
PROCEDURE itgetacrate
	LPARAMETER VCCY , VRATE , VDATE , VCHECKIF , VFIELD , VCLOSEDBF
	LOCAL VPLGETRANGEDBFWK
	VPLGETRANGEDBFWK = SELECT()
	SET_EXACT = SET('exact')
	SET_NEAR = SET('near')
	VRATERETURN = 0
	IF EMPTY(VCCY) .OR. EMPTY(VDATE)
		RETURN VRATE
	ENDIF
	IF  .NOT. EMPTY(VCHECKIF)
		IF UPPER(VCHECKIF) = 'Y'
			RETURN VRATE
		ENDIF
	ENDIF
	IF  .NOT. USED('itgetaccrate')
		USE IN 0 currrate AGAIN ALIAS ITGETACCRATE ORDER period
	ENDIF
	IF EMPTY(VFIELD)
		VFIELD = 'itgetaccrate.acct_rate'
	ENDIF
	SELECT ITGETACCRATE
	GO TOP
	SET EXACT OFF
	SET NEAR ON
	VSEEKVALUE =  ;
		VCCY + ALLTRIM(STR(YEAR(VDATE)) + RIGHT('0' + ALLTRIM(STR(MONTH(VDATE))),2))
	SELECT ITGETACCRATE
	GO TOP
	SEEK VSEEKVALUE
	IF FOUND()
		if &vfield. <>0
			vratereturn=&vfield.
		ENDIF
	ENDIF
	IF  .NOT. EMPTY(VCLOSEDBF)
		IF VCLOSEDBF = 'Y'
			USE IN ITGETACCRATE
		ENDIF
	ENDIF
	set exact &set_exact.
	set near &set_near.
	SELECT (VPLGETRANGEDBFWK)
	IF VRATERETURN = 0
		RETURN VRATE
	ELSE
		RETURN VRATERETURN
	ENDIF
ENDPROC
*------
PROCEDURE ITSQLSendMail
	LPARAMETER SYS_SETTINGS , CTO , CCC , CBCC , CSUBJECT , CBODY , CATTACHMENT , CFROM ,  ;
		CFROMNAME , CREPLYTO , CADDRECIPIENT , CCHARSET , CBODYTYPE , VERROR ,  ;
		CUSERNAME , CPASSWORD , CSMTP , CMAILSERVERPASSWORD , CMAILSERVERUSERNAME
	VERROR = 'OK'
	ON ERROR VERROR='FAIL: Error number: ' + LTRIM(STR(ERROR( )))+ ' Error message: ' + MESSAGE( )+ ' Line of code with error: ' +  MESSAGE(1) + ' Line number of error: ' + LTRIM(STR(LINENO( )))+ ' Program with error: ' + PROGRAM( )
	SET NEAR ON
	SET EXACT OFF
	SET SAFETY OFF
	SET TALK OFF
	SET DELETED ON
	SET EXCLUSIVE OFF
	SET_DATAPATH = SUBSTR(SYS_SETTINGS,1,AT(';',SYS_SETTINGS,1) - 1)
	DATETYPE =  ;
		UPPER(SUBSTR(SYS_SETTINGS,AT(';',SYS_SETTINGS,6) + 1,AT(';',SYS_SETTINGS,7) - AT(';',SYS_SETTINGS,6) - 1))
	IF EMPTY(DATETYPE)
		SET DATE TO DMY
	ELSE
		SET DATE TO &datetype.
	ENDIF
	CSMTPSELECT = ''
	IF  .NOT. EMPTY(CSMTP)
		CSMTPSELECT = CSMTP
	ENDIF
	IF EMPTY(CUSERNAME) .OR. EMPTY(CPASSWORD)
		IF USED('crmsetup')
			USE IN CRMSETUP
		ENDIF
		VUSEDDBF = ALLTRIM(SET_DATAPATH) + 'crmsetup'
		IF AT('.',VUSEDDBF) = 0
			IF FILE(VUSEDDBF + '.wsd')
				VUSEDDBF = VUSEDDBF + '.wsd'
			ENDIF
		ENDIF
		use &vuseddbf. alias crmsetup in 0  again SHARED
		SELECT CRMSETUP
		IF VARTYPE(MAILPSW) = 'C'
			CMAILSERVERPASSWORD = CRMSETUP.MAILPSW
			CMAILSERVERUSERNAME = CRMSETUP.MAILUSER
		ENDIF
		CUSERNAME = ALLTRIM(CRMSETUP.USERNAME)
		CPASSWORD = ALLTRIM(CRMSETUP.PASSWORD)
		CSMTP = ALLTRIM(CRMSETUP.SMTP)
		CSMTPSELECT = ALLTRIM(CRMSETUP.SMTP)
		CSMTP0 = ALLTRIM(CRMSETUP.SMTP)
		CSMTP1 = ALLTRIM(CRMSETUP.SMTP1)
		CSMTP2 = ALLTRIM(CRMSETUP.SMTP2)
		CSMTP3 = ALLTRIM(CRMSETUP.SMTP3)
		CSMTP4 = ALLTRIM(CRMSETUP.SMTP4)
		CSMTP5 = ALLTRIM(CRMSETUP.SMTP5)
		IF EMPTY(CMAILSERVERPASSWORD) AND EMPTY(CMAILSERVERUSERNAME)
			CMAILSERVERPASSWORD = CPASSWORD
			CMAILSERVERUSERNAME = CUSERNAME
		ENDIF
		IF EMPTY(CREPLYTO) AND VARTYPE(REPLYTO) = 'C'
			CREPLYTO = ALLTRIM(CRMSETUP.REPLYTO)
		ENDIF
		NSMTPTRY = 0
		NSMTPTRY1 = 0
		NSMTPTRY2 = 0
		NSMTPTRY3 = 0
		NSMTPTRY4 = 0
		NSMTPTRY5 = 0
		NOFSMTP = 0
		IF  .NOT. EMPTY(CRMSETUP.SMTP1)
			NOFSMTP = NOFSMTP + 1
		ENDIF
		IF  .NOT. EMPTY(CRMSETUP.SMTP2)
			NOFSMTP = NOFSMTP + 1
		ENDIF
		IF  .NOT. EMPTY(CRMSETUP.SMTP3)
			NOFSMTP = NOFSMTP + 1
		ENDIF
		IF  .NOT. EMPTY(CRMSETUP.SMTP4)
			NOFSMTP = NOFSMTP + 1
		ENDIF
		IF  .NOT. EMPTY(CRMSETUP.SMTP5)
			NOFSMTP = NOFSMTP + 1
		ENDIF
		IF EMPTY(CFROM) AND VARTYPE(FROM) = 'C'
			CFROM = CRMSETUP.FROM
		ELSE
			CFROM = ''
		ENDIF
		IF EMPTY(CFROMNAME) AND VARTYPE(FROMNAME) = 'C'
			CFROMNAME = ALLTRIM(CRMSETUP.FROMNAME)
		ELSE
			CFROMNAME = ''
		ENDIF
		IF EMPTY(CREPLYTO) AND VARTYPE(REPLYTO) = 'C'
			CREPLYTO = ALLTRIM(CRMSETUP.REPLYTO)
		ELSE
			CREPLYTO = ''
		ENDIF
		CSMTPSELECT = 'cSmtp' + ALLTRIM(STR(ROUND(RAND() * NOFSMTP + 0.5,0)))
		cSmtpselect=&cSmtpselect.
		IF  .NOT. EMPTY(CSMTP) AND EMPTY(CSMTPSELECT)
			CSMTPSELECT = CSMTP
		ENDIF
		IF USED('crmsetup')
			USE IN CRMSETUP
		ENDIF
	ENDIF
	NSMTPTRY0 = 0
	VCOUNTER = 0
	VMAILCOUNTER = 0
	VKEY_VALUE = ''
	VNOOFSECONDS = DATETIME()
	IF  .NOT. LCISSTRING(CTO) AND  .NOT. LCISSTRING(CCC)
		VERROR = 'FAIL: Please sure the recipient or cc not empty .'
		RETURN VERROR
	ENDIF
	IF  .NOT. LCISSTRING(CUSERNAME)
		VERROR = 'FAIL: Please sure the smtp username not empty.'
		RETURN VERROR
	ENDIF
	IF  .NOT. LCISSTRING(CPASSWORD)
		VERROR = 'FAIL: Please sure the smtp password not empty.'
		RETURN VERROR
	ENDIF
	IF  .NOT. LCISSTRING(CSMTPSELECT)
		RETURN 'FAIL: Please sure the smtp is not empty.'
	ENDIF
	IF  .NOT. LCISSTRING(CFROM)
		CFROM = CUSERNAME + '@' + SUBSTR(CSMTPSELECT,AT('.',CSMTPSELECT) + 1)
	ENDIF
	IF EMPTY(CCHARSET)
		CCHARSET = 'UTF-8'
	ELSE
		CCHARSET = UPPER(ALLTRIM(CCHARSET))
	ENDIF
	OJMAIL = CREATEOBJECT('Jmail.Message')
	IF EMPTY(CFROMNAME)
		CFROMNAME = UPPER(SUBSTR(CFROM,1,1)) + SUBSTR(CFROM,2,AT('@',CFROM) - 2)
	ENDIF
	IF EMPTY(CREPLYTO)
		CREPLYTO = CFROM
	ENDIF
	OJMAIL.LOGGING = .T.
	OJMAIL.SILENT = .T.
	OJMAIL.FROMNAME = ALLTRIM(CFROMNAME)
	OJMAIL.FROM = ALLTRIM(CFROM)
	OJMAIL.REPLYTO = ALLTRIM(CREPLYTO)
	OJMAIL.CONTENTTRANSFERENCODING = 'base64'
	OJMAIL.PRIORITY = 3
	IF EMPTY(CADDRECIPIENT)
		CADDRECIPIENT = ''
	ELSE
		OJMAIL.ADDRECIPIENT = ALLTRIM(CADDRECIPIENT)
	ENDIF
	IF LCISSTRING(CTO)
		FOR NTAG = 1 TO OCCURS(';',CTO) + 1
			IF ',' $ LCSUBSTR(CTO,';',NTAG)
				OJMAIL.ADDRECIPIENT(LCSUBSTR(LCSUBSTR(CTO,';',NTAG),',',1),LCSUBSTR(LCSUBSTR(CTO,';',NTAG),',',2))
			ELSE
				OJMAIL.ADDRECIPIENT(LCSUBSTR(CTO,';',NTAG))
			ENDIF
		ENDFOR
	ENDIF
	IF LCISSTRING(CCC)
		FOR NTAG = 1 TO OCCURS(';',CCC) + 1
			IF ',' $ LCSUBSTR(CTO,';',NTAG)
				OJMAIL.ADDRECIPIENTCC(LCSUBSTR(LCSUBSTR(CCC,';',NTAG),',',1),LCSUBSTR(LCSUBSTR(CCC,';',NTAG),',',2))
			ELSE
				OJMAIL.ADDRECIPIENTCC(LCSUBSTR(CCC,';',NTAG))
			ENDIF
		ENDFOR
	ENDIF
	IF LCISSTRING(CBCC)
		FOR NTAG = 1 TO OCCURS(';',CBCC) + 1
			IF ',' $ LCSUBSTR(CTO,';',NTAG)
				OJMAIL.ADDRECIPIENTBCC(LCSUBSTR(LCSUBSTR(CBCC,';',NTAG),',',1),LCSUBSTR(LCSUBSTR(CBCC,';',NTAG),',',2))
			ELSE
				OJMAIL.ADDRECIPIENTBCC(LCSUBSTR(CBCC,';',NTAG))
			ENDIF
		ENDFOR
	ENDIF
	OJMAIL.SUBJECT = IIF(LCISSTRING(CSUBJECT),CSUBJECT,'')
	IF EMPTY(CBODYTYPE)
		CBODYTYPE = 'HTML'
	ENDIF
	IF LOWER(ALLTRIM(CBODYTYPE)) = 'text'
		OJMAIL.BODY = IIF(LCISSTRING(CBODY),CBODY,'')
	ELSE
		OJMAIL.HTMLBODY = STRTRAN(CBODY,CHR(13),'<br>')
	ENDIF
	IF LCISSTRING(CATTACHMENT)
		FOR NTAG = 1 TO OCCURS(';',CATTACHMENT) + 1
			OJMAIL.ADDATTACHMENT(LCSUBSTR(CATTACHMENT,';',NTAG))
		ENDFOR
	ENDIF
	OJMAIL.CHARSET = CCHARSET
	IF  .NOT. EMPTY(CMAILSERVERPASSWORD) AND  .NOT. EMPTY(CMAILSERVERUSERNAME)
		OJMAIL.MAILSERVERPASSWORD = ALLTRIM(CMAILSERVERPASSWORD)
		OJMAIL.MAILSERVERUSERNAME = ALLTRIM(CMAILSERVERUSERNAME)
	ENDIF
	IF OJMAIL.SEND(CSMTPSELECT)
		RETURN 'OK'
	ELSE
		CSMTPSELECT = 'cSmtp' + ALLTRIM(STR(ROUND(RAND() * NOFSMTP + 0.5,0)))
		cSmtpselect=&cSmtpselect.
		IF OJMAIL.SEND(CSMTPSELECT)
			RETURN 'OK'
		ELSE
			CSMTPSELECT = 'cSmtp' + ALLTRIM(STR(ROUND(RAND() * NOFSMTP + 0.5,0)))
			cSmtpselect=&cSmtpselect.
			IF OJMAIL.SEND(CSMTPSELECT)
				RETURN 'OK'
			ELSE
				RETURN 'FAIL: ' + OJMAIL.ERRORMESSAGE
			ENDIF
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE LcIsString
	LPARAMETER CSTRING , LFORCE
	IF LFORCE
		IF VARTYPE(CSTRING) <> 'C'
			RETURN .F.
		ELSE
			RETURN .T.
		ENDIF
	ELSE
		IF VARTYPE(CSTRING) <> 'C' .OR. EMPTY(ALLTRIM(CSTRING))
			RETURN .F.
		ELSE
			RETURN .T.
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE LcSubstr
	LPARAMETER SUBSTR_VALUE , SUBSTR_PLUS , SUBSTR_INDEX , SUBSTR_TRIM
	IF VARTYPE(SUBSTR_VALUE) <> 'C' .OR. EMPTY(SUBSTR_VALUE)
		RETURN ''
	ENDIF
	IF VARTYPE(SUBSTR_TRIM) <> 'L'
		SUBSTR_TRIM = .F.
	ENDIF
	IF VARTYPE(SUBSTR_PLUS) <> 'C' .OR. ASC(SUBSTR_PLUS) = 0
		SUBSTR_PLUS = ','
	ENDIF
	IF VARTYPE(SUBSTR_INDEX) <> 'N'
		SUBSTR_INDEX = 0
	ELSE
		IF SUBSTR_INDEX < 0
			SUBSTR_INDEX = 0
		ENDIF
	ENDIF
	IF  .NOT. (SUBSTR_PLUS $ SUBSTR_VALUE) .OR. SUBSTR_INDEX = 0
		IF SUBSTR_TRIM
			RETURN ALLTRIM(SUBSTR_VALUE)
		ELSE
			RETURN SUBSTR_VALUE
		ENDIF
	ENDIF
	SUBSTR_VALUE = STRTRAN(SUBSTR_VALUE,SUBSTR_PLUS,CHR(13) + CHR(10))
	IF ALINES(SUBSTR_ARRAY,SUBSTR_VALUE) < 2
		IF SUBSTR_TRIM
			RETURN ALLTRIM(SUBSTR_VALUE)
		ELSE
			RETURN SUBSTR_VALUE
		ENDIF
	ELSE
		IF ALEN(SUBSTR_ARRAY) >= SUBSTR_INDEX
			IF SUBSTR_TRIM
				RETURN ALLTRIM(SUBSTR_ARRAY(SUBSTR_INDEX))
			ELSE
				RETURN SUBSTR_ARRAY(SUBSTR_INDEX)
			ENDIF
		ELSE
			IF SUBSTR_TRIM
				RETURN ALLTRIM(SUBSTR_ARRAY(ALEN(SUBSTR_ARRAY)))
			ELSE
				RETURN SUBSTR_ARRAY(ALEN(SUBSTR_ARRAY))
			ENDIF
		ENDIF
	ENDIF
ENDPROC
*------
PROCEDURE GbConvert
	LPARAMETER LCVALUE , LCTYPE
	IF PARAMETERS() < 2
		WAIT WINDOW NOWAIT 'Please type the convert value and convert type !'
		RETURN ''
	ENDIF
	IF VARTYPE(LCVALUE) <> 'C'
		WAIT WINDOW NOWAIT 'Please sure the convert value in character ! '
		RETURN ''
	ELSE
		IF EMPTY(LCVALUE)
			RETURN ''
		ENDIF
	ENDIF
	IF VARTYPE(LCTYPE) <> 'N'
		WAIT WINDOW NOWAIT 'Please sure the convert type in number !'
		RETURN ''
	ELSE
		IF  .NOT. (LCTYPE = 1 .OR. LCTYPE = 2)
			WAIT WINDOW NOWAIT 'Please sure the convert type in 1 or 2 !'
			RETURN ''
		ENDIF
	ENDIF
	LOCAL CONERROR , LERRORED
	CONERROR = ON('Error')
	ON ERROR lErrored=.T.
	DECLARE INTEGER GBToBig5 IN 'mchset.dll' STRING @
	DECLARE INTEGER Big5ToGB IN 'mchset.dll' STRING @
	On Error &cOnError.
	IF LERRORED
		WAIT WINDOW NOWAIT 'Can not found mchset.dll .'
		RETURN LCVALUE
	ENDIF
	IF LCTYPE = 1
		GBTOBIG5(@LCVALUE)
	ELSE
		BIG5TOGB(@LCVALUE)
	ENDIF
	RETURN LCVALUE
ENDPROC
*------*
